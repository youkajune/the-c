[toc]

# Unit 1. 初识编程

## 编程语言

### 硬件和软件

计算机硬件是指现实中存在的，能够看得见摸得着的计算机部件。例如，CPU、主板等。

计算机软件则是在现实中并不存在，摸不到的。例如，QQ、WX这些都是软件，甚至运行这些软件的操作系统都是软件。

而软件其实就是由编程语言来编写的。

### 编程语言的发展

计算机只能识别由0和1组成的机器语言，因此早期的程序是使用机器语言来编写的。但使用机器语言来进行编程非常的不方便，程序员需要记住一系列0和1组成的命令，学习成本非常高，因此在早期，编写计算机的程序员往往都是高等院校的研究员。

后来在机器语言的基础上出现了汇编语言，汇编语言使用一些英文单词来代替机器语言由0和1组成的命令，这使得汇编语言在学习成本和编写程序的效率上远高于机器语言。但是汇编语言编写的程序需要先转换成机器语言，再由计算机执行，这使得机器语言编写的程序效率高于汇编语言。

随着计算机软件、硬件的发展，又出现了一系列的高级编程语言，高级编程语言相比汇编语言，高级编程语言对程序员更友好，程序的执行效率会比汇编语言稍低，不过由于现在的计算机执行速度很快，因此这点执行效率并不会让用户感到程序执行慢。

而 C 语言就是一种高级编程语言。

## C 语言

### 介绍

C语言是一门功能强大的专业化编程语言，深受程序员的喜爱。

C语言有很多优点：

- C语言的设计特性让用户可以轻松的完成自顶向下的规划、结构化编程和模块化设计。
- C语言是高效的语言。相比很多其他的编程语言，C语言运行速度很快。
- C语言是可移植的语言。
- C语言功能强大且灵活。

人无完人，金无足赤。C语言也有一些缺点，C语言给予了程序员很大的灵活性，相对的，程序员编写程序时也就需要更加警惕。

### 应用

C语言主要应用于底层开发，和硬件打交道，如操作系统，嵌入式开发，或者要求效率，高可移植性的地方。比较常见的 C 程序就是操作系统、驱动程序。

### 如何编程

> 为了让读者对编程有大概的了解，我们把编写 C 程序的过程分解为 7 个步骤，如下图所示。需要注意的是，这是理想状态，在实际的使用过程中，尤其是在较大型项目中，可能要做一些重复的工作，根据下一个步骤的情况来调整或改进上一个步骤。—— 《C Primer Plus》

1. **确定程序目标**。想要做什么事、需要什么信息(输入信息)、需要进行那些计算、获得什么结果(输出信息)
2. **设计程序**。如何表示数据、用什么方法处理数据、怎样组织程序、用户界面是什么样的、...
3. **编写代码**。此时才是真正开始书写代码。
4. **编译源代码**。编译的作用：检查C语言程序的编写是否有错误；将源代码编译为计算机能够识别的指令集(即目标代码文件)；将源代码编译后的文件和C库代码、启动代码合并为可执行文件。

> PS：通过编译的代码叫做目标代码文件，目标代码文件不能直接运行，还缺少启动代码和库函数，需要通过链接将其合并为一个文件。

1. **运行程序**。编译之后会生成一个可执行文件(exe)，可通过双击的形式直接在操作系统中运行。
2. **测试和调试程序**。两个名词：bug —— 程序中的一些错误；调试 —— 查找并修复程序错误的过程。
3. **维护和修改代码**。创建完程序之后，发现程序有错或者想要扩展程序用途，就需要修改程序。

## 编译

### 什么是编译？

C语言只是我们人能读懂的语言，在计算机眼中C语言就是外星文，根本看不懂，计算机只能识别机器语言，所以我们需要将C语言“翻译”为机器语言，这个过程就是编译。

这里就有两点：1. 为什么不直接用机器语言编程，而是使用C语言？2. 如何将C语言翻译为机器语言？
1.为什么不直接用机器语言变成而是使用C语言？因为机器语言是一串0、1码，非常难以记忆和阅读，是人难以理解的一种语言，但是对于计算机而言就是非常容易理解的；而C语言则相反，C语言使用人比较容易理解的方式，而计算机是无法理解的。
2.如何将C语言翻译为机器语言？C语言是由编译器来将我们写的C语言程序翻译为计算机可以理解的**指令集** —— 这就是编译的过程。



### 编译的好处

首先，**使用人容易理解的语言来进行编程，可以提高编程效率**。使用C语言编程的过程可以理解为写文件的时候使用中文写，然后找专业的翻译人员将其翻译为英文，然后将这个英文文件交由处理人员，处理人员就可以根据你写的这份英文文件的步骤进行操作。而使用机器语言编程的过程就需要你查找你陌生的英文将其翻译为英文文件，交由处理人员。可以想象，对于一个对英文不熟悉的人来说，这效率可以说非常低了。

其次，**程序的可移植性**。之前讲过，编译就是将C语言编译为计算机可以识别的指令集，说到指令集，我们要知道不同 CPU 的指令集是不同的，比如 Intel 和 AMD 的 CPU 指令集就完全不同，这代表着在 Intel 的 CPU 中可以运行的指令集放在 AMD 的 CPU 中可能就完全无法理解需要做什么。
程序的可移植性的意思就是我们写好的源代码移动到另一台计算机中依旧可以执行。
C语言的可移植性是如何保证的？不同的CPU使用的指令集不同，通过不同的编译器，可以将同一个C语言代码转换成不同CPU可以识别的机器语言指令集程序，以适应不同的CPU环境。这样我们将源代码移动到另一台计算机中，在该计算机中会将其编译为这台计算机可以理解的指令集。

### 编译型语言和解释型语言

解释型语言由于是在运行时进行“翻译”，因此程序运行效率较低(边运行边翻译)，但是每次修改源代码不需要重新编译；而编译型语言在运行之前进行“翻译”，因此程序运行效率较高(只运行)，但每次修改源代码之后需要进行重新编译。



**编译型语言和解释型语言举例：**编译型语言举例：C、C++ 等；解释型语言举例：Python、JavaScript 等。
学习编程的过程中，一定会听到另一个大名 —— Java，Java 有点特殊，Java 先将源代码编译为 .class 文件，然后再由 JVM 在程序运行时来将 .class 文件解释为机器语言。因此 Java 是编译型语言还是解释型语言是有争议的。我比较倾向于 Java 是编译型语言。

## 入门代码 —— Hello, World

### Hello, World 代码

学习编程的第一个程序一般都是经典的控制台输出 Hello, World! 的程序，这表示我们开启了一个编程的大门，进入到编程世界。

```c
#include <stdio.h>
int main(void)
{
    /* 我的第一个 C 程序 */
    printf("Hello, World! \n");
    return 0;
}
```

下面简单的解读一下这个C程序：

首先，\#表示后面跟着的是预处理语句，与include合起来的\#include 表示包含另一个文件，这里包含的是 stdio.h 文件

其次，`int main(void)`，int 表示返回值是 int 类型，() 中的 void 表示没有参数。这条语句还可以写成 `int main()` 或者 `void main(void)` 或者 `void main()`

> 如果返回值类型为 void ，程序{ }中最后的 return 语句需要去掉，但是需要注意的是后面两种写法可能会碰到某些编译器不识别的问题。所以推荐写第一种，第二种其实也可以，int main() 是 C99 标准之前的写法，而 int main(void) 是 C99 标准之后的写法。

第三，`/* 我的第一个 C 程序 */`是注释。编译器在编译时(将C语言翻译成机器能理解的语言)不会编译注释，因此写多少注释都不会影响最后生成的C程序的大小。注释主要是为了帮助程序员理解这部分代码的功能。对于初学者来说，可能会觉得注释没什么用，这是因为目前只能接触到比较简单的程序，而真正的开发过程中代码会比较复杂，并且代码量非常的大，面对成千上万条代码，如果不写注释，当你写好一段代码之后，隔了一个周再回来看这段代码可能都不知道自己当时是怎么写的。C语言提供两种注释 —— 单行注释和多行注释：

1. 单行注释：以 // 开头，直到本行最后都是注释
2. 多行注释：以 / \*开头，\*/ 结尾的都是注释。

> Java 中除了当行注释、多行注释之外，还提供了一个文档注释 /** */，C语言中该注释和多行注释等同。

### 程序可读性

刚才的 Hello, World 程序很简短，但是对于复杂的程序，代码可能有成千上万行，如果程序的可读性很差，那么在维护代码的时候效率会非常低。

提升程序的可读性：

1. 选择有意义的变量名或者函数名
2. 多写注释
3. 在函数中用空行分割概念上的多个部分
4. 每个语句占一行

## 标识符

标识符就是变量、函数、类型等的名字。它们由大小写字母、数字和下划线组成，但不能以数字开头。C 是一种区分大小写的语言。标识符的长度没有限制，但标准允许编译器忽略第 31 个字符以后的字符。

# Unit 2. 基础知识

## 数据

### 什么是数据？

定义：**数据是所有能输入计算机并被计算机程序处理的符号介质的总称**。

### 为什么存储数据？

程序是由指令和数据组成的。在程序的指导下，计算机可以做许多事情，如数值计算、名字排序、执行语言或视频命令、计算彗星轨道、准备邮件列表、拨电话号码、画画、做决策或其他你能想到的事情。

要完成这些任务，就需要存储需要处理的信息。

### 如何存储数据？

为了把信息存储在计算机中，必须记录 3 个基本属性：

- 信息存储在哪里？
- 存储什么类型的信息？
- 存储什么值？

在 C 语言中，我们可以通过声明一个变量来实现存储信息，例如：

```c
int bra;
bra = 5;
```

这些语句告诉程序，正在存储整数，存储的整数值为 5，使用名称 bra 来表示该整数值(这里为 5)。实际上，程序在内存中找到一块能够存储整数的内存，将该内存单元标记为 bra，并将 5 复制到这个内存单元中；然后，可以在代码中使用 bra 来访问该内存单元。虽然这些语句并没有明确表明这个值应该存储在内存的什么位置，但程序确实记录了这种信息。事实上，可以通过 & 运算符来检索 bra 的地址。

## C语言数据类型

![](E:\Note\Code Language\the-c\picture\basic\2-1.png)

在 C 语言的基本数据类型中有整型、浮点型、字符类型。在学习基本数据类型时，我们需要关注这些类型的关键字，占多少字节，取值范围。

### 整型

**什么是整型？**所谓整型，即没有小数的数。它又包括正整数、0、负整数，同样我们的整型数据有正有负，也有0。C 语言提供了多种整数类型，程序员针对不同情况可以选择不同类型，一般情况使用 int 类型即可，但是为满足特定任务和机器要求，可以选择其他类型。

#### 整型 int

内存大小：C 语言规定，int 类型最少占 2 字节，最多不超过 long。对于 16 位编译器来说，int 是 2 字节，对于 32 位和 64 位编译器来说，int 是 4 字节。因为目前常用的是 32 位和 64 位编译器，因此一般来说 int 的范围是 [-2^31, 2^31-1]，即 [-2147483648, 2147483647]。

#### 短整型 short

内存大小：C 语言规定，short 类型最少占 2 字节，最多不超过 int。对于 16 位、32 位、64 位编译器来说，short 类型都是占 2 字节，取值范围是 [-2^15, 2^15 -1]，即 [-32768, 32767]。

#### 长整型 long

内存大小：C 语言规定，long 类型最少占 4 字节。对于 16 位、32 位编译器来说，long 占 4 字节，对于 64 位编译器来说，long 占 64 位。

由于 long 类型在常用的 32 位和 64 位编译器中存储的字节数不同，因此引入 long long 类型，long long 至少占 8 字节。

不同位数的编译器，整型数据所占字节数如下所示。

| **数据类型\编译器位数** | **16** | **32** | **64** |
| ----------------------- | ------ | ------ | ------ |
| **short**               | 2      | 2      | 2      |
| **int**                 | 2      | 4      | 4      |
| **long**                | 4      | 4      | 8      |
| **long long**           | 8      | 8      | 8      |

#### 为什么要使用多种整型?

首先，我们来看看**整型和我们平常所说的整数有什么差别？**

平常所说的整数是无限的，而整型是存储在计算机中的整数，它是有限的，是受限于计算机的存储单元的。之所以使用多种整型，正是因为这些整型由于存储时占据的字节数不同，使得它们的取值范围不同。这样我们就可以根据需要存储的数据的范围来选择使用的整型。

### 浮点型

**什么是浮点型？**所谓浮点型，即有小数的数。是因为小数点的位置可以自由浮动，因此称为浮点数。例如，1.234 和 12.34，虽然他们在大小上一致，但是在存储时有所不同。浮点型有单精度浮点数和双精度浮点数两种，所谓精度指的是能精确表示的有效数字，注意不是小数点后有效数字！！！。

#### 单精度浮点数 float

内存大小：占 4 字节。至少能精确表示6位有效数字。最高位为符号位，紧接着8位为指数位，剩下的23位为尾数位。

#### 双精度浮点数 double

内存大小：占 8 字节。至少能精确10位有效数字。最高位为符号位，紧接着8位为指数位，剩下的52位为尾数位。

### 字符型 char

内存大小：占 1 字节。其本质上是 1 字节的整型。大部分编译器默认 char 类型是有符号的，不过我们常用的是 [0，127] 这一部分，实际上其取值范围是 [-128，127]。

### 构造类型

有的数据比较复杂，我们可能会用到结构、数组等数据形式来表示。

### 指针类型

C 语言的重点内容就是指针和内存管理，所以这一部分呢很重要，在后面的学习中有一章专门讲解。

## 变量

变量这个名词来源于数学，**在计算机语言中变量是储存计算结果或能表示值的抽象概念**，变量可以通过变量名访问存储的值。也就是说，在 C 语言中，可以用变量来存储数据。

变量是一种使用方便的占位符，用于引用计算机内存地址。使用变量时并不需要了解变量在计算机内存中的地址，只要通过变量名引用变量就可以查看或更改变量的值。

变量其实有很多需要学习的知识，包括命名规则、变量类型、类型转换、存储类型等，这里我们先学习较为简单的变量命名，其他部分之后再进行学习。

### 命名规则

对于计算机来说，没有命名不命名的，只有0和1。数据保存在内存中，程序使用数据时，需要知道该数据在内存中的地址，才能使用，而地址是由一系列的0、1组成。之所以要有命名是因为直接使用内存地址的话，不光使用的时候非常麻烦，而且阅读代码的时候也十分难以阅读。

C 语言的命名提供了一个机制，我们为使用的内存地址命了一个名，之后使用这个名字，程序会根据这个名字找到对应的内存地址，使用该数据。另外为了便于日后代码的阅读性，要求**命名时要使用有意义的变量名或标识符**。如果变量名无法清楚地表达自身的用途，可以在注释中进一步说明。

**结论：命名是为了我们编写和阅读代码方便而引入的，为了便于代码阅读，推荐命名时使用有意义的变量名或者标识符。**

C语言的变量命名遵循一下规则：

1. 可以用英文字母、数字、下划线(_) 来命名。
2. 英文字母区分大小写。例如，num、Num、NuM、NUM 是不同的。
3. 首字母不能是数字。
4. 不能使用 C 语言的关键字和保留标识符。

> Java 的命名规则中还可以用美元符号($)来命名，但是 C/C++ 不可以。

### 关键字

关键字是 C 语言中事先被定义了某些用途的词汇。有的用于指定不同的数据类型，例如，int。有的用于控制程序中语句的执行顺序，例如，if。这些我们都会在后面的学习中遇到。

| **分类**         | **关键字**                                                   |
| ---------------- | ------------------------------------------------------------ |
| **数据类型**     | char、short、int、long、float、double、unsigned、**const**、**void** |
| **流程控制**     | if、else、for、while、do...while、switch、case、default、continue、break、return、goto |
| **存储类别**     | static、auto、register、**volatile**                         |
| **其他数据形式** | struct、union、**enum**                                      |
| **其他**         | inline、extern、restrict、sizeof                             |
| **C11 新增**     | ***_Alignas、_Alignof、_Atomic、_Bool、_Complex、_Generic、_Imaginary、_Noreturn、_Static_assert、_Thread_local\*** |

### 变量的声明以及初始化

变量需要先进行声明，之后才能使用变量。下面，我们声明一个 int 类型的变量，并让其存储值 5。

```c
int arb; // 声明变量
arb = 5; // 存储值 5
```

上面的两条语句可以合并为一条初始化语句：

```c
int arb = 5; // 在声明变量的同时赋值的语句称为初始化语句
```

### 常量与变量

有些数据类型在程序使用之前已经预先设定好了，在整个程序的运行过程中没有变化，这些称为常量(constant)。其他数据类型在程序运行期间可能会改变或被赋值，这些称为变量(variable)。

C语言中一般使用 #define 来定义常量，不过后来也引入了 C++ 中的 const 关键字来定义常量。

### 基本数据类型的类型转换

### 自动类型转换

通常，在语句和表达式中应使用类型相同的变量和常量。但是，如果使用混合类型，C 不会像 Pascal 那样停在那里死掉，而是采用一套规则进行自动类型转换。虽然这很便利，但是有一定的危险性，尤其是在无意间混合使用类型的情况下（许多 UNIX 系统都使用 lint 程序检查类型“冲突”。如果选择更高错误级别，许多非 UNIX C编译器也可能报告类型问题）。最好先了解一些**基本的类型转换规则**：

1. 当类型转换出现在表达式时，无论是 unsigned 还是 signed 的 char 和 short 都会被自动转换成 int，如有必要会被转换成 unsigned int。在 K&R 时的 C 中，float 会被自动转换成 double（目前的 C 不是这样）。由于都是从较小类型转换为较大类型，所以这些转换被称为升级（promotion）

   > PS：char、short 转换为 unsigned int 的情况 —— 如果short与int的大小相同，unsigned short就比int大。这种情况下，unsigned short会被转换成 unsigned int。

2. 涉及两种类型的运算，两个值会被分别转换成两种类型的更高级别。

3. 类型的级别从高至低依次是 long double、double、float、unsigned long long、long long、unsigned long、long、unsigned int、int。例外的情况是，当 long 和 int 的大小相同时，unsigned int 比 long 的级别高。之所以 short 和 char 类型没有列出，是因为它们已经被升级到 int 或 unsigned int。

4. 在赋值表达式语句中，计算的最终结果会被转换成被赋值变量的类型。这个过程可能导致类型升级或降级（demotion）。所谓降级，是指把一种类型转换成更低级别的类型。

5. 当作为函数参数传递时，char 和 short 被转换成 int，float 被转换成 double。之后将介绍，函数原型会覆盖自动升级。

类型升级通常都不会有什么问题，但是类型降级会导致真正的麻烦。原因很简单：较低类型可能放不下整个数字。例如，一个 8 位的 char 类型变量储存整数 101 没问题，但是存不下 22334。



如果待转换的值与目标类型不匹配怎么办？这取决于转换涉及的类型。待赋值的值与目标类型不匹配时，规则如下：

1. 如果目标类型是无符号整型，且待赋的值是整数时，额外的位将被忽略。例如，如果目标类型是 8 位 unsigned char，待赋的值是原始值求模 256。 
2. 如果目标类型是一个有符号整型，且待赋的值是整数，结果因实现而异。
3. 如果目标类型是一个整型，且待赋的值是浮点数，该行为是未定义的。

如果把一个浮点值转换成整数类型会怎样？当浮点类型被降级为整数类型时，原来的浮点值会被截断。例如，23.12 和 23.99 都会被截断为 23，-23.5 会被截断为 -23。

### 强制类型转换

通常，应该避免自动类型转换，尤其是类型降级。但是如果能小心使用，类型转换也很方便。我们前面讨论的类型转换都是自动完成的。然而，有时需要进行精确的类型转换，或者在程序中表明类型转换的意图。这种情况下要用到强制类型转换（cast），即在某个量的前面放置用圆括号括起来的类型名，该类型名即是希望转换成的目标类型。圆括号和它括起来的类型名构成了强制类型转换运算符（cast operator），其通用形式是：(type)，用实际类型替换 type 即可。

```c
int mice;
mice = 1.6 + 1.7;
mice = (int)1.6 + (int)1.7;
```

第 2 行使用自动类型转换。首先 1.6 + 1.7 得 3.3，然后为了匹配 int 类型变量，3.3 被类型转换截断为 3。

第 3 行使用强制类型转换。首先 1.6 和 1.7 被转换为 1，然后将值相加的结果 2 赋值给 mice。

本质上，两种类型转换都好不到哪里去，要考虑程序的具体情况再做取舍。

一般而言，不应该混合使用类型（因此有些语言直接不允许这样做），但是偶尔这样做也是有用的。C语言的原则是避免给程序员设置障碍，但是程序员必须承担使用的风险和责任。

## 控制台输入输出

目前我们已经学习了基本数据类型，但是在使用的过程中，都是我们在代码中固定好了变量存储的值，这样很不灵活，现在期望能够在程序运行的过程中输入变量的，这就需要用到 C 语言提供的输入输出函数 scanf 和 printf 了。

### 输出数据的函数

**语法**：`printf(格式字符串，[参数列表]);`
**注意**：使用 printf 打印数据时，待打印的数据的类型一定要和格式字符串中的转换说明相匹配！！！

例如，我们的第一个 C 语言程序输出了 Hello, World：

```c
#include <stdio.h>
int main()
{
    printf("Hello, World");
    return 0;
}
```

但是这样只能输出固定的字符串，没有办法出来变量的值输出，想要输出变量值需要使用格式转换符来占位。

#### 格式转换符

scanf() 和 printf() 输入输出数据时都需要使用格式转换符来进行占位。

| **格式转换符** | **说明**                          |
| -------------- | --------------------------------- |
| %d             | 有符号，十进制数                  |
| %u             | 无符号，十进制数                  |
| %o             | 八进制                            |
| %x             | 十六进制                          |
| %#o、%#x       | 带前缀的八进制和十六进制数        |
| %hd、%ho、%hx  | 十进制、八进制和十六进制的 short  |
| %ld、%lo、%lx  | 十进制、八进制和十六进制的 long   |
| %f             | float 和 double 类型浮点数        |
| %e             | 指数计数法的 float 和 double      |
| %lf            | long double 类型浮点数            |
| %.nf           | 保留小数点后n位的浮点数(四舍五入) |
| %c             | 字符                              |
| %s             | 字符串                            |
| %p             | 指针                              |
| %%             | 打印一个 % 号，相当于转义 %       |

```c
#include <stdio.h>
int main(void)
{
    int a = 17;
    double b = 5.5;
    char c = 'A';
    printf("a=%d, b=%f, c=%c", a, b, c);
    printf("十进制:a=%d, 八进制:a=%o, 十六进制:a=%x", a, a, a);
    return 0;
}
```

```c
// 输出结果：
a=17, b=5.500000, c=A
十进制:a=17, 八进制:a=21, 十六进制:a=11
```

#### 格式化输出

printf() 可以对输出进行格式化控制。例如，可以控制浮点数小数点后的位数等。

![](E:\Note\Code Language\the-c\picture\basic\2-2.png)

![](E:\Note\Code Language\the-c\picture\basic\2-3.png)

`数字` 表示最小字段宽度。如果需要打印的数据宽度小于该数字，那么在前面自动补空格；如果需要打印的数据宽度大于等于该数字，正常打印。默认是右对齐的，搭配 - 表示左对齐。搭配 0 表示不足补 0，而不是空格。

```c
#include <stdio.h>
int main()
{
    int i = 100;
    printf("*%d*\n",i);
    printf("*%6d*\n",i);
    printf("*%-6d*\n",i);
    printf("*%06d*\n",i);
    getchar();
    return 0;
}
```

```c
// 输出结果：
*100*
*   100*
*100   *
*000100*
```

`.数字` 表示精度。对于浮点数来说，精度就是显示小数点后几位，如果浮点数小数点后位数比这个数字小，则补零；如果浮点数小数点后面位数比这个数字大，则四舍五入。对于整型数来说，精度就是待打印的数据的最小位数，如果待打印数据位数不足，前面补零。

> PS:如果 0 标记和精度一起出现，0 标记会失效。 

```c
printf("*%06.4d*\n",i);// 0标记失效，输出*  0100*
```

#### 转换说明

转换说明把以二进制格式储存在计算机中的值转换成一系列字符（字符串）以便于显示。例如，数字76在计算机内部的存储格式是二进制数 01001100。%d 转换说明将其转换成字符 7 和 6，并显示为 76；%x 转换说明把相同的值（01001100）转换成十六进制记数法 4c；%c 转换说明把 01001100 转换成字符 L。

1. 整数类型的转换说明不匹配；

2. 浮点数类型的转换说明不匹配。

```c
// 转换说明不匹配示例1
short j = -336;
// 将一个负数打印为无符号 short int 类型，输出结果是65200
printf("%hu\n",j);

// 转换说明不匹配示例2
int k = 336;
// 将大于256的数打印为 char 类型，输出结果是 P，其 ASCII 是 80
printf("%c\n",k);
```

![](E:\Note\Code Language\the-c\picture\basic\2-4.png)

```c
// 转换说明不匹配示例3
float  n1 = 3.0;
double n2 = 3.0;
long   n3 = 2000000000;
long   n4 = 1234567890;
// 将 long 类型数据n3和n4打印为 double 类型数据。
printf("%.1e %.1e %.1e %.1e\n", n1, n2, n3, n4);
// 将 double 类型数据n1和n2打印为 long 类型数据。
printf("%ld %ld %ld %ld\n", n1, n2, n3, n4);
```

```c
// 打印为e计数的浮点数
3.0e+000 3.0e+000 3.1e+46 1.7e+266
// 打印为 long 类型数据
0 1074266112 0 1074266112
```

> 具体情况因编译器实现而异。这个结果是《C Prime Plus》中的结果，我在 Windows 下运行的结果是 0 0 2000000000 1234567890，在 Ubuntu 下运行的结果会报错，它严格要求转换说明是匹配的，不允许输出格式是 long 类型，而参数是 double 类型的。

如果printf()语句有其他不匹配的地方，即使用对了转换说明也会生成虚假的结果。用%ld转换说明打印浮点数会失败，但是在这里，用 %ld 打印 long 类型的数竟然也失败了！
**解释**：该调用告诉计算机把变量n1、n2、、n3和n4的值传递给程序。这是一种常见的参数传递方式。程序把传入的值放入被称为栈（stack）的内存区域。 计算机根据变量类型（不是根据转换说明）把这些值放入栈中。因此，n1被储存在栈中，占8字节（float类型被转换成double类型）。同样，n2也在栈中占8字节，而n3和n4在栈中分别占4字节。然后，控制转到printf()函数。该函数根据转换说明（不是根据变量类型）从栈中读取值。%ld转换说明表明 printf()应该读取4字节，所以printf()读取栈中的前4字节作为第1个值。这是 n1的前半部分，将被解释成一个long类型的整数。根据下一个%ld转换说 明，printf()再读取4字节，这是n1的后半部分，将被解释成第2个long类型的 整数（见图4.9）。类似地，根据第3个和第4个%ld，printf()读取n2的前半部分和后半部分，并解释成两个long类型的整数。因此，对于n3和n4，虽然用对了转换说明，但printf()还是读错了字节。

![](E:\Note\Code Language\the-c\picture\basic\2-5.png)

#### printf() 的返回值

printf() **返回打印的字符的个数**，如果输出有错误，则 printf() 返回一个负值。

>  printf() 的返回值是其打印输出功能的附带用途，通常很少用到，但在检查输出错误时可能会用到（如，在写入文件时很常用）。
>
> 注意计算输出的字符个数是针对所有的字符，包括空格和不可见的换行符（\n）。

#### 打印较长字符串时的断行

1. 方法1：使用多个printf()语句。
2. 方法2：用反斜杠（\）和 Enter（或Return）键组合来断行。PS：下一行代码必须从**最左边**开始，如果有缩进，那么缩进的这些空格都会成为字符串的一部分。
3. 方法3：ANSI C引入的字符串连接。在两个用双引号括起来的字符串之 间用空白隔开，C编译器会把多个字符串看作是一个字符串。

```c
// 方法1
printf("Here's one way to print a "); 
printf("long string.\n"); 
// 方法2
printf("Here's another way to print a \ 
long string.\n"); 
// 方法3
printf("Here's the newest way to print a " 
"long string.\n"); // ANSI C
```

### 输入数据的函数

#### 用法

C 语言的库中有多个输入函数，scanf() 是最通用的一个，因为它可以读取不同格式的数据。

scanf() 把输入的字符串转换成整数、浮点数、字符或字符串，而 printf() 正好与它相反，把整数、浮点数、字符和字符串转换成显示在屏幕上的文本。

scanf() 和 printf() 主要的区别在参数列表中，printf() 函数使用变量、常量和表达式，而 scanf() 函数使用指向变量的指针。

如果不了解指针，可以简单的记住下面的两条规则：

1. 如果用scanf()读取基本变量类型的值，在变量名前加上一个&；
1. 如果用scanf()把字符串读入字符数组中，不要使用&。

scanf() 函数所用的转换说明与 printf() 函数几乎相同。主要的区别是，对于 float 类型和 double 类型，printf()都使用%f、%e、%E、%g 和 %G 转换说明。而 scanf() 只把它们用于 float 类型，对于 double 类型时要使用 l 修饰。

#### 读取输入数据的过程

假设 scanf() 根据一个 %d 转换说明读取一个整数。

1. scanf() 函数每次读取一个字符，跳过所有的空白字符，直至遇到第1个非空白字符才开始读取。
   PS：因为要读取整数，所以 scanf() 希望发现一个数字字符或者一个符号(+或-)。
1. 如果找到一个数字或符号，它便保存该字符，并读取下一个字符。
1. 如果下一个字符是数字，它便保存该数字并读取下一个字符。scanf()不断地读取和保存字符，直至遇到非数字字符。
1. 如果遇到一个非数字字符，它便认为读到了整数的末尾。然后， scanf()把非数字字符放回输入。这意味着程序在下一次读取输入时，首先读到的是上一次读取丢弃的非数字字符。
1. 最后，scanf() 计算已读取数字（可能还有符号）相应的数值，并将计算后的值放入指定的变量中。

如果使用字段宽度，scanf()会在字段结尾或第1个空白字符处停止读取 （满足两个条件之一便停止）。

**Q**：如果第1个非空白字符是 A 而不是数字，会发生什么情况？
**A**：scanf() 将停在那里，并把 A 放回输入中，不会把值赋给指定变量。程序在下一次读取输入时，首先读到的字符是 A。如果程序只使用 %d 转换说明， scanf() 就一直无法越过 A 读下一个字符。另外，如果使用带多个转换说明的 scanf()，C规定在第1个出错处停止读取输入。

用其他数值匹配的转换说明读取输入和用 %d 的情况相同。区别在于 scanf() 会把更多字符识别成数字的一部分。

如果使用 %s 转换说明，scanf()会**读取除空白以外的所有字符**。scanf() 跳过空白开始读取第 1 个非空白字符，并保存非空白字符直到再次遇到空白。 **这意味着 scanf() 根据 %s 转换说明读取一个单词**，即不包含空白字符的字符串。如果使用字段宽度，scanf() 在字段末尾或第1个空白字符处停止读取。**无法利用字段宽度让只有一个 %s 的 scanf() 读取多个单词**。最后要注意一点：**当scanf()把字符串放进指定数组中时，它会在字符序列的末尾加上'\0'，让数组中的内容成为一个C字符串**。

#### 格式字符串的普通字符

scanf() 函数允许把普通字符放在格式字符串中。除空格字符外的普通字符必须与输入字符串严格匹配。例如，假设在两个转换说明中添加一个逗号：`scanf("%d,%d", &n, &m);` scanf() 函数将其解释为：用户将输入一个数字、一个逗号，然后再输入一个数字。也就是说，用户必须像`88,121`这样输入两个整数。

#### scanf() 的返回值

scanf() 函数返回成功读取的项数。如果没有读取任何项，或需要读取一个数字而用户却输入一个非数值字符串，scanf() 便返回0。当 scanf() 检测到“文件结尾”时，会返回EOF（EOF是stdio.h中定义的特殊值，通常用 #define 指令把EOF 定义为 -1）。

#### 跳过输入项

把\*放在%和转换字符之间时，会使得 scanf() 跳过相应的输入项。

```c
#include <stdio.h>
int main()
{
    int n;
    printf("Please enter there integers:\n");
    scanf("%*d %*d %d",&n);
    printf("n is %d\n",n);
    return 0;
}
```

输入：2019 2020 2021
输出：n is 2021

在程序需要读取文件中特定列的内容时，这项跳过功能很有用。

### 字符的输入输出

虽然，printf() 和 scanf() 提供了相应的格式转换符，但一般对于字符的输入输出往往采用 getchar() 和 putchar() 这两个函数，它们和 printf() 和 scanf() 一样，都位于 <stdio.h> 文件中，每次只处理一个字符。

你可能认为每次只能处理一个字符实在太笨拙了，毕竟与我们的阅读方式相差甚远。但是，这种方法很适合计算机，而且，这是绝大多数文本（普通文字）处理程序所用的核心方法。

#### 缓冲区示例

编写一个示例程序，要求程序获取从键盘输入的字符，并将这些字符发送到屏幕上，以 # 字符结束。

```c
#include <stdio.h> 
int main(void) 
{
	char ch; 
	while ((ch = getchar()) != '#') 
		putchar(ch); 
	return 0; 
}
```

> PS: getchar() 和 putchar() 其实都不是真正的函数，而是定义为供预处理器使用的宏。

```
// 输出
Hello, there. I would[enter]
Hello, there. I would 
like a #3 bag of potatoes.[enter] 
like a
```

如果是在一些老式系统中运行，可能出现下面的现象：

```
HHeelllloo,, tthheerree.. II wwoouulldd[enter] 
lliikkee aa #
```

#### 缓冲区

**无缓冲输入：** 像用户输入的字符后立即重复打印该字符是属于无缓冲输入，即正在等待的程序可立即使用输入的字符。
**缓冲输入：** 对于该例，大部分系统在用户按下 Enter 键之前不会重复打印刚输入的字符，这种输入形式属于缓冲输入。用户输入的字符被收集并储存在一个被称为缓冲区（buffer）的临时存储区，按下Enter键后，程序才可使用用户输入的字符。

![](E:\Note\Code Language\the-c\picture\basic\2-6.jpg)

**Q：为什么要有缓冲区？**
**A：1. 将若干字符作为一个块进行传输比逐个发送这些字符节约时间；2. 如果用户打错字符，可以直接通过键盘输入修正错误，当按下 Enter 键时，传输的时正确的输入。**

虽然缓冲输入好处很多，但是某些交互式程序也需要无缓冲输入。例如，在游戏中，你希望按下一个键就执行相应的指令(如释放技能)。因此，缓冲输入和无缓冲输入都有用武之地。



**缓冲分为两类：完全缓冲I/O和行缓冲I/O。**

 1. **完全缓冲I/O** 指的是当缓冲区被填满时才刷新缓冲区（内容被发送至目的地），通常出现在文件输入中。缓冲区的大小取决于系统，常见的大小是 512  字节和 4096 字节。
   2. **行缓冲I/O** 指的是在出现换行符时刷新缓冲区。键盘输入通常是行缓冲输入，所以在按下 Enter 键后才刷新缓冲区。

#### 结束键盘输入

文件是存储器中储存信息的区域。通常文件都保存在某种永久存储器中(如，硬盘、U 盘等)。
不同的系统的文件是有差异的。比如，在处理文件方面，有些系统使用单个换行符标记行末尾，而其他系统可能使用回车符和换行符的组合来表示行末尾。使用标准 I/O 包，就不需要考虑这些差异。

从概念上看，C 程序处理的是流而不是直接处理文件。流（stream）是一个实际输入或输出映射的理想化数据流。这意味着不同属性和不同种类的输入，由属性更统一的流来表示。于是，打开文件的过程就是把流与文件相关联，而且读写都通过流来完成。
C 把输入和输出设备视为存储设备上的普通文件，尤其是把键盘和显示设备视为每个C程序自动打开的文件。stdin 流表示键盘输入，stdout 流表示屏幕输出。getchar()、putchar()、printf() 和 scanf() 函数都是标准 I/O 包的成员，处理这两个流。因此可以用处理文件的方式来处理键盘输入。

#### 文件的末尾（EOF）

计算机操作系统要以某种方法判断文件的开始和结束，检测文件结尾的方法有两种：1. 在文件末尾放一个特殊字符来标记文件结尾。曾经操作系统使用的唯一标识是 Ctrl + Z 字符。2. 另一种方法是储存文件大小的信息。

无论操作系统实际上使用的是何种方法检测文件结尾，在 C 语言中，用 getchar() 读取文件检测到文件结尾时将放回一个特殊值，即 EOF (End Of File 的缩写)。scanf()函数检测到文件结尾时也返回EOF。通常， EOF定义 在stdio.h文件中：`#define EOF (-1)`

> EOF 什么是-1？
> 因为getchar()函数的返回值通常都介于0～127，这些值对应标准字符集。但是，如果系统能识别扩展字符集，该函数的返回值可能在 0～255 之间。无论哪种情况，-1都不对应任何字符，所以，该值可用于标记文件结尾。
> 某些系统也许把EOF定义为-1以外的值，但是定义的值一定与输入字符 所产生的返回值不同。

**EOF 是一个值，标志着检测到文件结尾，并不是在文件中找得到的符号。**

如何在程序中使用EOF？把 getchar() 的返回值和 EOF 作比较。如果两值不同，就说明没有到达文件结尾。也就是说，可以使用下面这样的表 达式：`(ch = getchar()) != EOF`

#### 字符串

在前面的介绍中，我们碰到了字符串这一概念，这里简单的介绍一下字符串。字符串（character string）是一个或多个字符的序列，如： "Zing went the strings of my heart!"
注意：双引号不是字符串的一部分。双引号仅告知编译器它括起来的是字符串，正如单引号用于标识单个字符一样。

C 语言没有专门用于储存字符串的变量类型，字符串都被储存在 char 类型的数组中。

> PS：C++ 提供了 string 类型来存储字符串。

**那么，什么是数组？**数组由连续的存储单元组成，可以把数组看作是一行连续的多个存储单元。用更正式的说法是，数组是同类型数据元素的有序序列。通过以下声明创建了一个包含40个存储单元（或元素）的数组，每个单元储存一个 char 类型的值：

```c
char name[40];
```

name 后面的方括号表明这是一个数组，方括号中的 40 表明该数组中的元素数量。char 表明每个元素的类型。

![](E:\Note\Code Language\the-c\picture\basic\2-7.jpg)

了解了什么是数组之后，我们再来看字符串。字符串中的字符被储存在相邻的存储单元中，每个单元储存一个字符。

![](E:\Note\Code Language\the-c\picture\basic\2-8.jpg)

注意上图中数组末尾位置的字符 \0。这是空字符（null character），C 语言用它标记字符串的结束。空字符不是数字 0！它是非打印字符，其 ASCII 码值是（或等价于）0。C 中的字符串一定以空字符结束，这意味着数组的容量必须至少比待存储字符串中的字符数多1。因此，前面定义的 name 中有 40 个存储单元的字符串，只能储存 39 个字符，剩下一个字节留给空字符。



刚开始接触字符串的时候，很容易搞不清楚字符串和字符数组的区别。
字符串是以空字符(\0)结尾的字符数组，这意味字符串是特殊的字符数组，是字符数组的子集。

```c
char name1[5] = {'y', 'o', 'u', 'k', 'a'};
char name2[6] = {'y', 'o', 'u', 'k', 'a', '\0'};
```

如上所示，name1 是字符数组，因为它不是以空字符 \0 结尾，而 name2 是字符串。

![](E:\Note\Code Language\the-c\picture\basic\2-9.png)

**小结：字符串是特殊的字符数组，字符数组不一定是字符串。**

字符串看上去比较复杂！必须先创建一个数组，把字符串中的字符逐个放入数组，还要记得在末尾加上一个\0。还好，计算机可以自己处理这些细节，我们可以使用双引号 "" 来告知编译器这是一个字符串，编译器会自动在其尾部添加上空字符 \0。



使用字符串其实很简单，例如：

```c
#include <stdio.h>
#define PRAISE "You are an extraordinary being." 
int main(void) 
{
    char name[40]; 
    printf("What's your name? "); 
    scanf("%s", name); 
    printf("Hello, %s.%s\n", name, PRAISE); 
    return 0; 
}
```

%s 告诉 printf() 打印一个字符串。%s 出现了两次，因为程序要打印两个字符串：一个储存在 name 数组中；一个由 PRAISE 来表示。

```c
// 上面程序输出结果：
What's your name? Angela Plains 
Hello, Angela.You are an extraordinary being.
```

你不用亲自把空字符放入字符串末尾，scanf() 在读取输入时就已完成这项工作。也不用在字符串常量 PRAISE 末尾添加空字符。编译器会在末尾加上空字符。
**注意：使用 scanf() 读取字符串，在遇到第一个空白(空格、制表符、换行符)时不再读取输入。**所以上面的结果中只读取了 Angela，没有将 Plains 也读取。

# Unit 3. 运算符与语句

## 运算符及其优先级

| **优先级** | **运算符类别**  | **运算符**                                             | **结合性** |
| ---------- | --------------- | ------------------------------------------------------ | ---------- |
| 1          | 括号和 .、->    | ()、[]、.                                              | 从左到右   |
| 2          | 一元运算符      | +、-、++、--、*、&、!、~、sizeof                       | 从右到左   |
| 3          | 算术运算符      | *、/、%                                                | 从左到右   |
| 4          | 算术运算符      | +、-                                                   | 从左到右   |
| 5          | 位移运算符      | <<、>>、>>>                                            | 从左到右   |
| 6          | 比较运算符      | <、<=、>、>=、instanceof                               | 从左到右   |
| 7          | 比较运算符      | !=、==                                                 | 从左到右   |
| 8          | 位运算符(除了~) | &、\|、^                                               | 从左到右   |
| 9          | 逻辑运算符      | &&、\|\|                                               | 从左到右   |
| 10         | 三元运算符      | ?:                                                     | 从右到左   |
| 11         | 赋值运算符      | =、*=、/=、%=、+=、-=、&=、\|=、~=、^=、<<=、>>=、>>>= | 从右到左   |

> 重点：自增和自减运算符的使用。

### 自增自减运算符

#### ++ a 和 a ++

**++ a 是先加一再运算，a ++ 是先运算再加一。**

```c
// 示例1
int a1 = 1;
int a2 = 1;
int b1 = 10 + a1++;
int b2 = 10 + ++a2;
printf("b1=%d\n", b1);// 输出b1=11
printf("b2=%d\n", b2);// 输出b2=12
// 示例2
int n = 0;
n = n++;
printf("n=%d\n",n);// 输出 n=0
```

示例 2 的过程：
1. 首先将 n 的值读取到寄存器中，即将 n=0 保存在寄存器中；
1. 然后在内存中将 n 的值修改为 n + 1，即此时存储变量 n 的内存中保存的是 1；
1. 最后从寄存器中读取寄存器中 n 的值，并进行运算，即将 n = 0 赋值给变量 n。

所以输出的结果是 n=0。

如果是 ++ a，先改变内存中 a 的值，然后读取到寄存器中，最后从寄存器中读取 a 的值，并进行运算。

#### 优势

1. 通常由自增和自减运算符生成的机器语言代码效率更高，因为它是和实际的机器语言指令很相似。尽管如此，随着商家推出的C编译器越来越智能，这一优势可能会消失。
1. 可以使程序更加简洁。比如可以将控制循环的循环条件和循环变量的修改集中在一起。

#### 注意事项

1. 如果变量出现在函数的多个参数中了，最好不要使用自增和自减运算符；
1. 如果变量在某个表达式中出现多次，最好不要使用自增和自减运算符；
1. 如果使用 a 和 a 会得到不同的结果，那么最好不要那样使用。

第1，2条是因为随着编译器的不同，可能会出现不同的结果。比如 `int n = 2;printf("%d %d",n,n*n++);`，在某些系统上是打印 n\*n，然后将 n 递增1，也就是 `2 4`；但在另一些系统中，打印出来的结果就是 n\*(n+1)，也就是`3 6`。
对于第3条，比如`int i = 0; int a = i++;`，在这里使用 i++ 的话，a 是 0，使用 ++i 的话，a 是 1，因此不推荐这么写，推荐写为`int i = 0; i++; int a = i;`

### 算术运算符

加(+)、减(-)、乘(*) 这三个运算符没有什么可说的，跟数学中的运算没什么差别，主要讲一下两个除法运算符。

#### 1. / 运算符

如果操作数都是整数，则结果为舍弃小数位的正数。例如，3 / 2 的结果为 1，而不是 1.5。

如果操作数中有一个数为浮点数，则结果为浮点数。例如，3.0 / 2 的结果为 1.5。

#### 2. % 运算符

1.  % 求模运算符只能用于整数，不能用于浮点数。 
1.  负数求模，趋零截断。如果第一个运算对象是负数，那么求模的结果是负数，反之，结果是整数。
    例如，11 % 5 = 1，11 % -5 = 1，-11 % 5 = -1，-11 % -5 = -1。 
1.  只要 a 和 b 都是整数值，那么就可以通过 a - (a/b)*b 来计算 a%b。 

### 位移运算符

左移一位相当于×2，右移一位相当于÷2。

### 位运算符

& 和 | 是位运算符，但是也可以用来作为逻辑判断，但是与 &&、|| 不同的是，& 和 | 没有短路现象，这也是因为 & 和 | 进行逻辑判断时依旧是在进行位运算。

### 逻辑运算符

#### 1. 短路现象

**短路现象**：当左边的表达式已经能决定整个表达式的真假时，不会去运行右边的表达式的现象被称为短路现象。&& 和 || 都有短路现象。

```c
int a = 1, b = 0;
if (a++ || --b);
printf("a=%d, b=%d\n", a, b);// 输出 a=2, b=0
int c = 0, d = 0;
if (c++ || d--);
printf("c=%d, d=%d\n", c, d);// 输出 c=1, d=-1
```
#### 2. 备选逻辑运算符

C 是在美国用标准美式键盘开发的语言。但是在世界各地，并非所有的 键盘都有和美式键盘一样的符号。因此，C99标准新增了可代替逻辑运算符 的拼写，它们被定义在ios646.h头文件中。如果在程序中包含该头文件，便可用and代替&&、or代替||、not代替!。

![img](E:\Note\Code Language\the-c\picture\basic\3-1.jpg)

### 三元运算符

A ? B:C —— 当 A 成立时，结果为 B；当 A 不成立时，结果为 C。

```c
int a = 3, b = 5;
int c = a > b ? a : b;// 取 a 和 b 中的较大值赋值给 c
```

### 赋值运算符

1. = 和 == 是完全不同的。
1. 赋值表达式的结果是表达式右侧的值。
1. 赋值运算符可以和算术运算符等组合。例如 a -= b 等价于 a = a - b。

### 逗号运算符

逗号运算符最常用的地方是 for 循环中。

**逗号运算符的性质：**
1. **被逗号分隔的表达式从左往右求值。** 即逗号是一个序列点，所以逗号左侧项的副作用(也就是执行)都在程序执行右侧项之前发生。
1. **整个逗号表达式的值是右侧项的值。**

```c
// 例1 —— 性质1
int a, b;
a = 1;
a++, b = a * 2; // b = 4;
// 例2 —— 性质2
int x,y,z;
x = (y=3, (z=++y+2)+5);
printf("%d\n",x);// 输出 11
// 例3 —— 性质2
int a = (250,251); // a 的值是 251.
```

例2和例3了解就行，写还是不要写出这样了，会被打死的。
> PS：`int a, b;` 和 `printf("%d %d\n",a,b);` 中的`,`都是分割符，而不是逗号运算符。

### sizeof 运算符

sizeof 运算符以字节为单位返回运算对象的大小（在C中，1字节定义为char类型占用的空间大小。过去，1 字节通常是 8 位，但是一些字符集可能使用更大的字节）。运算对象可以是具体的数据对象（如，变量名）或类型。如果运算对象是类型（如，float），则必须用圆括号将其括起来。

```c
#include <stdio.h>
int main(void) 
{
    int n = 0; 
    size_t intsize; 
    intsize = sizeof (int); 
    printf("n = %d, n has %zd bytes; all ints have %zd bytes.\n", n, sizeof n, intsize); 
    return 0; 
}
```

C 语言规定，sizeof 返回 size_t 类型的值。这是一个无符号整数类型，但它不是新类型。前面介绍过，size_t是语言定义的标准类型。C 有一个 typedef 机制，允许程序员为现有类型创建别名。C 头文件系统可以使用 typedef 把 size_t 作为 unsigned int 或 unsigned long 的别名。这样，在使用 size_t 类型时，编译器会根据不同的系统替换标准类型。

如果 sizeof 运算符作用于数组，得到的是整个数组占的字节数；如果 sizeof 运算符作用于数组元素，则得到的将是数组元素占的字节数；如果 sizeof 运算符作用于指针，则得到指针占的字节数 —— 32 位系统为 4 字节，64 位系统为 8 字节。

```c
// 64 位系统
int arr[10];
int* p = arr;
printf("sizeof(arr)=%d\n", sizeof(arr));// 输出：sizeof(arr)=40
printf("sizeof(arr[0])=%d\n", sizeof(arr[2]));// 输出：sizeof(arr)=4
printf("sizeof(p)=%d\n", sizeof(p));// 输出：sizeof(p)=8
```

易错点：函数参数中的数组其实是指针。

```c
void f(int arr[]) {
	printf("sizeof(arr)=%d\n", sizeof(arr));
}
int main(void) {
    int arr[10] = {};
    f(arr); // 输出：sizeof(arr)=8
    return 0;
}
```

## 表达式及语句

C 程序都是由语句组成的，语句是 C 程序的基本构建块，而大多数语句又是由表达式构成的。

注意区分：C 程序的基本组成单位是函数，Java 程序的基本组成单位是类。

### 表达式

表达式由运算符和运算对象组成。最简单的表达式是一个单独的运算对象，即没有运算符。例如 4 就是一个最简单的表达式，而 3 + 21，-6 这两个则是由运算符和运算对象组成的表达式。

在简单表达式的基础上可以建立一些复杂的表达式。例如，a*(b + c/d)/20，x = ++q % 3 等。

如你所见，运算对象可以是常量、变量或二者的组合。一些表达式由子表达式组成(子表达式即较小的表达式)。

C 表达式的一个最重要的特性是，每个表达式都有一个值。要获得这个值，必须根据运算符优先级规定的顺序来执行操作。

### 语句

语句是 C 语言的基本构建块，一条语句相当于一条完整的计算机指令。在 C 中，大部分语句都以分号结尾。因此，arr = 4 只是一个表达式，而 arr = 4; 是一条语句。

**复合语句**：由 { } 括起来的多条语句被视为一条复合语句。这种用法在循环和分支中经常使用。

## 条件语句

> 这节会介绍以下关键字：if、else、switch、case、continue、break、default、goto。

大多数人都希望自己是体格强健、天资聪颖、多才多艺的能人。虽然有时事与愿违，但至少我们用 C 能写出这样的程序。诀窍是控制程序流。对于计算机科学（是研究计算机，不是用计算机做研究）而言，一门语言应该提供以下3种形式的程序流：

- 自上而下顺序执行语句序列(顺序结构)； 
- 通过测试，选择执行哪一个语句序列(分支结构/条件语句)；
- 如果满足某些条件就重复执行语句序列(循环结构/循环语句)；

第一种形式，大家应该已经很熟悉了，在前面学习的程序就是这种形式，程序自上而下一次执行每一条语句序列。接下来讲解的条件语句是第二种形式，后面会介绍的循环语句。

**什么是条件语句？**

**条件语句用于在不同的执行方案之间进行选择**，让程序更“智能”，且极大地提高了计算机的用途，让程序根据测试条件执行相应的行为。另外，本章还将复习 C 语言的逻辑运算符，分支结构和循环结构是逻辑运算符的主要应用场景，逻辑运算符能在if 的条件中测试更多关系。学完本章后，读者就可以设计按自己期望方式运行的程序。

### if 语句

![](E:\Note\Code Language\the-c\picture\basic\3-2.png)

例如，下面是输入一个整数，输出其绝对值的程序：

```c
int n;
scanf("%d", &n);
if (n < 0)
    n = -n;
printf("%d\n", n);
```

在上面的程序中，输入 -1，程序进行到 if 语句处进行判断，-1 < 0 结果为 true，执行 { } 内容使得 n = 1，结果为 1。如果输入 1，程序进行到 if 语句处进行判断，1 < 0 结果为 false，不执行 { } 内容 n 的值依旧是 1。



通过前面的例子对 if 语句已经有一些了解了，下面正式介绍下 if 语句的通用形式：

```c
if (expression ) 
	statement;
```

if 语句被称为分支语句（branching statement）、选择语句（selection statement）或条件语句，因为它相当于一个交叉点，程序要在两条分支中选择一条执行。

如果对 expression 求值为真（非0），则执行 statement；否则，跳过 statement。statement 可以是一条简单语句或复合语句。

绝大多数情况下，expression 是关系表达式，即比较两个量的大小（如，表达式 x > y 或 c == 6）。如果 expression 为真（即x大于y，或c == 6），则执行 statement。否则，忽略 statement。概括地说，可以使用任意表达式，表达式的值为 0 则为假。

statement 部分可以是一条简单语句，如本例所示，或者是一条用花括号括起来的复合语句（或块）：

```c
![3-3](E:\Note\Code Language\the-c\picture\basic\3-3.png)if (score > big) 
    printf("Jackpot!\n"); 
// 简单语句 
if (joe > ron) 
{ 
    // 复合语句 
    joecash++; 
    printf("You lose, Ron.\n"); 
}
```

> 注意，即使if语句由复合语句构成，整个if语句仍被视为一条语句。

### if else 语句

简单形式的 if 语句可以让程序选择执行一条语句，或者跳过这条语句。 C 还提供了 if else 形式，可以在两条语句之间作选择。

![](E:\Note\Code Language\the-c\picture\basic\3-3.png)

例如，下面的程序表示变量 x 的值大于 3，则将 x 变为原来的两倍，否则，x 的值 +3。

```c
if(x > 3)
    x = 2 * x;
else
    x = x + 3;
```



if else 通用形式如下：

```c
if ( expression )
	statement1 
else 
    statement2
```

如果 expression 为真(非0)，则执行 statement1；如果 expression 为假(0)，则执行 else 后面的 statement2。statement1 和 statement2 可以是一条简单语句或复合语句。

> C 并不要求一定要缩进，但这是标准风格。缩进让根据测试条件的求值结果来判断执行哪部分语句一目了然。

**注意**！如果要在if和else之间执行多条语句，必须用花括号把这些语句括起来成为一个块。我们来看一下下面的代码：

```c
if (x > 0) 
    printf("Incrementing x:\n"); 
	x++; 
else // 将产生一个错误 
    printf("x <= 0 \n");
```

上面的代码将产生语法错误，因为 if 和 else 之间只能存在一条语句，编译器把 printf() 语句视为 if 语句的一部分，而把 x++; 看作一条单独的语句，它不是 if 语句的一部分。然后，编译器发现 else 并没有所属的 if，这是错误的。上面代码应该修改为：

```c
if (x > 0) 
{
    printf("Incrementing x:\n"); 
	x++;
}
else // 将产生一个错误 
    printf("x <= 0 \n");
```

### 多重选择 —— else if

现实生活中我们经常有多种选择。在程序中也可以用 else if 扩展 if else 结构模拟这种情况：

```c
if (score < 60)       // 00~59 分
    printf("不及格");
else if (score < 80)  // 60~79 分
    printf("及格");
else if (score < 90)  // 80~89 分
    printf("良好");
else                  // 90 分以上
    printf("优秀");
```

实际上，else if 是已学过的 if else 语句的变式。如果改为 if else 的写法，代码如下：

```c
if (score < 60)       // 00~59 分
    printf("不及格");
else 
    if (score < 80)  // 60~79 分
    	printf("及格");
	else 
    	if (score < 90)  // 80~89 分
    		printf("良好");
		else             // 90 分以上
    		printf("优秀");
```

也就是说，该程序由一个 if else 语句组成，else 部分包含另一个 if else 语句，该 if else 语句的 else 部分又包含另一个 if else 语句。第2个 if else 语句嵌套在第1个 if else 语句中，第3个 if else 语句嵌套在第2个 if else 语句中。

回忆一下，整个 if else 语句被视为一条语句，因此不必把嵌套的 if else 语句用花括号括起来。当然，花括号可以更清楚地表明这种特殊格式的含义。

这两种形式完全等价。唯一不同的是使用空格和换行的位置不同，不过编译器会忽略这些。尽管如此，第1种形式还是好些，因为这种形式更清楚地显示了有 4 种选择。在浏览程序时，这种形式让读者更容易看清楚各项选择。

### else 和 if 的配对规则

如果程序中有许多if和else，编译器如何知道哪个if对应哪个else？例如，考虑下面的程序段：

```c
if (number > 6) 
if (number < 12) 
    printf("You're close!\n"); 
else 
    printf("Sorry, you lose a turn!\n");
```

何时打印 Sorry, you lose a turn!？当 number 小于或等于 6 时，还是 number 大于 12 时？换言之，else 与第1个 if 还是第2个 if 匹配？答案是，else 与第2个 if 匹配。也就是说，输入的数字和匹配的响应如下： 

```c
数字 响应 
5    None 
10   You’re close! 
15   Sorry, you lose a turn!
```

else 与 if 的**配对规则**是，如果没有花括号，else 与离它最近的 if 匹配，除非最近的 if 被花括号括起来。

> 快速记忆：else 和 if 的配对遵循就近原则。

![](E:\Note\Code Language\the-c\picture\basic\3-4.png)

![](E:\Note\Code Language\the-c\picture\basic\3-5.png)

注意：要缩进“语句”，“语句”可以是一条简单语句或复合语句，缩进的语句更便于阅读。因此前面例子的缩进应该是这样的：

```c
if (number > 6) 
    if (number < 12) 
        printf("You're close!\n"); 
	else 
    	printf("Sorry, you lose a turn!\n");
```

第1个例子中的缩进使得 else 看上去与第1个 if 相匹配，但是记住，编译器是忽略缩进的。



如果希望 else 与第1个 if 匹配，应该这样写： 

```c
if (number > 6) 
{
    if (number < 12) 
        printf("You're close!\n"); 
}
else 
    printf("Sorry, you lose a turn!\n");
```

### 逻辑运算符与条件语句

读者应该已经已经熟悉了 if 语句，if 语句通常使用关系表达式作为测试条件，而有时候把多个关系表达式组合起来会很有用，这时就需要用到逻辑运算符来组合多个关系表达式。

例如，当 3 <= x <= 7 的时候，输出 Yes，否则输出 No。

```c
if (x >= 3 && x <= 7) 
    printf("Yes");
else
    printf("No");
```

注意，if 的测试条件中的关系表达式不能直接写作 3 <= x <= 7，C 编译器会视为语义错误，需要用逻辑运算符来进行组合。如果不熟悉逻辑运算符或者觉得很别扭，请记住：(练习&&时间) == 完美。

### ?: 条件运算符

C提供条件表达式（conditional expression）作为表达 if else 语句的一种便捷方式，该表达式使用 ?: 条件运算符。该运算符分为两部分，需要 3 个运算对象。回忆一下，带一个运算对象的运算符称为一元运算符，带两个运算对象的运算符称为二元运算符。以此类推，带 3 个运算对象的运算符称为三元运算符。条件运算符是C语言中唯一的三元运算符。下面的代码得到一个数的绝对值：

```c
y = (x>0)?x:-x;
```

在=和;之间的内容就是条件表达式，该语句的意思是“如果 x 大于 0，那么 y = x 否则，y = -x”。

条件表达式的通用形式： `expression1 ? expression2 : expression3 `。

如果 expression1 为真(非 0)，那么整个条件表达式的值与 expression2 的值相同；如果 expression1 为假(0)，那么整个条件表达式的值与 expression3 的值相同。 

需要把两个值中的一个赋给变量时，就可以用条件表达式。典型的例子是，把两个值中的最大值赋给变量：`z = (x>y)?x:y;`

通常，条件运算符完成的任务用 if else 语句也可以完成。但是，使用条件运算符的代码更简洁，而且编译器可以生成更紧凑的程序代码。 

### switch 语句

使用条件运算符和 if else 语句很容易编写二选一的程序。然而，有时程序需要在多个选项中进行选择。可以用 if else if...else 来完成。但是，大多数情况下使用 switch 语句更方便。

请看下面的示例程序：

```c
#include <stdio.h> 
#include <ctype.h> 
int main(void) 
{
    char ch; 
    printf("Give me a letter of the alphabet, and I will give an animal name beginning with that letter.\n"); 
    printf("Please type in a letter; type # to end my act.\n"); 
    while ((ch = getchar()) != '#') 
    {
        if ('\n' == ch) 
            continue; 
        if (islower(ch)) /* 只接受小写字母*/ 
		switch (ch) 
        {
        case 'a': 
        	printf("argali, a wild sheep of Asia\n"); 
            break; 
        case 'b': 
            printf("babirusa, a wild pig of Malay\n"); 
       		break; 
        case 'c': 
            printf("coati, racoonlike mammal\n"); 
            break; 
        case 'd': 
           	printf("desman, aquatic, molelike critter\n"); 
            break; 
        case 'e': 
            printf("echidna, the spiny anteater\n"); 
            break; 
        case 'f': 
          	printf("fisher, brownish marten\n");
            break; 
        default: 
            printf("That's a stumper!\n"); 
        } /* switch结束 */ 
        else 
            printf("I recognize only lowercase letters.\n"); 
        while (getchar() != '\n') continue; /* 跳过输入行的剩余部分 */ 
        printf("Please type another letter or a #.\n"); 
    } /* while循环结束 */ 
    printf("Bye!\n"); 
    return 0; 
}
```

篇幅有限，我们只编到 f，后面的字母以此类推。在进一步解释该程序之前，先看看输出示例：

```c
Give me a letter of the alphabet, and I will give an animal name beginning with that letter. 
Please type in a letter; type # to end my act.
a [enter]
argali, a wild sheep of Asia 
Please type another letter or a #.
# [enter] 
Bye!
```

switch 语句的语法：

```c
switch(整型表达式) 
{
    case 常量1: 
        语句; // 可选
    case 常量2: 
        语句; // 可选 
    ...
    default : // 可选 
        语句; // 可选 
}
```

要对紧跟在关键字 switch 后圆括号中的表达式求值。在示例程序中该表达式是刚输入给 ch 的值。然后程序扫描标签（这里指，case 'a' :、case 'b' :等）列表，直到发现一个匹配的值为止，然后程序跳转至那一行。

**如果没有匹配的标签怎么办？**如果有 default: 标签行，就跳转至该行；否则，程序继续执行在 switch 后面的语句。

**break 语句在其中起什么作用？**它让程序离开 switch 语句，跳至 switch 语句后面的下一条语句。如果没有 break 语句，就会从匹配标签开始执行到 switch 末尾。例如，如果删除该程序中的所有 break 语句，运行程序 

后输入 d，其交互的输出结果如下： 

```c
Give me a letter of the alphabet, and I will give an animal name beginning with that letter. 
Please type in a letter; type # to end my act. 
d [enter] 
desman, aquatic, molelike critter 
echidna, the spiny anteater 
fisher, a brownish marten 
That's a stumper! 
Please type another letter or a #. 
# [enter] 
Bye! 
```

如上所示，执行了从 case 'd': 到 switch 语句末尾的所有语句。

![](E:\Note\Code Language\the-c\picture\basic\3-6.png)

![](E:\Note\Code Language\the-c\picture\basic\3-7.png)

顺带一提，break 语句可用于循环和 switch 语句中，但是 continue 只能用于循环中。尽管如此，如果 switch 语句在一个循环中，continue 便可作为 switch 语句的一部分。这种情况下，就像在其他循环中一样，continue 让程序跳出循环的剩余部分，包括 switch 语句的其他部分。break 和 continue 在循环中的作用区别见下一节循环结构。

**switch 语句的注意事项**：

1. C语言的 case 一般都指定一个值，不能使用一个范围。
2. switch 在圆括号中的测试表达式的值应该是一个整数值（包括 char 类型）。case 标签必须是整数类型(包括  char 类型)的常量或整型常量表达式(即，表达式中只包含整型常量)。不能用变量作为 case 标签。

### switch 和 if else 语句的选择

**何时使用 switch？何时使用 if else？** 

你经常会别无选择，因为如果是根据浮点类型的变量或表达式来选择，就无法使用 switch。

如果根据变量在某范围内决定程序流的去向，使用 switch 就很麻烦，这种情况用 if 就很方便。

但是，如果使用 switch，程序通常运行快一些，生成的代码少一些。

## 循环语句

C语言的条件语句有两种 —— if & switch，还有一个运算符 —— ?:。而C语言的循环语句有3种 —— while、do while、for。

### 什么是循环语句？

现在我们有这样一个需求，想要打印一个如下所示的图形：

```c
#
##
###
####
#####
```

用我们之前学习的方法来实现，代码如下：

```c
printf("#\n");
printf("##\n");
printf("###\n");
printf("####\n");
printf("#####\n");
```

按照以前学习的方法很容易打印出上面要求的图形，但是我们可以看到，其实这个过程没啥技术含量，完全是复制粘贴，然后在 printf 语句中添加一个 '#'，如果现在要我们打印 100 行的图形，难道还要一行一行的添加吗？即使你不嫌麻烦地写了 100 行代码，现在需求编程了打印 10000 行，你还要一行一行的写吗？

循环结构就为我们提供了解决这样重复执行相同步骤的方法。

### while 循环

我们来学习一下 while 循环。在学习之前，再体会一下不使用循环的局限性。

```c
#include <stdio.h> 
#define ADJUST 7.31 // 字符常量 
int main(void) 
{
    const double SCALE = 0.333;// const变量 
    double shoe, foot; 
    shoe = 9.0; 
    foot = SCALE * shoe + ADJUST; 
    printf("Shoe size (men's) foot length\n"); 
    printf("%10.1f %15.2f inches\n", shoe, foot); 
    return 0; 
}
```

上面的代码实现了将鞋码转换成英寸的功能，程序使用了乘法和加法，假定用户穿 9 码的鞋，以英寸为单位打印用户的脚长。你可能会说：“这太简单了，我用笔算比敲程序还要快。”说得没错。写出来的程序只使用一次（本例即只根据一只鞋的尺码计算一次脚长），实在是浪费时间和精力。如果写成交互式程序会更有用，但是仍无法利用计算机的优势。

计算机的优势就在于做一些重复计算的工作，我们使用 while 循环改进后的程序：

```c
#include <stdio.h> 
#define ADJUST 7.31 // 字符常量 
int main(void) 
{
    const double SCALE = 0.333;// const变量 
    double shoe, foot; 
    printf("Shoe size (men's) foot length\n"); 
    shoe = 3.0;
	while (shoe < 18.5) /* while循环开始 */ 
    {   /* 块开始 */ 
        foot = SCALE * shoe + ADJUST; 
        printf("%10.1f %15.2f inches\n", shoe, foot); 
        shoe = shoe + 1.0; 
    } /* 块结束 */ 
    printf("If the shoe fits, wear it.\n"); 
    return 0; 
}
```

下面是shoes2.c程序的输出（...表示并未显示完整，有删节）： 

```c
Shoe size (men's) foot length 
3.0 8.31 inches 
4.0 8.64 inches 
5.0 8.97 inches 
6.0 9.31 inches 
... 
16.0 12.64 inches 
17.0 12.97 inches 
18.0 13.30 inches 
If the shoe fits, wear it. 
```

下面解释一下while循环的原理。当程序第 1 次到达 while 循环时，会检查圆括号中的条件是否为真。该程序中，条件表达式是：`shoe < 18.5`。变量 shoe 被初始化为 3.0，显然小于 18.5。因此，该条件为真，程序进入块中继续执行，把尺码转换成英寸。然后打印计算的结果。下一条语句把 shoe 增加 1.0，使 shoe 的值为 4.0： `shoe = shoe + 1.0; `此时，程序返回 while 入口检查条件。

为何要返回 while 的入口部分？因为上面这条语句的下面是右花括号(})，代码使用一对花括号({})来标出 while 循环的范围。**花括号之间的内容就是要被重复执行的内容。**花括号以及被花括号括起来的部分被称为块(block)。

现在，回到程序中。因为 4 小于 18.5，所以要重复执行被花括号括起来的所有内容(用计算机术语来说就是，程序循环这些语句)。该循环过程一直持续到 shoe 的值为 19.0。此时，由于 19.0 小于 18.5，所以该条件为假：`shoe < 18.5 `出现这种情况后，控制转到紧跟 while 循环后面的第 1 条语句。该例中，是最后的 printf() 语句。

可以很方便地修改该程序用于其他转换。例如，把 SCALE 设置成 1.8、ADJUST 设置成 32.0，该程序便可把摄氏温度转换成华氏温度；把 SCALE 设置成 0.6214、ADJUST 设置成 0，该程序便可把公里转换成英里。注意，修改了设置后，还要更改打印的消息，以免前后表述不一。



**while 语句常用格式**：

```c
while(循环条件表达式)
{
    循环执行的语句;
    循环条件更新;
}
```

写 while 循环的时候最重要的一点就是更新循环条件，否则，循环就不会停止，我们称之为死循环。(PS：事实上，不更新循环条件，也是可以通过 if 语句和 break 来终止循环的，这个在之后会讲，目前我们还只能通过更新循环条件，让循环条件表达式结果为假来终止循环)。



考虑下面的例子：

```c
int i = 1;
while(i <= 5)
{
    printf("%d\n", i);
}
```

上面的程序段将打印无数次 1。为什么？因为循环中 i 的值一直都是原来的值 1，不曾变过。现在，考虑下面的程序段： 

```c
int i = 1;
while(--i <= 5)
{
    printf("%d\n", i);
}
```

这段程序也好不到哪里去。虽然改变了 i 的值，但是改错了！不过，这个版本至少在 i 减少到其类型到可容纳的最小负值并变成最大正值时会终止循环。

### 应用：C 风格的读取循环

```c
int num;
while (scanf("%d", &num) == 1) 
{
    /*循环行为*/ 
}
```

上面的代码同时使用 scanf() 的两种不同的特性。首先，如果函数调用成功，scanf() 会把一个值存入 num。然后，利用 scanf() 的返回值（0或1，不是 num 的值）控制 while 循环。因为每次迭代都会判断循环的条件，所以每次迭代都要调用 scanf() 读取新的 num 值来做判断。换句话说，C 的语法特性让你可以用下面的精简版本替换标准版本： 当获取值和判断值都成功，处理该值。

利用 C 语言中非零值为真的特性，可以进一步精简，将循环条件表达式中的 == 1 省略。

```c
int num;
while (scanf("%d", &num)) 
{
    /*循环行为*/ 
}
```

### while 循环小测验

判断下面的几段代码是否存在问题？

**代码1：**

```c
int i = 0;
while(i = 3)
{
    printf("hello\n");
    i++;
}
```

**答案**：有问题，循环测试条件是一个赋值语句，而不是关系表达式，因此测试条件 `i = 3` 的值一直是 3，因此循环会一直进行，是死循环。应该将 `i = 3` 修改为 `i == 3` 或者 `i < 3`。



**代码2**：

```c
int i = 0;
while(i = 0)
{
    printf("hello\n");
    i++;
}
```

**答案**：不会出现死循环，并且循环语句永远不会被执行。因为循环条件表达式中赋值语句的值是 0，while 判断是假，不执行循环语句。

### 不确定循环和计数循环

一些 while 循环是不确定循环(indefinite loop)。所谓不确定循环，指在测试表达式为假之前，预先不知道要执行多少次循环。例如，C 风格的读取循环。我们事先并不知道用户会结束输入整数。另外，还有一类是计数循环(counting loop)。这类循环在执行循环之前就知道要重复执行多少次。下面的代码就是一个简单的计数循环。

```c
#include <stdio.h> 
int main(void) 
{
    const int NUMBER = 22; 
    int count = 1; // 初始化 
    while (count <= NUMBER) // 测试 
    {
        printf("Be my Valentine!\n"); // 行为 
        count++; // 更新计数 
    }
    return 0; 
}
```

虽然上面的代码运行情况良好，但是定义循环的行为并未组织在一起，程序的编排并不是很理想。我们来仔细分析一下，在创建一个重复执行固定次数的循环中涉及了3个行为： 

1. 必须初始化计数器； 
2. 计数器与有限的值作比较； 
3. 每次循环时递增计数器。 

while 循环的测试条件执行比较，递增运算符执行递增。代码中，递增发生在循环的末尾，这可以防止不小心漏掉递增。因此，这样做比将测试和更新组合放在一起(即使用 count++ <= NUMBER)要好，但是计数器的初始化放在循环外，就有可能忘记初始化。实践告诉我们可能会发生的事情终究会发生，所以我们来学习另一种控制语句 —— for 循环，可以避免这些问题。

### for 循环

for 循环把上述3个行为(初始化、测试和更新)组合在一处，请看下面的 for 循环示例：

```c
#include <stdio.h> 
int main(void) 
{
    const int NUMBER = 22; 
    for (int count = 1; count <= NUMBER; count++) 
        printf("Be my Valentine!\n"); 
    return 0; 
}
```

**for 语句常用格式**：

```c
for(初始化语句;循环条件表达式;表达式更新)
{
    /*循环语句*/
}
```

关键字 for 后面的圆括号中有3个表达式，分别用两个分号隔开。第 1 个表达式是初始化，只会在 for 循环开始时执行一次。第 2 个表达式是测试条件，在执行循环之前对表达式求值。如果表达式为假时，循环结束。第 3 个表达式执行更新，在每次循环结束时求值。

for 圆括号中的表达式也叫做控制表达式，它们都是完整表达式，所以每个表达式的副作用(如，递增变量)都发生在对下一个表达式求值之前。

![](E:\Note\Code Language\the-c\picture\basic\3-8.png)

对于计数循环，for 循环的第一行包括了循环所需的所有信息：初始值，终值，每次循环的增量。

### for 语句的灵活性

for 循环中的三个表达式给予了 for 循环对于计数循环很强的灵活性。

1. 除了计数器递增，还可以使用递减运算符来递减计数器。
    ```
    for (secs = 5; secs > 0; secs--) 
    ```
    
1. 可以让计数器每次递增、递减指定长度的增量，而不只是 1。
    ```
    for (n = 2; n < 60; n = n + 13) 
    ```
    
1. 可以用字符代替数字计数。
    ```
    for (ch = 'a'; ch <= 'z'; ch++) 
    ```
    
1. 除了测试迭代次数之外，还可以测试其他条件。
    ```
    for (num = 1; num*num*num <= 216; num++) 
    ```
    
1. 可以让递增的量几何增长，而不是算术增长。
    ```
    for (debt = 100.0; debt < 150.0; debt = debt * 1.1) 
    ```
    
1. 第3个表达式可以使用任意合法的表达式。无论是什么表达式，每次迭代都会更新该表达式的值。 
    ```
    for (x = 1; y <= 75; y = (++x * 5) + 50) 
    ```
    
1. 可以省略一个或多个表达式(但是不能省略分号)，只要在循环中包含能结束循环的语句即可。
    ```
    for (n = 3; ans <= 25;) // 更新表达式放在了{}中
    ```
    
1. 循环体中的行为可以改变循环头中的表达式。

### do while 循环

while 循环和 for 循环都是入口循环，即在循环的每次迭代之前检查测试条件，所以有可能根本不执行循环体中的内容。而 do while 循环是出口循环，即在循环的每次迭代之后检查测试条件，这保证了至少执行循环体中的内容一次。

```c
#include <stdio.h> 
int main(void) 
{
    const int secret_code = 13; 
    int code_entered; 
    do
    {
        printf("To enter the triskaidekaphobia therapy club,\n"); 
        printf("please enter the secret code number: "); 
        scanf("%d", &code_entered); 
    } while (code_entered != secret_code); 
    printf("Congratulations! You are cured!\n"); 
    return 0; 
}
```

下面是do while循环的通用形式： 

```c
do
    statement 
while ( expression );
```

![](E:\Note\Code Language\the-c\picture\basic\3-9.png)

### 如何选择循环

如何选择循环？

**首先，****确定是需要入口条件循环还是出口条件循环**。通常，入口条件循环用得比较多。有几个原因，其一，一般原则是在执行循环之前测试条件比较好。其二，测试放在循环的开头，程序的可读性更高。其三，在许多应用中，要求在一开始不满足测试条件时就直接跳过整个循环。因此，我们通常是 while 循环和 for 循环中选择一个。

**那么，到底是选择 while 循环还是 for 循环**？这取决于个人喜好，因为二者皆可，要让 for 循环看起来像 while 循环，直接将第一个表达式和第三个表达式省略即可。要让 while 循环像 for 循环，直接在 while 前面初始化变量，在 while 循环体中包含更新语句。

一般而言，当循环涉及初始化和更新变量时(例如计数循环)，用 for 循环比较合适，而在其他情况下用 while 循环更好。

### 循环的嵌套

还记得我们刚开始的打印图形的例子吗？

```c
#
##
###
####
#####
```

我们用之前学习的循环结构可以打印指定数目的 '#' 字符了。

```c
for(int i = 0; i < n; i++)
    printf("#");
```

其中 n 是指定打印几个 '#' 字符。

如果想要打印上面指定的图形，就需要用到嵌套循环了。

```c
int i = 0, j = 0;
int n = 5;
while(i < n)
{
    j = 0;
    while(j <= i)
    {
    	printf("#");
        j++;
    }
    printf("\n");
    i++;
}
```

如果我们想要打印 100 行图形，只需要将 n 修改为 100 即可。

## 跳转

一般而言，程序进入循环后，在下一次循环测试之前会执行完循环体中的所有语句。continue 和 break 语句可以根据循环体中的测试结果来忽略一部分循环内容，甚至结束循环。

### continue

continue 只用在循环语句中，常搭配 if 语句使用。执行到该语句时，会跳过本次迭代的剩余部分，并开始下一轮迭代。如果 continue 语句在嵌套循环内，则只会影响包含该语句的内层循环。

```c
#include <stdio.h>
int main()
{
    char c = 0;
    while(c!='\n')
    {  //回车键结束循环
        c=getchar();
        if(c=='4' || c=='5')  //按下的是数字键4或5
            continue;  //跳过当次循环，进入下次循环
        putchar(c);
    }
    return 0;
}
```

本例我们输入的是 0123456789，当读取到 4 或 5 时，if 的条件 c=='4'||c=='5' 成立，就执行 continue 语句，结束当前循环，直接进入下一次循环，也就是说 putchar(c); 不会被执行到。而读取到其他数字时，if 的条件不成立，continue 语句不会被执行到，putchar(c); 就会输出读取到的字符。

这种情况下，使用 continue 的好处是减少主语句组中的一级缩进。当语句很长或嵌套较多时，紧凑简洁的格式提高了代码的可读性。例如我们下面演示了不使用 continue 的情况，需要将剩下的语句放在 else 中。

```c
#include <stdio.h>
int main()
{
    char c = 0;
    while(c!='\n')  //回车键结束循环
    {
        c=getchar();
        if(c=='4' || c=='5')  //按下的是数字键4或5
            continue;  //跳过当次循环，进入下次循环
        else 
        {
        	putchar(c);
        }
    }
    return 0;
}
```

continue 还可用作占位符。例如，下面的循环读取并丢弃输入的数据，直至读到行末尾： 

```c
while (getchar() != '\n');
```

当程序已经读取一行中的某些内容，要跳至下一行开始处时，这种用法很方便。问题是，一般很难注意到一个单独的分号。如果使用 continue，可读性会更高： 

```c
while (getchar() != '\n') 
	continue; 
```

### break

break 可以用在循环和 switch 中，在循环中常和 if 搭配使用。程序执行到循环中的 break 语句时，会终止包含它的循环，并继续执行下一阶段。如果 break 语句位于嵌套循环内，它只会影响包含它的当前循环。

在 for 循环中的 break 和 continue 的情况不同，执行完 break 语句后会直接执行循环后面的第 1 条语句，连更新部分也跳过。而 continue 会执行 for 循环的更新部分。

### goto

早期版本的 BASIC 和 FORTRAN 所依赖的 goto 语句，在 C 中仍然可用。但是 C 和其他两种语言不同，没有 goto 语句 C 程序也能运行良好。Kernighan 和 Ritchie 提到 goto 语句“易被滥用”，并建议“谨慎使用，或者根本不用”。

介绍一下如何使用 goto 语句。。goto 语句有两部分：goto 和标签名。标签的命名遵循变量命名规则，如下所示：`goto part2; `要让这条语句正常工作，函数还必须包含另一条标为 part2 的语句，该语句以标签名后紧跟一个冒号开始： 

```c
part2: printf("Refined analysis:\n"); 
```

原则上，根本不用在C程序中使用 goto 语句。

因为 goto 的出现是因为 BASIC 和 FORTRAN 的 if else 语句后面只能跟一条语句，因此需要用 goto 来实现复合语句，而 C 本身就支持用 {} 括起来的复合语句，因此不需要用到 goto 语句。

讽刺地是，虽然 C 根本不需要 goto，但是它的 goto 比其他语言的 goto 好用，因为 C 允许在标签中使用描述性的单词而不是数字。

# Unit 4. 函数探幽

## 初识函数

### 什么是函数？

**函数是完成特定任务的独立程序代码单元，也是 C 程序的基本组成单位**。语法规则定义了函数的结构和使用方式 —— 函数定义和函数调用。虽然 C 中的函数和其他语言中的函数、子程序、过程作用相同，但是细节上略有不同。

一些函数执行某些动作，如 printf() 把数据打印到屏幕上；一些函数找出一个值供程序使用，如 strlen() 把指定字符串的长度返回给程序。一般而言，函数可以同时具备以上两种功能。

### 为什么用函数？

首先，使用函数可以省去编写重复代码的苦差。如果程序要多次完成某项任务，那么只需编写一个合适的函数，就可以在需要时使用这个函数，或者在不同的程序中使用该函数，就像许多程序中使用 putchar() 一样。其次，即使程序只完成某项任务一次，也值得使用函数。因为函数让程序更加模块化，从而提高了程序代码的可读性，更方便后期修改、完善。

例如，假设要编写一个程序完成以下任务：读入一系列数字、分类这些数字、找出这些数字的平均值、打印一份柱状图。可以使用下面的程序：

```c
#include <stdio.h> 
#define SIZE 50 
int main(void) 
{
	float list[SIZE]; 
    readlist(list, SIZE); 
    sort(list, SIZE); 
    average(list, SIZE); 
    bargraph(list, SIZE); 
    return 0; 
}
```

当然，还要编写 4 个函数 readlist()、sort()、average() 和 bargraph() 的实现细节。描述性的函数名能清楚地表达函数的用途和组织结构。然后，单独设计和测试每个函数，直到函数都能正常完成任务。如果这些函数够通用，还可以用于其他程序。

许多程序员喜欢把函数看作是根据传入信息(输入)及其生成的值或响应的动作(输出)来定义的“黑盒”。如果不是自己编写函数，根本不用关心黑盒的内部行为。例如，使用 printf() 时，只需知道给该函数传入格式字符串或一些参数以及 printf() 生成的输出，无需了解 printf() 的内部代码。以这种方式看待函数有助于把注意力集中在程序的整体设计，而不是函数的实现细节上。因此，在动手编写代码之前，仔细考虑一下函数应该完成什么任务，以及函数和程序整体的关系。

### 如何学习函数？

函数这部分主要的知识点有三部分 —— 如何定义函数、调用函数以及函数间的通信，除此之外，还需要了解参数传递、递归、变参函数几个小知识点。先演示一个简单的例子：

```c
#include <stdio.h> 
#define NAME "GIGATHINK, INC." 
#define ADDRESS "101 Megabuck Plaza" 
#define PLACE "Megapolis, CA 94904" 
#define WIDTH 40 
void starbar(void); /* 函数原型 */ 
int main(void) 
{
    starbar(); 
    printf("%s\n", NAME); 
    printf("%s\n", ADDRESS); 
    printf("%s\n", PLACE); 
    starbar(); /* 使用函数 */ 
    return 0; 
}
void starbar(void) /* 定义函数 */ 
{
    int count; 
    for (count = 1; count <= WIDTH; count++) 
        putchar('*'); 
    putchar('\n'); 
}
```

该程序的输出如下：

```plain
****************************************
GIGATHINK, INC. 
101 Megabuck Plaza 
Megapolis, CA 94904 
****************************************
```

该程序要注意以下几点。程序在 3 处使用了 starbar 标识符：1. 函数原型告诉编译器函数 starbar() 的类型；2. 函数调用表明在此处执行函数；3. 函数定义明确地指定了函数要做什么。

## 定义函数

函数和变量类似，例如，变量需要先定义之后才能使用 —— 函数也需要先定义之后才能使用；变量有不同的类型 —— 函数也有类型；通过变量名来使用变量 —— 函数调用需要使用函数名。

定义一个函数有两种方式，一种是直接使用函数定义；另一种是先使用函数声明告诉编译器函数要如何使用，再使用函数定义规定函数的执行细节。

### 函数定义

**函数定义**：指对函数功能的确立，包括指定函数名，函数值类型、形参类型、函数体等，它是一个完整的、独立的函数单位。

函数定义的格式：

```c
返回值类型 函数名(参数列表)
{
    // 函数体
    return 返回值;
}
```

示例：

```c
#include <stdio.h>
// 函数定义
int add(int a, int b) {
    int c = a + b;
    return c;
}
int main() {
    // 调用函数
}
```

### 函数声明

C 语言代码由上到下依次执行，原则上函数定义要出现在函数调用之前，否则就会报错。但在实际开发中，经常会在函数定义之前使用它们，这个时候就需要提前声明。

**函数声明**：把函数的名字、函数类型以及形参类型、个数和顺序通知编译系统，以便在调用该函数时系统按此进行对照检查。

所谓**函数声明**，就是告诉编译器我要使用这个函数，你现在没有找到它的定义不要紧，请不要报错，稍后我会把定义补上。

> PS：对于一些老旧的编译器来说，函数声明是不带参数列表的。

函数声明给出了函数名、返回值类型、参数列表（重点是参数类型）等与该函数有关的信息，也称为**函数原型**。简单来说，就是将函数定义的函数体替换为分号。

```c
// 函数声明，也称为函数原型
返回值类型 函数名(参数列表);
// 示例：
int add(int a, int b);
```

**函数原型相当于函数声明**。需要注意的是，虽然现在一般都会说函数原型就是函数声明，但其实对于一些老旧的编译器，它们是不同的，对于这些老旧的编译器，函数声明是不带参数列表的，如`int imax();`，但是这样编译器无法针对参数不匹配的问题，因此提出了函数原型来解决这个问题，因此在后来的编译器中函数声明的标准中加上了参数列表。

函数原型的作用是告诉编译器该函数有关的信息，让编译器知道函数的存在，以及存在的形式，即使函数暂时没有定义，编译器也知道如何使用它。这样在有函数声明的情况下，函数定义就可以出现在任何地方了，甚至是其他文件、静态链接库、动态链接库等。

> 注意：函数声明并不可以代替函数定义，函数声明的意义在于可以使得函数定义出现在函数调用之后或者出现在其他文件中。



**Q：已经有了函数定义，为什么还需要函数声明？**

**A：**如果没有函数声明，函数定义必须在函数调用之前，否则会报错。例如，下面的例子就会报错，错误提示是 add 函数没有定义：

```c
#include <stdio.h>
int main() {
    // 调用函数
    int c = add(3, 4);// 报错
}
// 函数定义
int add(int a, int b) {
    int c = a + b;
    return c;
}
```

这时在函数调用之前加上函数声明，就不会报错了。

```c
#include <stdio.h>
int add(int a, int b);
int main() {
    // 调用函数
    int c = add(3, 4);// 正确
}
// 函数定义
int add(int a, int b) {
    int c = a + b;
    return c;
}
```

函数声明的参数列表中的参数名可以和函数定义的参数列表中的参数名不同。

> PS：C 语言函数声明中的参数列表可以省略，C函数声明的参数列表不可省略，因为 C 会存在函数重载的问题，需要参数列表作为特征标。

### 函数的类型

函数和变量一样，有多种类型。任何程序在使用函数之前都要声明该函数的类型。

**函数类型：**函数类型取决于函数的返回值以及参数的类型。返回值类型和参数类型相同的函数是同一种类型的函数。例如上面的程序中，函数原型部分 `void starbar(void);` 其中第一个 void 是函数类型，void 类型表明 starbar() 函数无返回值类型。

> PS：如果不声明返回值类型，C 语言默认是返回 int 类型。



上面关于函数类型的定义是来自书上的，我其实不太认同。我认为返回值类型以及参数列表两者共同表示了函数的类型。根据指针来证明：

```c
#include <stdio.h>
int f1(int a, int b);
int main(void) {
	int (*ptr)(int a) = f1; // 会报错
}
int f1(int a, int b) {
    return a+b;
}
```

如果函数返回值类型就是函数类型的话，函数指针就没有必要要求指针的参数列表也要和指向的函数的参数列表一致了。

我对这里说的函数类型是返回值类型的理解是：C语言不支持函数重载，而且C语言可以在函数声明中不写参数列表，只在函数定义中提供参数列表。

## 递归

### 什么递归？

**C 语言允许函数调用自己，这种调用过程称为递归(recursion)。**

我们来看一个简单的递归示例 —— 计算阶乘的函数，并计算 0~9 的阶乘值。

```c
#include<stdio.h>
int factorial(int);
int main()
{
    int n = 10;
    for (int i = 0; i < n; i++)
        printf("(%d!) = %d\n", i, factorial(i));
    
    getchar();
    return 0;
}
int factorial(int a)
{
    if (a < 2)
        return 1;
    return factorial(a - 1) * a;
}
```

<img src="E:\Note\Code Language\the-c\picture\basic\4-1.png" align="left" />

递归有时难以捉摸，有时却很方便实用。**结束递归是使用递归的难点**，因为如果递归代码中没有终止递归的条件测试部分，一个调用自己的函数会无限递归。

可以使用循环的地方通常都可以使用递归。有时用循环解决问题比较好，但有时用递归更好。**递归方案更简洁，但效率却没有循环高**。

### 递归的基本原理

初次接触递归会觉得比较难以理解，为了帮助大家理解递归过程，讲解几个递归的要点。

1. **每级函数调用都有自己的变量。**
2. **每次函数调用都会返回一次。当函数执行完毕后，控制权将被传回上一级递归。程序必须按顺序逐级返回递归。**
3. **递归函数中位于递归调用之前的语句，均按被调函数的顺序执行。**
4. **递归函数中位于递归调用之后的语句，均按被调函数相反的顺序执行。**
5. **虽然每级递归都有自己的变量，但是并没有拷贝函数的代码。程序按顺序执行函数中的代码，而递归调用就相当于又从头开始执行函数的代码。除了为每次递归调用创建变量外，递归调用非常类似于一个循环语句。实际上，递归有时可用循环来代替，循环有时也能用递归来代替。** 
6. **递归函数必须包含能让递归调用停止的语句。通常，递归函数都使用if或其他等价的测试条件在函数形参等于某特定值时终止递归。为此，每次递归调用的形参都要使用不同的值。**

为了方便演示上面的几个要点，在阶乘函数中加入了一些输出信息。

```c
#include<stdio.h>
int factorial(int);
int main()
{
    printf("main: (4!) = %d\n", factorial(4));
    return 0;
}
int factorial(int a)
{
    printf("start: a = %d, &a = %p\n", a, &a);
    if (a < 2) {
        printf("end: a = %d, &a = %p\n", a, &a);
        return 1;
    }
    int result = factorial(a - 1) * a;
    printf("end: a = %d, &a = %p\n", a, &a);
    return result;
}
```

<img src="E:\Note\Code Language\the-c\picture\basic\4-2.png" align="left" />

可以看到计算 4 的阶乘的时候有四级调用，第一级调用是 factorial(4)，第二级调用是 factorial(3) ...。每一级调用中的形式参数 a 都是不同的，这一点可以通过它们的地址来看出来。递归调用之前的输出信息语句是按照递归调用的顺序输出的(4 3 2 1)，而递归调用之后的输出信息语句是逆序的(1 2 3 4)。

### 尾递归

最简单的递归形式是把递归调用置于函数的末尾，即正好在 return 语句之前。这种形式的递归被称为尾递归(tail recursion)，因为递归调用在函数的末尾。**尾递归是最简单的递归形式，因为它相当于循环**。我们前面的计算阶乘的函数就是尾递归。



**既然用递归和循环来计算阶乘都没问题，那么到底应该使用哪一个？**

一般而言，选择循环比较好。首先，每次递归都会创建一组变量，所以**递归使用的内存**更多，而且每次递归调用都会把创建的一组新变量放在栈中。**递归调用的数量受限于内存空间**。其次，由于每次**函数调用要花费一定的时间，所以递归的执行速度较慢**。



**既然递归执行速度较慢，为什么还要学习递归？**

尾递归是递归中最简单的形式，比较容易理解。**在某些情况下，不能用简单的循环代替递归**，因此读者还是要好好理解递归。

### 倒序计算

递归在处理倒序时非常方便（在解决这类问题中，递归比循环简单）。

例如，编写一个函数，输入一个整数，打印这个整数的二进制数。

```c
#include<stdio.h>
void binary(int);
int main()
{
    int a;
    scanf("%d", &a);
    binary(a);
    return 0;
}
void binary(int a)
{
    if(a/2)
        binary(a/2);
    printf("%d", a%2);
}
```

<img src="E:\Note\Code Language\the-c\picture\basic\4-3.png" align="left" />

**不用递归，是否能实现这种用二进制形式表示整数的算法？**

当然可以。 但是由于这种算法要首先计算最后一位二进制数，所以在显示结果之前必须把所有的位数都储存在别处（例如，数组）。

### 递归的优缺点

递归既有优点也有缺点。

**优点**：递归为某些编程问题提供了最简单的解决方案。

**缺点**：一些递归算法会快速消耗计算机的内存资源。另外，递归不方便阅读和维护。



我们再来举一个典型的例子，斐波那契数列。斐波那契数列的定义如下：第1 个数字和第 2 个数字都是 1，而后续的每个数字都是其前两个数字之和。例如，该数列的前几个数是：1、1、2、3、5、8、13。用数学上的数列来描述的话就是：

![img](E:\Note\Code Language\the-c\picture\basic\4-4.svg)

首先，我们来看看递归的实现。递归提供一个简单的定义。如果把函数命名为 Fibonacci()，那么如果 n 是 1 或 2， Fibonacci(n) 应返回 1，对于其他数值，则应返回 Fibonacci(n-1) + Fibonacci(n-2)。代码如下：

```c
unsigned long Fibonacci(unsigned n) 
{
    if (n < 3) 
   		return 1; 
    return Fibonacci(n-1) + Fibonacci(n-2);
}
```

这个递归函数只是重述了数学定义的递归。该函数使用了双递归(double recursion)，即函数每一级递归都要调用本身两次，这就造成了一个问题。

为了说明这个问题，假设调用 Fibonacci(40)。这是第 1 级递归调用，将创建一个变量 n。然后在该函数中要调用 Fibonacci() 两次，在第 2 级递归中要分别创建两个变量 n。这两次调用中的每次调用又会进行两次调用，因而在第 3 级递归中要创建 4 个名为 n 的变量。此时总共创建了 7 个变量。由于每级递归创建的变量都是上一级递归的两倍，所以**变量的数量呈指数增长！**按指数增长很快就会产生非常大的值。在本例中，指数增长的变量数量很快就消耗掉计算机的大量内存，很可能导致程序崩溃。 

虽然这是个极端的例子，但是该例说明：**在程序中使用递归要特别注意，尤其是效率优先的程序**。



所有的 **C** 函数皆平等。程序中的每个 C 函数与其他函数都是平等的。每个函数都可以调用其他函数，或被其他函数调用。这点与 Pascal 和 Modula-2 中的过程不同，虽然过程可以嵌套在另一个过程中，但是嵌套在不同过程中的过程之间不能相互调用。 

main() 函数是否与其他函数不同？是的，main() 的确有点特殊。当 main() 与程序中的其他函数放在一起时，最开始执行的是 main() 函数中的第 1 条语句，但是这也是局限之处。main() 也可以被自己或其他函数递归调用 —— 尽管很少这样做。

## 变参函数

stdarg.h 头文件为函数提供了变参函数的功能，但是用法比较复杂。必须按如下步骤进行：

1. 1. 提供一个使用省略号的函数原型； 
   2. 在函数定义中创建一个 va_list 类型的变量； 
   3. 用宏把该变量初始化为一个参数列表； 
   4. 用宏访问参数列表； 
   5. 用宏完成清理工作。 

变参函数的实现其实离不开变参宏，接下来详细分析这些步骤。这种函数的原型应该有一个形参列表，其中**至少有一个形参和一个省略号**：

```c
void f1(int n, ...); // 有效 
int f2(const char * s, int k, ...); // 有效 
char f3(char c1, ..., char c2);// 无效，省略号不在最后 
double f3(...); // 无效，没有形参 
```

最右边的形参（即省略号的前一个形参）起着特殊的作用，标准中用 parmN 这个术语来描述该形参。在上面的例子中，第1行f1()中 parmN 为 n，第2行 f2() 中 parmN 为 k。传递给该形参的实际参数是省略号部分代表的参数数量。例如，可以这样使用前面声明的 f1() 函数： 

```c
f1(2, 200, 400); // 2个额外的参数 
f1(4, 13, 117, 18, 23); // 4个额外的参数
```

接下来，声明在 stdarg.h 中的 va_list 类型代表一种用于储存形参对应的形参列表中省略号部分的数据对象。变参函数的定义起始部分类似下面这样：

```c
double sum(int lim,...) 
{
	va_list ap; //声明一个储存参数的对象 
```

在该例中，lim 是 parmN 形参，它表明变参列表中参数的数量。然后，该函数将使用定义在 stdarg.h 中的 va_start() 宏，把参数列表拷贝到 va_list 类型的变量中。该宏有两个参数：va_list 类型的变量和 parmN 形参。

接着上面的例子讨论，va_list 类型的变量是 ap，parmN 形参是 lim。所以，应这样调用它： 

```c
va_start(ap, lim); // 把ap初始化为参数列表 
```

下一步是访问参数列表的内容，这涉及使用另一个宏 va_arg()。该宏接受两个参数：一个 va_list 类型的变量和一个类型名。第1次调用 va_arg() 时，它返回参数列表的第1项；第2次调用时返回第2项，以此类推。表示类型的参数指定了返回值的类型。例如，如果参数列表中的第1个参数是 double 类型，第2个参数是 int 类型，可以这样做： 

```c
double tic; 
int toc; 
... 
tic = va_arg(ap, double); // 检索第1个参数 
toc = va_arg(ap, int); //检索第2个参数 
```

注意，**传入的参数类型必须与宏参数的类型相匹配**。如果第1个参数是10.0，上面 tic 那行代码可以正常工作。但是如果参数是10，这行代码可能会出错。这里不会像赋值那样把 double 类型自动转换成 int 类型。 

最后，要使用 va_end() 宏完成清理工作。例如，释放动态分配用于储存参数的内存。该宏接受一个 va_list 类型的变量： `va_end(ap); // 清理工作`

调用 va_end(ap) 后，只有用 va_start 重新初始化 ap 后，才能使用变量 ap。因为 va_arg() 不提供退回之前参数的方法，所以有必要保存 va_list 类型变量的副本。C99 新增了一个宏用于处理这种情况：va_copy()。该宏接受两个 va_list 类型的变量作为参数，它把第2个参数拷贝给第1个参数：

```c
va_list ap; 
va_list apcopy; 
double 
double tic; 
int toc; 
... 
va_start(ap, lim); // 把ap初始化为一个参数列表 
va_copy(apcopy, ap); // 把apcopy作为ap的副本 
tic = va_arg(ap, double); // 检索第1个参数 
toc = va_arg(ap, int); // 检索第2个参数 
```

此时，即使删除了 ap，也可以从 apcopy 中检索两个参数。 

```c
//varargs.c -- use variable number of arguments 
#include <stdio.h> 
#include <stdarg.h> 
double sum(int, ...); 
int main(void) 
{
    double s, t; 
    s = sum(3, 1.1, 2.5, 13.3); 
    t = sum(6, 1.1, 2.1, 13.1, 4.1, 5.1, 6.1); 
    printf("return value for sum(3, 1.1, 2.5, 13.3): %g\n", s); 
    printf("return value for sum(6, 1.1, 2.1, 13.1, 4.1, 5.1, 6.1): %g\n", t); 
    return 0; 
}
double sum(int lim, ...) 
{
    va_list ap; // 声明一个对象储存参数 
    double tot = 0; 
    int i; 
    va_start(ap, lim); // 把ap初始化为参数列表 
    for (i = 0; i < lim; i++) 
    tot += va_arg(ap, double); // 访问参数列表中的每一项 
    va_end(ap); // 清理工作 
    return tot; 
}   
```

下面是该程序的输出： 

```c
return value for sum(3, 1.1, 2.5, 13.3): 16.9 
return value for sum(6, 1.1, 2.1, 13.1, 4.1, 5.1, 6.1): 31.6 
```

查看程序中的运算可以发现，第1次调用 sum() 时对3个数求和，第2次调用时对6个数求和。总而言之，使用变参函数比使用变参宏更复杂，但是函数的应用范围更广。

# Unit 5. 复合数据类型

## 数组

### 数组简介

在 Unit 2 中简单介绍过字符数组和字符串的概念，事实上，在 C 语言中不只能创建 char 类型数组，还可以创建其他类型的数组。

**数组由数据类型相同的一系列元素组成。**需要使用数组时，通过声明数组告诉编译器数组中内含多少元素和这些元素的类型，编译器根据这些信息正确地创建数组。普通变量可以使用的类型，数组元素都可以用。

数组在内存中是连续的存储单元，可以把数组看作是一行连续的多个存储单元。



我们在学习普通变量的时候学习了普通变量的定义、初始化、使用，而数组的知识同样需要学习如何定义一个数组，如何初始化一个数组，以及数组的使用。

### 数组的定义

在使用一个变量之前需要先定义该变量，同样的，在使用数组之前需要先定义数组。编译器会根据定义的数组在内存中找到一块连续的存储单元来存储数组的数据。

数组定义的格式：

```c
type arrayName [arraySize];
```

这叫做一维数组，事实上我们平常说的数组都是指一维数组，需要注意的是：

1. type 可以是任意有效的 C 数据类型。
2. arrayName 被称为数组名，其命名规则满足 C 语言的命名标准，它代表着数组的起始地址。
3. arraySize 必须是一个大于零的整数常量。在 C99 标准之前，arraySize 不允许是变量，C99 标准之后引入了变长数组的概念。

定义数组的演示：

```c
float candy[365]; /* 内含365个float类型元素的数组 */ 
char code[12];    /* 内含12个char类型元素的数组*/ 
int states[50];   /* 内含50个int类型元素的数组*/
```

要访问数组中的元素，通过使用数组下标数(也称为索引)表示数组中的各元素。数组元素的编号从 0 开始，所以 candy[0] 表示 candy 数组的第 1 个元素，candy[364] 表示第 365 个元素，也就是最后一个元素。

### 数组的初始化

#### 数组的通用初始化

数组通常被用来储存程序需要的数据。例如，一个内含 12 个整数元素的数组可以储存 12 个月的天数。在这种情况下，在程序一开始就初始化数组比较好。下面介绍初始化数组的方法。 

在学习数组之前，我们接触到的变量都是**只能存储单个值的，称为标量变量**。我们已经很熟悉如何初始化这类变量：

```c
int a = 10;
double b = 1.9;
```



下面来了解下数组的初始化，和标量变量的初始化一样，**数组初始化指在数组定义时给数组元素赋予初值**。C 语言使用新的语法来初始化数组。

```c
type arrayName [arraySize] = {value1, value2, ..., valueN};
```

例如：

```c
int powers[8] = {1, 2, 4, 6, 8, 16, 32, 64};
```

如上所示，用以逗号分隔的值列表(用花括号括起来)来初始化数组，各值之间用逗号分隔。在逗号和值之间可以使用空格。根据上面的初始化，把 1 赋给数组的首元素(powers[0])，以此类推。



数组初始化的限制：

1. **只有在定义数组时才可以初始化，此后就不能再用了**。
2. **不能直接将一个数组赋值给另一个数组**。



初始化注意事项：

1. **使用数组之前必须先初始化数组或者为每个元素赋值，否则编译器使用的值是内存相应位置上的现有值**。(PS：事实上，这一条只针对自动存储类别的数组，对于静态存储期的数组，即使没有初始化，编译器会默认将所有元素初始化为 0。这一部分是存储类别的知识，目前不需要记住。)
2. **初始化列表的项数和数组的大小不一致。**
   a. **初始化列表的项数大于数组的大小，编译器报错。**
   b. **初始化列表的项数小于数组的大小，编译器将剩余的元素初始化为 0。**也就是说，如果不初始化数组，数组元素和未初始化的普通变量一样，其中储存的都是垃圾值；但是，如果部分初始化数组，剩余的元素就会被初始化为0。
3. 根据第2点，**可以省略方括号中的数字，让编译器自动匹配数组大小和初始化列表中的项数**。但必须保证初始化列表中的项数是正确的，否则即使少了一项或者多了一项，编译器都不会察觉。

    ```c
    int a [10]= {}; // 将 a 数组的十个元素都初始化为 0.
    ```
4. **如果初始化数组时省略方括号中的数字，编译器会根据初始化列表中的项数来确定数组的大小**。
   
    ```c
    int a[] = { 1, 2, 3, 4, 5, 6};// 编译器初始化一个含有6个元素的数组
    ```
    
1. 使用 **const** 声明数组。有时需要把数组设置为只读，这样程序只能从数组中检索值，不能把新值写入数组。要创建只读数组，应该用 const 声明和初始化数组。例如：

    ```c
    const int days[MONTHS] = {31,28,31,30,31,30,31,31,30,31,30,31}; 
    ```

这样程序在运行过程中就不能修改该数组中的内容。和普通变量一样，应该使用声明来初始化 const 数据，因为一旦声明为 const，便不能再给它赋值。

#### 字符串初始化(字符串特有)

还有一种初始化数组的方法，这种方法仅限于初始化字符数组，更确切地说是仅限于字符串初始化 —— 使用字符串常量初始化。

```c
char str1[10] = "hello";  // 数组长度是 10
char str2[10] = {"world"};// 数组长度是 10
char str3[] = "hello";    // 数组长度是 6
char str4[] = {"world"};  // 数组长度是 6
```

#### 指定初始化器(C99新特性)

C99 增加了一个新特性：指定初始化器（designated initializer）。利用该特性可以初始化指定的数组元素。例如，只初始化数组中的最后一个元素。

对于传统的 C 初始化语法，必须初始化最后一个元素之前的所有元素，才能初始化它： 

```c
int arr[6] = {0,0,0,0,0,212}; // 传统的语法
```

而C99规定，**可以在初始化列表中使用带方括号的下标指明待初始化的元素**：

```c
int arr[6] = {[5] = 212}; // 把arr[5]初始化为212 
```

下面我们来**演示一下指定初始化器的用法**：

```c
int days[12] = { 31, 28, [4] = 31, 30, 31, [1] = 29 };
// days 数组：days[] = { 31, 29, 0, 0, 31, 30, 31, 0, 0, 0, 0, 0};
```

这里演示了指定初始化器的两个重要特性。

1. 如果指定初始化器后面有更多的值，如该例中的初始化列表中的片段：`[4] = 31,30,31`，那么后面这些值将被用于初始化指定元素后面的元素，即，在 days[4] 被初始化为 31 后，days[5] 和 days[6] 将分别被初始化为 30 和 31。
2. 如果再次初始化指定的元素，那么最后的初始化将会取代之前的初始化。如该例中，初始化列表开始时把days[1] 初始化为 28，但是 days[1] 又被后面的指定初始化 [1] = 29 初始化为 29。

**如果未指定数组元素大小会怎样？**

```c
int stuff[] = {1, [6] = 23}; //会发生什么？ 
int staff[] = {1, [6] = 4, 9, 10}; //会发生什么？
```

**编译器会把数组的大小设置为足够装得下初始化的值**。所以，stuff 数组有 7 个元素，编号为 0～6；而 staff 数组的元素比 stuff 数组多两个（即有9个元素）。

### 数组的使用

#### 对数组元素的访问
访问数组元素可以**使用数组表示法和指针表示法**，由于此时还没有学习指针的相关知识，因此这里只介绍数组表示法。数组表示法使用下标(或者称为索引)来访问数组元素的。使用的格式：`数组名[下标]`。

> **注意**：下标从 0 开始计数。这意味着对于一个数组元素个数为 n 的数组来说，其下标的取值范围为[0, n-1]，其中 0 表示数组的第一个元素，1 表示数组的第二个元素，...，n-1 表示数组的最后一个元素。

```c
int m[10] = {1, 2, 3, 4, [8]=9, 33, 2};// 1, 2, 3, 4, 0, 0, 0, 9, 33, 2.
int a = m[7]; // a的值是m数组的第8个元素，即9.
int b = m[4]; // b的值是m数组的第5个元素，即0.
```

在使用数组时，要防止数组下标超出边界。也就是说，必须确保下标是有效的值。例如，假设有下面的声明： `int doofi[20]; `。那么在使用该数组时，要确保程序中使用的数组下标在 0～19的范围内，因为编译器不会检查数组下标是否使用得当（但是，一些编译器发出警告，然后继续编译程序）。在 C 标准中，使用越界下标的结果是未定义的。这意味着程序看上去可以运行，但是运行结果很奇怪，或异常中止。

**C 语言为何会允许这种麻烦事发生？**这要归功于 C 信任程序员的原则。不检查边界，C 程序可以运行更快。编译器没必要捕获所有的下标错误，因为在程序运行之前，数组的下标值可能尚未确定。因此，为安全起见，编译器必须在运行时添加额外代码检查数组的每个下标值，这会降低程序的运行速度。C 相信程序员能编写正确的代码，这样的程序运行速度更快。但并不是所有的程序员都能做到这一点，所以就出现了下标越界的问题。

#### 对数组元素的赋值

在数组定义之后就不能再初始化数组了，但我们可以在声明数组后，借助数组下标(或索引)给数组元素赋值。

```c
#include <stdio.h> 
#define SIZE 50 
int main(void) 
{
    int counter, evens[SIZE]; 
    for (counter = 0; counter < SIZE; counter++) 
        evens[counter] = 2 * counter; 
    ... 
}
```

注意这段代码中使用循环给数组的元素依次赋值。只有初始化才可以对数组整体进行赋值，之后想要修改数组中元素的值只能通过赋值方式依次对需要修改的数组元素赋值。

**C 不允许把数组作为一个单元赋给另一个数组**，**除初始化以外也不允许使用花括号列表的形式赋值**。

```c
int oxen[5] = {5,3,2,8}; /* 初始化没问题 */ 
int yaks[5] = oxen;      /* 不允许 */ 
yaks[5] = oxen[5];       /* 数组下标越界 */
yaks[5] = {5,3,2,8};     /* 不起作用 */
```

#### 数组的大小

在 C99 标准之前，声明数组时只能在方括号中使用整型常量表达式。所谓整型常量表达式，是由整型常量构成的表达式。sizeof 表达式被视为整型常量，但是 const 值不是(这与 C++ 不同)。另外，表达式的值必须大于 0。

而 C99 标准允许使用变量作为数组的大小，这创建了一种新型数组，称为变长数组（variable-length array）或简称 VLA。VLA 有一些限制，例如，**声明 VLA 时不能进行初始化**。

### 数组和函数

假设要编写一个处理数组的函数，该函数返回数组中所有元素之和，待处理的是名为 marbles 的 int 类型数组。

#### 如何声明以及调用使用数组的函数？

记住，数组名是该数组首元素的地址，所以实际参数 marbles 是一个储存 int 类型值的地址，应把它赋给一个指针形式参数，即该形参是一个指向 int 的指针：

```c
int sum(int * ar); // 对应的函数原型
int main() {
    ...
	total = sum(marbles); // 函数调用
    ...
}
```

函数从实参获得了该数组首元素的地址，知道要在该位置上找出一个整数。注意，该参数并未包含数组元素个数的信息。 我们有两种方法让函数获得这一信息。第一种方法是，在函数代码中写上固定的数组大小。另一个比较灵活的方法是把数组大小作为第 2 个参数。还可传递两个指针分别指向数组的起始位置和终止位置。



注意！一定要时刻注意形参是函数的临时变量：

```c
#include<stdio.h>
int f(int* a, int* b);
int main()
{
    int a[] = {2, 3, 4};
    int b[] = {6, 3, 5};
    f(a, b);
    for(int i = 0; i < 3; i++)
        printf("%d ", a[i]);
    printf("\n");
    for(int i = 0; i < 3; i++)
        printf("%d ", *(b+i));
    getchar();
    return 0;
}
int f(int* a, int* b)
{
    b = a;
    return 0;
}
```

上面代码在 f() 中将 b 的地址赋值给 a，但是并不会改变 main 函数中的 a 和 b 数组。

#### 另一种形参表示

关于函数的形参，还有一点要注意。只有在函数原型或函数定义头中， 可以用 int ar[] 代替 int * ar，在其他地方是不可以的。 

```c
int sum1 (int ar[], int n); // 可以
int sum2 (int ar[], int n) { // 可以
    ...
}
int main() {
    int ar[]; // 错误
}
```

**int \*ar 形式和 int ar[] 形式都表示 ar 是一个指向 int 的指针**。但是，int ar[] 只能用于声明形式参数。第 2 种形式(int ar[])只是提醒读者指针 ar 指向的不仅仅一个 int 类型值，还是一个 int 类型数组的元素。

> PS：还可以用 sizeof 运算符来证明 int ar[] 是一个指针而不是数组(怎么证明的，大家可以思考一下，答案在后面)。



因为数组名是该数组首元素的地址，作为实际参数的数组名要求形式参数是一个与之匹配的指针。只有在这种情况下，C 才会把 int ar[] 和 int * ar 解释成一样。也就是说，ar 是指向 int 的指针。由于函数原型可以省略参数名， 所以下面 4 种原型都是等价的： 

```c
int sum(int *ar, int n); 
int sum(int *, int); 
int sum(int ar[], int n); 
int sum(int [], int);
```

但是，在函数定义中不能省略参数名。下面两种形式的函数定义等价： 

```c
int sum(int *ar, int n) 
{
	// 其他代码已省略 
}
int sum(int ar[], int n); 
{
	//其他代码已省略 
}
```

#### 思考题答案

```c
#include<stdio.h>
int f(int *a, int b[]);
int main()
{
    int a[] = {2, 3, 4};
    int b[] = {6, 3, 5};
    printf("main:%d\n", sizeof(b));
    f(a, b);
    getchar();
    return 0;
}
int f(int *a, int b[])
{
    printf("f:%d\n", sizeof(b));
    return 0;
}
```

<img src="E:\Note\Code Language\the-c\picture\basic\5-1.png" align="left" />

main 中的 sizeof 计算结果是：数组 b 的元素个数 * 数组 b 的元素类型占的内存大小，是会根据 b 数组的大小而改变的。例如，b 数组的元素个数是 5，则结果是 20。

f 中的 sizeof 计算结果是：指针占据的内存大小，是确定的。64 位系统的指针固定占 8 位，32 位系统的指针固定占 4 位。

### 多维数组

多维数组其实就是二维数组的继续延申，而且在正常项目中，常用的多维数组就是二维数组了，因此下面我们重点介绍一下二维数组的定义、初始化以及使用。

#### 二维数组

我们之前介绍的数组只有一个下标，称为一维数组，其数组元素也称为单下标变量。在实际问题中有很多量是二维的或多维的，因此 C 语言允许构造多维数组。多维数组元素有多个下标，以标识它在数组中的位置，所以也称为多下标变量。

二维数组就是有两个下标的数组，是常用的多维数组，更高维的数组其实使用的并不多。二维数组定义的一般形式：

```c
type array_Name[n][m];
```

> PS：type 是数组元素的类型，array_Name 是数组名，n 和 m 为常量表达式。

```c
float rain[5][12];
```

**应该如何理解这个数组？**

事实上，**C 语言依旧将二维数组识别为一维数组**，只不过数组的元素不再是如 int 类型的变量了，而是一个数组。那么 rain\[5]\[12] 是有 5 个元素的数组，其中每个元素是一个含有 12 个元素的数组，还是有 12 个元素的数组，其中每个元素是一个含有 5 个元素的数组呢？

这个问题在于 [] 这个运算符的结合方向，[] 是自左向右的，因此编译器识别 rain\[5]\[12] 时，会先和 \[5] 结合，认为 rain 是一个含有 5 个元素的数组，然后识别 \[12] 认为 rain 的每一个元素都是一个含有 12 个元素的数组。

根据以上分析可知，rain 的首元素 rain\[0] 是一个内含 12 个 float 类型值的数组。所以，rain\[1]、rain\[2]等也是如此。如果 rain[0] 是一个数组，那么它的首元素就是 rain\[0]\[0]，第 2 个元素是 rain\[0]\[1]，以此类推。简而言之，数组 rain 有 5 个元素，每个元素都是内含 12 个 float 类型元素的数组，rain\[0] 是内含 12 个 float 值的数组，rain\[0]\[0] 是一个 float 类型的值。假设要访问位于 2 行 3 列的值，则使用 rain\[2]\[3]（记住，数组元素的编号从 0 开始，所以 2 行指的是第 3 行）。

这里对于二维数组，我们往往会采用数学上的行和列来描述，行指的是第一个[]，列指的是第二个[]。这也是因为用二维视图有助于理解二维数组的两个下标。

![](E:\Note\Code Language\the-c\picture\basic\5-2.png)

#### 二维数组初始化

初始化二维数组是建立在初始化一维数组的基础上。首先，初始化一维数组如下： 

```c
sometype ar1[5] = {val1, val2, val3, val4, val5}; 
```

这里，val1、val2 等表示 sometype 类型的值。例如，如果 sometype 是 int，那么 val1 可能是 7；如果 sometype 是 double，那么 val1 可能是 11.34，诸如此类。

```c
int arr1[3][4];
```

如上所示的 arr1 是一个内含 3 个元素的数组，每个元素又是内含 4 个 int 类型元素的数组。所以，对 arr1 而言，val1 应该包含 4 个值，用于初始化内含 4 个 int 类型元素的一维数组。也就是说，因此，为了初始化二维数组 arr1，要用逗号分隔 3 个这样的数值列表：

```c
int arr1[3][4] = {{1, 1, 2, 3}, {2, 4, 5, 3}, {3, 4, 5, 2}};
```

这个初始化使用了 3 个数值列表，**每个数值列表都用花括号括起来**。第 1 个列表的数据用于初始化数组的第 1 行，第 2 个列表的数据用于初始化数组的第 2 行，以此类推。

前面讨论的**数据个数和数组大小不匹配的问题同样适用于这里的每一行**。也就是说，如果第 1 个列表中只有 2 个数，则只会初始化数组第 1 行的前两个元素，而后两个元素将被默认初始化为 0。如果某列表中的数值个数超出了数组每行的元素个数，则会出错，但是这并不会影响其他行的初始化。

> PS：做牛客上的题时，有遇到一个题说初始化二维数组时，{} 中没有任何元素会报错，实践之后发现是可以正确执行的，而且没有任何资料说 {} 是错误的。

**初始化时也可省略内部的花括号，只保留最外面的一对花括号**。只要保证初始化的数值个数正确，初始化的效果与上面相同。但是如果初始化的数值不够，则按照先后顺序逐行初始化，直到用完所有的值。后面没有值初始化的元素被统一初始化为0。

这两种初始化的区别：

![](E:\Note\Code Language\the-c\picture\basic\5-3.png)

#### 二维数组的使用

二维数组和一维数组相同，有数组表示法和指针表示法，其中指针表示法在指针处讲解。数组表示法和一维数组类似。

```c
array[4][6]; // array 数组第5行第6列的元素
```

#### 其他多维数组

前面讨论的二维数组的相关内容都适用于三维数组或更多维的数组。可以这样声明一个三维数组： 

```c
int box[10][20][30]; 
```

可以把一维数组想象成一行数据，把二维数组想象成数据表，把三维数组想象成一叠数据表。例如，把上面声明的三维数组 box 想象成由 10 个二维数组（每个二维数组都是20行30列）堆叠起来。



还有一种理解 box 的方法是，把 box 看作数组的数组。

也就是说，box 内含 10 个元素，每个元素是内含 20 个元素的数组，这 20 个数组元素中的每个元素是内含 30 个元素的数组。或者，可以简单地根据所需的下标值去理解数组。



通常，处理三维数组要使用 3 重嵌套循环，处理四维数组要使用 4 重嵌套循环。对于其他多维数组，以此类推。 

## 指针

### 指针简介

#### 内存

指针会涉及到内存地址，因此在指针之前先了解下内存的相关知识。

外存就是我们常用的硬盘(C盘、D盘等)、U 盘、光盘等。外存存储的数据量大，但是处理数据的速度慢，而 CPU 的运行速度是非常快的，为了提高效率，就出现了内存，内存存储的数据量小(目前常见的是 8 G)，但是处理数据的速度快，**CPU 处理的数据都在内存中**。

**内存和外存的区别**：

1. **内存存储的数据量远小于外存**。目前个人电脑内存比较常见的是 8G 和 16G，而硬盘常见的应该是 300G 左右吧，U 盘基本上也是 32G 左右的比较常用。
2. **内存速度比外存的速度快**。这也是使用内存的原因，外存处理数据速度太慢，而内存的速度则比外存快的太多了，因此使用内存来和 CPU 进行数据的交互。
3. **内存的成本大于外存**。要是内存成本 <= 外存成本，那么直接就是全用内存作为存储设备了，还分啥内外存呢。
4. **内存存储数据的时间小于外存**。内存存储的数据在断电之后会消失，而外存会一直存储。

	> 为了进一步提高效率，在内存和 CPU 之间还会有缓存。缓存的存储量更小，速度更快。

我们编写的程序(代码)在不执行的时候，以文件的形式存储在外存中。而当我们执行程序时，程序就会被调入到内存中(程序在执行之后称为进程)。在编写 C 语言程序时，我们写的变量、函数等等，都是会在程序执行之后放入到内存中，以供 CPU 使用。而 CPU 只能通过地址来获取内存中的代码和数据，程序在执行过程中会告知 CPU 要执行的代码以及要读写的数据的地址。

CPU 访问内存时需要的是地址，而不是变量名和函数名！变量名和函数名只是地址的一种助记符，是为我们提供方便的，让我们在编写代码的过程中可以使用易于阅读和理解的英文字符串，不用直接面对二进制地址。当源文件被编译和链接成可执行程序后，它们都会被替换成地址。编译和链接过程的一项重要任务就是找到这些名称所对应的地址。

#### 什么是指针？

**从根本上看，****指针是一个****值为内存地址的****变量**(或数据对象)。正如 char 类型变量的值是字符，int 类型变量的值是整数，**指针变量的值是地址**。

事实上，我们的程序中的变量名、函数名、指针在本质上是一样的，它们都是**地址助记符**。但在编写代码的过程中，我们认为变量名表示的是数据本身，而函数名、指针表示的是代码块或数据块的首地址。

#### 为什么学习指针？

1. 指针提供一种以符号形式使用地址的方法。因为计算机的硬件指令非常依赖地址，指针在某种程度上把程序员想要传达的指令以更接近机器的方式表达。因此，使用指针的程序更有效率。
2. 指针的大小是固定的，在 32 位系统中占 4 字节，在 64 位系统中占 8 字节。在面对普通的数据类型时，我们可能不觉得有什么，但是在学习过结构体之后，函数间传递结构体一般都是用函数体指针，而不是传递结构体的值，因为这样可以节省很大的内存开支。

#### 声明指针变量

定义指针变量与定义普通变量非常类似，不过要在变量名前面加星号*，格式为：

```cpp
// 声明指针变量
变量类型* 变量名;

// 声明并初始化指针变量
变量类型* 变量名 = 地址值;
```

示例：

```cpp
// 声明指针变量
double* p; // p 是指向 double 类型的指针
// 声明并初始化指针变量
int a = 10;
int* q = &a; // q 是指向 int 类型的指针
```

> 运算符* 在这里的含义是指针，运算符& 在这里的含义是取地址符。

**声明指针变量时必须指定指针所指向变量的类型**。首先，指针只保存数据的首地址，而不同的变量类型占用不同的存储空间，一些指针操作要求知道操作对象的大小。其次，程序必须知道储存在指定地址上的数据类型，long 和 float 可能占用相同的存储空间，但是它们储存数字却大相径庭。

类型说明符表明了指针所指向对象的类型，星号（*）表明声明的变量是一个指针。

![](E:\Note\Code Language\the-c\picture\basic\5-4.png)

#### 地址运算符

在指针中常用的两个地址运算符 —— & 和 *。

**& 运算符**，也称取址运算符，后面跟变量名，给出该变量的地址。

**\*  运算符**，也称解引用运算符，后面跟指针名(或地址)，给出存储在指针指向的地址上的值。

#### 指针初始化

普通变量可以初始化，`type name=value;`。同样的，指针变量也可以初始化，初始化的值是一个地址值。可以借助 & 运算符将某个变量的地址赋值给指针。

```c
int a = 5;
int* ptr = &a; // ptr指针指向a
```

也可以将指针变量赋值给另一个指针变量。

```c
int a = 5;
int* ptr1 = &a; // ptr1指针指向a
int* ptr2 = ptr1;
```

**注意**，将普通变量赋值给指针时，需要在普通变量前面加 & 运算符，因为指针的值是地址，所以用 & 获取普通变量的地址，并赋值给指针变量。而指针变量给指针变量赋值时，直接赋值即可，不需要用 & 运算符。

将普通变量的地址赋值给指针变量的过程也称作指针指向变量。



对于二维指针来说，一维指针相当于普通变量：

```c
int a = 5;
int* ptr1 = &a;
int** ptr2 = &ptr1;
```

#### 指针的使用

指针变量的值是地址，但我们往往需要使用的是指针指向的数据，这是就需要用到 * 运算符。

```c
int a = 5;
int* ptr = &a;
// *ptr 是 5
```

#### 数组的指针表示法

**在 C 语言中** **ar[i] 和 \*(ar+i) 是等价的，无论 ar 是数组还是指针变量**。但只有当 ar 是指针变量时，才能对 ar 值进行修改，如 ar++。

指针表示法（尤其与递增运算符一起使用时）更接近机器语言，因此一些编译器在编译时能生成效率更高的代码。还记得我们在学习数组时提到的指针表示法吗？指针表示法就是将数组当成指针变量来访问数组元素。

```c
int arr[6] = {1, 4, 3, 6, 1, 8};
// arr[0] 等价于 *(arr + 0) 或 *(arr)
// arr[1] 等价于 *(arr + 1)
// arr[2] 等价于 *(arr + 2)
```

对于多维数组也可以使用指针表示法：

```c
int arr[3][4] = {{1,3,4},{1,2,3,3},{4,5}};
// arr[0][3] 等价于 *(*(arr)+3)
// arr[1][2] 等价于 *(*(arr+1)+2)
```

#### 指针运算

指针可以的运算有六种，分别是赋值、解引用、取址、加法、减法、比较。

> PS：指针变量没有乘除法运算，且两个指针相加是没有意义的。

1. **赋值**：**可以将地址赋值给指针。** 例如，用数组名、带地址运算符（&）的 变量名、另一个指针进行赋值。

2. **解引用**：**\* 运算符给出指针指向地址上储存的值。**

3. **取址**：**和所有变量一样，指针变量也有自己的地址和值。** 对指针而言， &运算符给出指针本身的地址。

4. **加法**：指针和整数相加；指针递增。

5. **减法**：指针和整数相减；指针递减；指针和指针相减。通过计算求出两元素之间的距离，通常用于求同一个数组中两个元素的距离。

6. **比较**：**使用关系运算符可以比较两个指针的值**，前提是两个指针都指向相同类型的对象。

   > 千万不要解引用未初始化的指针！！！可能会导致极其严重的错误 —— 可能会擦写数据或代码，或者导致程序崩溃

### 指针数组和数组指针

刚开始接触指针的小白，可能碰到一些复杂点的指针类型就懵逼了，包括比较经典的指针常量和常量指针、指针数组和数组指针的辨析，例如：

```c
int *p[5];
int (*p)[5];
```

#### 什么是指针数组和数组指针？

**指针数组**：数组元素是指针的数组。**数组指针**：指向一个数组的指针。

> 记忆的小技巧：和常量指针以及指针常量的记忆类似，记住数组元素是指针和指向一个数组的指针这两句话，将**指针数组**当作数组元素是**指针**的**数组**的缩写，**数组指针**记作指向一个**数组**的**指针**的缩写。

以什么结尾主体就是什么。例如，指针数组是一个数组，什么样的数组？数组元素是指针的数组；数组指针是一个指针，什么样的指针？指向一个数组的指针。

#### 如何声明指针数组以及数组指针？

了解了指针数组和数组指针的概念，下面我们来学习如何声明指针数组和数组指针。在指针数组和数组指针这里最重要的一个知识点是 \* 和 [] 运算符的优先级。

![](E:\Note\Code Language\the-c\picture\basic\5-5.png)

可以看到，\* 运算符优先级低于 [] 运算符。

```c
int *ptr[10];
```

因此，在上面的代码中 [] 运算符优先和 ptr 结合，**说明 ptr 是一个数组**。然后 * 运算符结合，说明 ptr 数组的元素是一个指针。再和 int 结合，**说明 ptr 数组元素是一个 int 类型的指针**。因此 ptr 是一个含有十个数组元素的数组，数组元素是 int 类型的指针，即 ptr 是一个指针数组。

我们在来看一个例子：

```c
int (*ptr)[10];
```

在上面的代码中，() 运算符优先级最高，需要先看 () 里面的内容。\* 优先和 ptr 结合，**说明 ptr 是一个指针**。然后 [] 运算符结合，说明 ptr 指向的内容是一个数组。再和 int 结合，说明 ptr 指向的数组的元素是 int 类型的。因此 ptr 是一个指向含有 10 个数组元素数组的指针，数组的元素是 int 类型的，即 ptr 是一个数组指针。



总结：**如何区分数组指针和指针数组的定义？**从变量名处起，根据运算符优先级结合，一步一步分析。

> PS：对于复杂类型的变量也是这样看的。

### 指针常量和常量指针

#### 什么是指针常量和常量指针？

**指针常量**：**指针是一个常量**。**特点**：指针的值不能修改，因为指针是一个常量，但是指针指向的值可以改变。

**常量指针**：**指向常量的指针**。顾名思义，指针指向的是一个常量。**特点**：指针的值可以修改，但是指针指向的值不可以修改，因为指针指向的是一个常量。

> 记忆的小技巧：记住指针是一个常量和指向常量的指针这两句话，把**指针常量**记作**指针**是一个**常量**的缩写，同理，**常量指针**当作**指向常量的指针**的缩写。

#### 如何声明常量指针和指针常量？

```c
const int* a1;
int const *a2;
int* const a3;
```

以上代码演示了 const 的三个位置，分别是在类型前面、在类型和 * 中间、在 * 后面。那么到底**哪个是指针常量，哪个是常量指针？**

1. 只需要关注 const 和 * 的相对位置。
2. const 在 * 之前是常量指针，指向常量的指针。const 在 * 后面是指针常量，指针是一个常量。

再回来看上面的代码，a1 和 a2 的 const 再 * 前面，因此 a1 和 a2 都是常量指针。a3 的 const 在 * 后面，因此 a3 是指针常量。

> 记忆的小技巧：从左往右看，遇到 const 读常量，遇到 * 读指针。因此 `const int* a1;` 是常量指针，`int const *a2;` 也是常量指针，`int* const a3;` 是指针常量。

#### 常量指针常量

将常量指针和指针常量混合起来就是常量指针常量，指向常量的指针常量。

```c
const int* const a;
int const * const b;
// a 和 b 都是常量指针常量
```

我们依旧用小技巧来读，常量(const)指针(*)常量(const)。

#### 复杂指针类型的练习

```c
int p;    
// 这是一个普通的整型变量  

int *p;   
// 首先从p处开始,先与*结合,说明p是一个指针；
// 然后再与int结合,说明指针所指向的内容的类型为int型.
// 所以p是一个返回整型数据的指针  
      
int p[3];   
// 首先从p处开始,先与[]结合,说明p是一个数组;
// 然后与int结合,说明数组里的元素是整型的.
// 所以p是一个由整型数据组成的数组 
      
int *p[3]; // 指针数组
// 首先从p处开始,先与[]结合,因为其优先级比*高,所以p是一个数组;
// 然后再与*结合,说明数组里的元素是指针类型;
// 然后再与int结合,说明指针所指向的内容的类型是整型的;
// 所以P 是一个由返回整型数据的指针所组成的数组  

int (*p)[3]; // 数组指针
// 首先从p处开始,先与*结合,说明p是一个指针;
// 然后再与[]结合,说明指针所指向的内容是一个数组;
// 然后再与int结合,说明数组里的元素是整型的;
// 所以p是一个指向由整型数据组成的数组的指针

int **p; 
// 首先从p开始,先与*结合,说是p是一个指针;
// 然后再与*结合,说明指针所指向的元素是指针;
// 然后再与int结合,说明该指针所指向的元素是整型数据.
// 由于二级指针以及更高级的指针极少用在复杂的类型中,
// 所以后面更复杂的类型我们就不考虑多级指针了,最多只考虑一级指针. 
 
int p(int); 
//从p处起,先与()结合,说明p是一个函数;
// 然后进入()里分析,说明该函数有一个整型变量的参数;
// 然后再与外面的int结合,说明函数的返回值是一个整型数据.

int (*p)(int); 
// 从p处开始,先与指针结合,说明p是一个指针;
// 然后与()结合,说明指针指向的是一个函数;
// 然后再与()里的int结合,说明函数有一个int型的参数;
// 再与最外层的int结合,说明函数的返回类型是整型;
// 所以p是一个指向有一个整型参数且返回类型为整型的函数的指针.
  
int *(*p(int))[3]; 
//可以先跳过,不看这个类型,过于复杂.
// 从p开始,先与()结合,说明p是一个函数;
// 然后进入()里面,与int结合,说明函数有一个整型变量参数;
// 然后再与外面的*结合,说明函数返回的是一个指针;
// 然后到最外面一层,先与[]结合,说明返回的指针指向的是一个数组;
// 然后再与*结合,说明数组里的元素是指针;
// 然后再与int结合,说明指针指向的内容是整型数据.
// 所以p是一个参数为一个整数且返回一个指向由 整型指针变量组成的数组 的指针变量的函数.
```

> PS：函数指针是在结构体哪里讲解，目前了解即可。

### 指针和多维数组

**指针和多维数组有什么关系？为什么要了解它们的关系？**处理多维数组的函数要用到指针，所以在使用这种函数之前，先要更深入地学习指针。



#### 指针和多维数组的关系

```c
int zippo[4][2]; /* 内含int数组的数组 */
```

数组名 zippo 是该数组首元素的地址。在本例中，zippo 的首元素是一个内含两个 int 值的数组，所以 zippo 是这个内含两个 int 值的数组的地址。



下面，我们从指针的属性进一步分析。

因为 zippo 是数组首元素的地址，所以 zippo 的值和 &zippo\[0] 的值相同。而 zippo\[0] 本身是一个内含两个整数的数组，所以 zippo\[0] 的值和它首元素（一个整数）的地址（即&zippo\[0]\[0]的值）相同。

简而言之，zippo\[0] 是一个占用一个 int 大小对象的地址，而 zippo 是一个占用两个 int 大小对象的地址。由于这个整数和内含两个整数的数组都开始于同一个地址，所以 zippo 和 zippo\[0] 的值相同。 

给指针或地址加 1，其值会增加对应类型大小的数值。在这方面，zippo 和 zippo\[0] 不同，因为 zippo 指向的对象占用了两个 int 大小，而 zippo\[0] 指向的对象只占用一个 int 大小。因此， zippo + 1 和 zippo\[0] + 1 的值不同。 

解引用一个指针（在指针前使用 \* 运算符）或在数组名后使用带下标的 \[] 运算符，得到引用对象代表的值。因为 zippo\[0] 是该数组首元素（zippo\[0]\[0]）的地址，所以 \*(zippo\[0]) 表示储存在 zippo\[0]\[0] 上的值（即一个 int 类型的值）。与此类似，\*zippo 代表该数组首元素（zippo\[0]）的值，但是 zippo\[0] 本身是一个 int 类型值的地址。该值的地址是 &zippo\[0]\[0]，所以 \*zippo 就是 &zippo\[0]\[0]。对两个表达式应用解引用运算符表明， \*\*zippo 与 \*&zippo\[0]\[0] 等价，这相当于 zippo\[0]\[0]，即一个 int 类型的值。

简而言之， zippo 是地址的地址，必须解引用两次才能获得原始值。地址的地址或指针的指针是就是双重间接（double indirection）的例子。 

显然，增加数组维数会增加指针的复杂度。现在，大部分初学者都开始意识到指针为什么是 C 语言中最难的部分。

```c
int zippo[4][2] = { { 2, 4 }, { 6, 8 }, { 1, 3 }, { 5, 7 } }; 
printf(" zippo = %p, zippo + 1 = %p\n",zippo, zippo + 1);
printf("zippo[0] = %p, zippo[0] + 1 = %p\n",zippo[0], zippo[0] + 1); 
printf(" *zippo = %p, *zippo + 1 = %p\n",*zippo, *zippo + 1); 
printf("zippo[0][0] = %d\n", zippo[0][0]); 
printf(" *zippo[0] = %d\n", *zippo[0]); 
printf(" **zippo = %d\n", **zippo); 
printf(" zippo[2][1] = %d\n", zippo[2][1]); 
printf("*(*(zippo+2) + 1) = %d\n", *(*(zippo + 2) + 1));
// 结果
zippo = 0x0064fd38, zippo + 1 = 0x0064fd40 
zippo[0]= 0x0064fd38, zippo[0] + 1 = 0x0064fd3c 
*zippo = 0x0064fd38, *zippo + 1 = 0x0064fd3c 
zippo[0][0] = 2 
*zippo[0] = 2 
**zippo = 2 
zippo[2][1] = 3 
*(*(zippo+2) + 1) = 3 
```

要特别注意，与 zippo\[2]\[1] 等价的指针表示法是 \*(\*(zippo+2) + 1)。看上去比较复杂，应最好能理解。下面列出了理解该表达式的思路：

![](E:\Note\Code Language\the-c\picture\basic\5-6.png)

![](E:\Note\Code Language\the-c\picture\basic\5-7.png)

#### 指向二维数组的指针

声明一个指向二维数组的指针使用的是数组指针。

```c
int (* pz)[2];
```

#### 指针的兼容性

指针之间的赋值比数值类型之间的赋值要严格。例如，不用类型转换就可以把 int 类型的值赋给 double 类型的变量，但是两个类型的指针不能这样做。

```c
int (*pa)[2];
int (*pb)[3];
int ar[3][2];
int **p; // 一个指向指针的指针

pa = ar; // 有效都是指向内含2个int类型元素数组的指针
pb = ar; // 无效
p  = ar; // 无效
*p = ar[0]; // 有效
```

#### 形参是二维数组的函数的声明

以 arr[2][3] 作为实参为例，支持下面两种形参是二维数组的函数声明和定义。

```c
int f(int (*ar)[3]);
int f(int ar[][3]);
```

**注意，数组的列数是必须和实参一致的，不能省略。**这一点十分重要，因为列数向函数传递了必须的信息。



刚开始学的时候，可能会疑惑为什么 int\*\* ar 不能来接收二维数组。下面来讲解一下 **int\*\* ar 和 int (\*ptr)[3] 有什么差别**？这主要是由于指针加法的问题。这涉及到编译器如何对一个指针进行加法操作了。因此，我们先看一下指针怎么进行加法的。

以 int* ptr 为例，ptr + 3，编译器会先从 ptr 中读取地址，然后判断这个指针的类型是 int 类型，才知道对 ptr + 3 应该是加三个 int 的长度，即地址加 3*4 个字节。



总结一下，编译器对指针的加法操作：1. 获取指针变量指向的地址；2. 获取指针类型，计算该指针指向的类型的内存大小；3. 计算加法操作之后的地址。



如此，我们再回来看一下 int\*\* ar 指针，对它进行 +1 操作的过程：1. 获取 ar 指针指向的地址；2. 指针指向的类型是 int\*(int\* 在 32 位系统中是 4 字节，64 位系统中是 8 字节，这里我们假设是 64 位系统)，占据的内存大小是 8 字节；3. 对 ar + 1 就是在 ar 指向的地址的基础上加 1\*8 个字节。

而 int (\*ptr)[3] 的加法：ptr+1 的过程：1. 获取 ptr 的地址；2. ptr 的类型是含有三个元素的数组，数组的元素是 int，因此 ptr 指向的类型占据的内存大小是 3 个 int 类型的大小，即 12 个字节；3. 对 ptr + 1 就是在 ptr 指向的地址的基础上加 1*12 个字节。

```c
#include<stdio.h>
int f(int **a);
int main()
{
    int a[2][3] = {{1, 7, 8},{2, 3, 4}};
    f(a);
    return 0;
}
int f(int **a)
{
    printf("*(a+1):%d\n", *(a+1));
    return 0;
}
```

输出结果：8。

可以看到 int\*\* ar 的加法操作和二维数组是有区别的，因此用 ar 去接收二维数组在运行时极可能会造成程序的崩溃。所以 int (\*ptr)[3] 中的 [3] 就是为了告诉编译器进行指针加法运算时应该移动的距离。



**一般而言，声明一个指向 N 维数组的指针时，只能省略最左边方括号中的值**：

```c
int sum4d(int ar[][12][20][30], int rows);
```

### 指针、数组、函数

#### 指针和数组

学习过指针之后，回忆下我们学过的数组的知识，可以发现指针和数组名都表示地址，它们之间有什么联系和区别吗？

**联系：**指针和数组的联系很紧密，**指针和数组名都是地址**。在学习数组知识的时候，访问数组元素的时候，可以使用指针表示法和数组表示法。

在 C 语言中，数组和指针非常相似，甚至可以互换。可以用指针表示数组，也可以用数组表示指针。比如在函数的参数中，如果传递的是一个数组，可以用一个指针变量来接收。所以对于初学者来说，可以简单的理解为，数组和指针等价。但事实上，数组和指针还是有区别的，这一点我们稍后再说。

我们的系统中，地址按字节编址。在 C 中，指针加 1 指的是增加一个存储单元。对数组而言，这意味着把加 1 后的地址是下一个元素的地址，而不是下一个字节的地址。这是为什么必须声明指针所指向对象类型的原因之一。只知道地址不够，因为计算机要知道储存对象需要多少字节。

![](E:\Note\Code Language\the-c\picture\basic\5-8.png)



**区别**：指针是变量，而数组名是常量。

编译器把数组名识别为该数组首元素地址的别名，因此数组名必须为常量，不然一旦改变数组名的值，就意味着改变了数组的存储位置。那么指针是变量，数组名是常量会有什么差异呢？

**1.赋值问题。** 可以用数组名为指针赋值，但是不能用指针为数组名赋值(常量可以赋值给变量，但是常量不能被赋值)。

```cpp
const char * pt1 = "Something is pointing at me."; 
const char arr1[] = "Something is pointing at me.";
pt1 = arr1; // 正确
arr1 = pt1; // 错误
```

**2.自增自减操作。** 指针可以进行自增自减操作，数组名不可以。因为数组名是常量，对数组名进行自增操作，就像是 `3++` 是错误的语法。

```cpp
const char * pt1 = "Something is pointing at me."; 
const char arr1[] = "Something is pointing at me.";
pt1++; // 正确
arr1++; // 错误。
```

**3.内存大小。** 数组会占用 `元素个数 * 元素类型的内存大小` 的空间，而指针只会占据一个指针变量的空间。

> PS：指针变量的存储大小是由编译器决定的，而不是它指向的数据类型决定的。指针变量在 32 位编译器中是占 4 字节(32 位)，在 64 位编译器中是占 8 字节(64 位)。可以根据这一特点判断使用的编译器是多少位的。


例如，下面的两个字符串变量，由于字符串字面量会被保存在内存中，pt1 只是指向了该字符串字面量的首地址，而 arr1 则是申请到了一块内存区域来保存这个字符串的副本。这意味着**使用指针的时候，内存中只存有一个该字符串；而使用数组时，内存中会存在两个该字符串**。

```cpp
const char * pt1 = "Something is pointing at me."; 
const char arr1[] = "Something is pointing at me.";
printf("sizeof(pt1):%d\n", sizeof(pt1));
printf("sizeof(arr1):%d\n", sizeof(arr1));
```

<img src="E:\Note\Code Language\the-c\picture\basic\5-9.png" align="left" />

**4.二维数组。** 规则矩形和不规则矩形。

```cpp
int arr1[] = {1, 2, 3};
int arr2[] = {5, 7};
int arr3[] = {3, 2, 8, 9};
int arr4[] = {2};
int arr5[] = {1, 8};

int *pt[5] = {arr1, arr2, arr3, arr5, arr5};
int arr[5][5] = {{1, 2, 3}, {5, 7}, {3, 2, 8, 9}, {2}, {1, 8}};
```

pt 可以看作不规则的矩阵二维数组，每行长度不同；而 arr 则看作规则的二维数组，每行长度都是 5。

```cpp
// pt
1 2 3
5 7
3 2 8 9
2
1 8

// arr
1 2 3 0 0
5 7 0 0 0
3 2 8 9 0
2 0 0 0 0
1 8 0 0 0
```

#### 指针和函数

学习过指针之后，我们就可以来看看地址传递参数的本质了。在讲函数参数传递机制的时候，我们提到了地址传递，当时用到的程序是交换函数的两个参数的值，代码如下：

```c
#include<stdio.h>
int swap(int *a, int *b);
int main()
{
    int a = 30, b = 24;
    printf("main 交换前：a=%d, b=%d\n", a, b);
    swap(&a, &b);
    printf("main 交换后：a=%d, b=%d\n", a, b);
 
    return 0;
}
int swap(int *x, int *y)
{
    int temp = *x;
    *x = *y;
    *y = temp;
}
```

在学习指针之后，能够看出来 swap 函数中的参数实际上就是一个指针变量。传递的 &a 和 &b 是变量 a 和 b 的地址。在地址传递中，我提到过其本质依旧是值传递，在学习过指针之后，我们可以来看看为什么会这么说了。我们对上面的代码进行一下小修改。

```c
#include<stdio.h>
int swap(int *a, int *b);
int main()
{
    int a = 30, b = 24;
    printf("main：&a=%p, &b=%p\n", &a, &b);
    int* ptr1 = &a;
    int* ptr2 = &b;
    printf("main：&ptr1=%p, &ptr2=%p\n", &ptr1, &ptr2);
    printf("main：ptr1=%p, ptr2=%p\n", ptr1, ptr2);
    printf("main：*ptr1=%d, *ptr2=%d\n", *ptr1, *ptr2);
    printf("main 交换前：a=%d, b=%d\n", a, b);
    swap(ptr1, ptr2);
    printf("main 交换后：a=%d, b=%d\n", a, b);

    return 0;
}
int swap(int *x, int *y)
{
    printf("swap：&x=%p, &y=%p\n", &x, &y);
    printf("swap：x=%p, y=%p\n", x, y);
    printf("swap：*x=%d, *y=%d\n", *x, *y);
    int temp = *x;
    *x = *y;
    *y = temp;
}
```

![](E:\Note\Code Language\the-c\picture\basic\5-10.png)

整型变量 a 的地址是 0x61FE1C，整型变量 b 的地址是 0x61FE18。

main 函数中指针变量 ptr1 的地址是 0x61FE10，存储的值是整型变量 a 的地址 0x61FE1C；指针变量 ptr2 的地址是 0x61FE08，存储的值是整型变量 b 的地址 0x61FE18。

swap 函数中的指针变量 x 的地址是 0x61FDE0，存储的值是整型变量 a 的地址 0x61FE1C；指针变量 y 的地址是 0x61FDE8，存储的值是整型变量 b 的地址 0x61FE18。

**这说明什么？**这说明 main 函数中调用 swap 函数时传递参数 ptr1 和 ptr2，其实依旧是传递的 ptr1 和 ptr2 的值，也就是整型变量 a 和 b 的地址，并用这个值去初始化了 swap 中的形式参数 —— 指针变量 x 和 y。所以本质上地址传递依旧是值传递。



**指针与函数可以有以下的联系**：

1. **在函数间传递信息**。如果希望在被调函数中改变主调函数的变量，参数必须使用指针。

2. **处理参数是数组的函数**。通常函数的参数都是直接传递数值，只有程序需要在函数中改变该数值时，才会传递指针。但是对于数组别无选择，必须传递指针，因为这样做效率高。如果函数的意图不是修改数组中的数据内容，那么在函数原型和函数定义中声明形式参数时应使用关键字 const。

   >  **PS**：这样使用 const 并不是要求原数组是常量，而是该函数在处理数组时将其视为常量，不可更改。

3. **函数也可以有指针**，事实上函数名本身就代表着地址，使用函数指针可以在结构体中定义函数。

#### 指针和结构体

这一部分内容主要是放在结构体的知识中，所以这部分内容目前不需要记住。使用指针访问结构体的成员变量有两种方法：

```c
Struct {
    int a;
    double b;
} *ptr;

int main(void)
{
 	(*ptr).b; // 第一种方法
    ptr->a;   // 第二种方法
}
```

### 函数指针

#### 函数指针的用途

C 语言指针除了可以指向变量之外，还可以声明指向函数的指针，这种指针被称为函数指针。**这个复杂的东西到底有何用处**？

1. 函数指针可以作为另一个函数的参数，告诉该函数要使用哪一个函数。例如，回调函数就是用函数指针。
2. 函数指针可以作为结构体的成员。在结构体中不能直接声明函数，但是可以声明函数指针。这样就可以用结构体替代 C++ 中的类，这也体现了面向对象是一种思想，而不是语言，因为使用 C 语言一样可以实现面向对象编程。

这里主要介绍函数指针的第一种用法 —— 作为函数的参数。**用函数指针作为函数的参数有什么好处**？**A**：可以抽象出更通用的函数，通过传递函数指针来实现不同的效果。比较经典的函数指针作为函数参数的例子 —— C 库的 qsort() 函数：

```c
// <stdlib.h> 中 qsort() 函数原型:
void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void*))
```

排序数组涉及比较两个元素，以确定先后。如果元素是数字，可以使用 > 运算符；如果元素是字符串或结构，就要调用函数进行比较。C 库中的 qsort() 函数可以处理任意类型的数组，但是要告诉 qsort() 使用哪个函数来比较元素。为此， qsort() 函数的参数列表中，有一个参数接受指向函数的指针。然后，qsort() 函数使用该函数提供的方案进行排序，无论这个数组中的元素是整数、字符串还是结构。下面演示一下使用 函数指针作为参数的 qsort() 函数的灵活性：

```c
#include<stdio.h>
#include<stdlib.h>
int compare_int1(const void* a, const void* b)
{
    int *c = (int*) a;
    int *d = (int*) b;
    return *c - *d;
}
int compare_int2(const void* a, const void* b)
{
    int *c = (int*) a;
    int *d = (int*) b;
    return *d - *c;
}
void print_arr(int arr[], size_t num)
{
    for(int i = 0; i < num; i++)
        printf("%d ", arr[i]);
    printf("\n");
}
int main()
{
    int a[10] = {35, 12, 55, 27, 34, 59, 94, 0, 25, 87};
    printf("排序前 a 数组：");
    print_arr(a, 10);
    printf("-----------------------\n");
    qsort(a, 10, sizeof(a[0]), compare_int1);   
    printf("----- 从小到大排序 -----\n");
    printf("排序后 a 数组：");
    print_arr(a, 10);
    printf("-----------------------\n");
    printf("----- 从大到小排序 -----\n");
    printf("排序后 a 数组：");
    qsort(a, 10, sizeof(a[0]), compare_int2);
    print_arr(a, 10);
    return 0;
}
// 结果：
排序前 a 数组：35 12 55 27 34 59 94 0 25 87 
-----------------------
----- 从小到大排序 -----
排序后 a 数组：0 12 25 27 34 35 55 59 87 94
-----------------------
----- 从大到小排序 -----
排序后 a 数组：94 87 59 55 35 34 27 25 12 0
```

可以看到，通过传递不同的函数可以让 qsort() 函数分别实现从小到大排序和从大到小排序的效果，这样不需要我们分别创建两个排序函数，大大减少代码量。除了基本数据类型的排序，也可以通过传递函数指针的方式让 sqort() 函数对字符串数组、结构体数组进行排序，而且我们可以自定义按照什么规则进行排序。

> PS：学过 Java 的朋友应该会比较熟悉，在 Java 中是用过 Comparator 接口来传递比较规则的，Comparator 接口中只有一个 compare() 函数，实际上也就是传递了一个函数指针。

#### 函数指针的定义

前面我们已经了解过了使用函数指针的优点，下面我们就开始学习函数指针的知识吧。

回顾下我们之前学习的指针。假设有一个指向 int 类型变量的指针，该指针储存着这个 int 类型变量储存在内存位置的地址。同样，函数也有地址，因为函数的机器语言实现由载入内存的代码组成。指向函数的指针中储存着函数代码的起始处的地址。 

声明一个数据指针时，必须声明指针所指向的数据类型。同样的，**声明一个函数指针时，必须声明指针指向的函数类型**，即函数的**返回类型和形参类型**。

例如，考虑下面的函数原型： 

```c
void ToUpper(char *); // 把字符串中的字符转换成大写字符 
```

ToUpper() 函数的类型是“带 char * 类型参数、返回类型是 void 的函数”。下面声明了一个指针 pf 指向该函数类型： 

```c
void (*pf)(char *); // pf 是一个指向函数的指针 
```

从该声明可以看出，第1对圆括号把 * 和 pf 括起来，表明 pf 是一个指向函数的指针。因此，(*pf) 是一个参数列表为 char *、返回类型为 void 的函数。 

**注意**：把函数名 ToUpper 替换为表达式 (\*pf) 是创建指向函数指针最简单的方式。所以，如果想声明一个指向某类型函数的指针，可以写出该函数的原型后把函数名替换成 (\*pf) 形式的表达式，创建函数指针声明。前面提到过，由于运算符优先级的规则，在声明函数指针时必须把 \* 和指针名括起来。如果省略第1个圆括号会导致完全不同的情况：

```c
void *pf(char *); // pf 是一个返回void指针的函数
```

#### 函数指针的赋值

声明了函数指针后，可以把类型匹配的函数地址赋给它：

1. 1. 直接用函数名为函数指针赋值；
   2. 用(&函数名)为函数指针赋值。

例如：

```c
void ToUpper(char *); // 函数
int round(double); // 函数

void (pf)(char*); // 函数指针
int main(void) {
    pf = ToUpper; // 正确
    pf = &ToUpper; // 正确
    pf = ToUpper(); // 错误，这是调用函数。
    pf = round; // 错误，round和指针类型不匹配。
}
```

#### 函数指针的调用

给函数指针赋值时有两种写法，同样，使用函数组指针也同样有两种对应的写法。

```c
void ToUpper(char *); // 函数
void (pf)(char*); // 函数指针
int main(void) {
    pf = ToUpper;
    char str[] = "hello";
    pf(str); // 正确
    (*pf)(str); // 正确
}
```

之所以有两种写法是由于历史的原因，贝尔实验室的 C 和 UNIX 的开发者采用第1种形式，而伯克利的 UNIX 推广者却采用第2种形式。K&R C 不允许第2种形式。但是，为了与现有代码兼容，ANSI C 认为这两种形式等价。后续的标准也延续了这种矛盾的和谐。

### [转载]指针详解

#### 前言：复杂类型说明

要了解指针，多多少少会出现一些比较复杂的类型，所以我先介绍一下如何完全理解一个复杂类型。
要理解复杂类型其实很简单，一个类型里会出现很多运算符，他们也像普通的表达式一样，有优先级，其优先级和运算优先级一样，所以我总结了一下其原则：**从变量名处起，根据运算符优先级结合，一步一步分析**。下面让我们先从简单的类型开始慢慢分析吧：

```c
int p;  	
// 这是一个普通的整型变量  

int *p; 	
// 首先从p处开始,先与*结合,说明p是一个指针；
// 然后再与int结合,说明指针所指向的内容的类型为int型.
// 所以p是一个返回整型数据的指针  
			
int p[3];   
// 首先从p处开始,先与[]结合,说明p是一个数组;
// 然后与int结合,说明数组里的元素是整型的.
// 所以p是一个由整型数据组成的数组 
			
int *p[3]; // 指针数组
// 首先从p处开始,先与[]结合,因为其优先级比*高,所以p是一个数组;
// 然后再与*结合,说明数组里的元素是指针类型;
// 然后再与int结合,说明指针所指向的内容的类型是整型的;
// 所以P 是一个由返回整型数据的指针所组成的数组  

int (*p)[3]; // 数组指针
// 首先从p处开始,先与*结合,说明p是一个指针;
// 然后再与[]结合,说明指针所指向的内容是一个数组;
// 然后再与int结合,说明数组里的元素是整型的;
// 所以p是一个指向由整型数据组成的数组的指针

int **p; 
// 首先从p开始,先与*结合,说是p是一个指针;
// 然后再与*结合,说明指针所指向的元素是指针;
// 然后再与int结合,说明该指针所指向的元素是整型数据.
// 由于二级指针以及更高级的指针极少用在复杂的类型中,
// 所以后面更复杂的类型我们就不考虑多级指针了,最多只考虑一级指针. 
 
int p(int); 
//从p处起,先与()结合,说明p是一个函数;
// 然后进入()里分析,说明该函数有一个整型变量的参数;
// 然后再与外面的int结合,说明函数的返回值是一个整型数据.

int (*p)(int); 
// 从p处开始,先与指针结合,说明p是一个指针;
// 然后与()结合,说明指针指向的是一个函数;
// 然后再与()里的int结合,说明函数有一个int型的参数;
// 再与最外层的int结合,说明函数的返回类型是整型;
// 所以p是一个指向有一个整型参数且返回类型为整型的函数的指针.
  
int *(*p(int))[3]; 
//可以先跳过,不看这个类型,过于复杂.
// 从p开始,先与()结合,说明p是一个函数;
// 然后进入()里面,与int结合,说明函数有一个整型变量参数;
// 然后再与外面的*结合,说明函数返回的是一个指针;
// 然后到最外面一层,先与[]结合,说明返回的指针指向的是一个数组;
// 然后再与*结合,说明数组里的元素是指针;
// 然后再与int结合,说明指针指向的内容是整型数据.
// 所以p是一个参数为一个整数且返回一个指向由 整型指针变量组成的数组 的指针变量的函数.
```

说到这里也就差不多了，我们的任务也就这么多，理解了这几个类型，其它的类型对我们来说也是小菜了，不过我们一般不会用太复杂的类型，那样会大大减小程序的可读性，请慎用！这上面的几种类型已经足够我们用了。

#### 一、细说指针

**从根本上看，指针是一个值为内存地址的变量**。指针是一个特殊的变量，它里面存储的数值被解释成为内存里的一个地址。要搞清一个指针需要搞清指针的四方面的内容：**指针的类型**、**指针所指向的类型**、**指针的值**(或者叫指针所指向的内存区)、**指针本身所占据的内存区**。

让我们分别说明，先声明几个指针放着做例子：

```c
 // 例一：
(1) int* ptr;
(2) char* ptr; 
(3) int** ptr;  
(4) int (*ptr)[3];  
(5) int* (*ptr)[4];
```

**1.指针的类型：**
从语法的角度看，你只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。这是指针本身所具有的类型。让我们看看例一中各个指针的类型：

- (1) int* ptr;   <font color = "green">// 指针的类型是 int*</font>
- (2) char* ptr;<font color = "green">// 指针的类型是 char*</font>
- (3) int** ptr;<font color = "green">// 指针的类型是 int**</font>
- (4) int (\*ptr)[3];<font color = "green">// 指针的类型是 int(\*)[3]</font>
- (5) int* (\*ptr)[4];<font color = "green">// 指针的类型是 int\*(\*)[4]</font>

怎么样？找出指针的类型的方法是不是很简单？

**2.指针所指向的类型：**
当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。从语法上看，你只须把指针声明语句中的指针名字和名字左边的指针声明符*去掉，剩下的就是指针所指向的类型。例如：

- (1)int*ptr; <font color = "green"> // 指针所指向的类型是 int </font>
- (2)char*ptr;<font color = "green"> // 指针所指向的的类型是 char </font>
- (3)int\*\*ptr;<font color = "green"> // 指针所指向的的类型是 int* </font>
- (4)int(*ptr)[3];<font color = "green"> // 指针所指向的的类型是 int()[3] </font>
- (5)int*(\*ptr)[4];<font color = "green"> // 指针所指向的的类型是 int\*()[4] </font>

在指针的算术运算中，指针所指向的类型有很大的作用。指针的类型(即指针本身的类型)和指针所指向的类型是两个概念。当你对 C 越来越熟悉时，你会发现，把与指针搅和在一起的"类型"这个概念分成"指针的类型"和"指针所指向的类型"两个概念，是精通指针的关键点之一。我看了不少书，发现有些写得差的书中，就把指针的这两个概念搅在一起了，所以看起书来前后矛盾，越看越糊涂。

**3.指针的值----或者叫指针所指向的内存区或地址：**
**指针的值是指针本身存储的数值**，这个值将被编译器当作一个地址，而不是一个一般的数值。在 32 位程序里，所有类型的指针的值都是一个 32 位整数，因为 32 位程序里内存地址全都是 32 位长。

指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为 `sizeof(指针所指向的类型)` 的一片内存区。以后，我们说一个指针的值是XX，就相当于说该指针指向了以 XX 为首地址的一片内存区域；我们说一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。指针所指向的内存区和指针所指向的类型是两个完全不同的概念。在例一中，指针所指向的类型已经有了，但由于指针还未初始化，所以它所指向的内存区是不存在的，或者说是无意义的。

以后，每遇到一个指针，都应该问问：这个指针的类型是什么？指针指的类型是什么？该指针指向了哪里？（重点注意）

**4.指针本身所占据的内存区：**
指针本身占了多大的内存？你只要用函数 `sizeof(指针的类型)` 测一下就知道了。在 32 位平台里，指针本身占据了 4 个字节的长度。指针本身占据的内存这个概念在判断一个指针表达式（后面会解释）是否是左值时很有用。

#### 二、指针的算术运算

指针可以加上或减去一个整数。指针的这种运算的意义和通常的数值的加减运算的意义是不一样的，以单元为单位。例如：

```c
// 例二：
char a[20]; 
int *ptr=(int *)a; //强制类型转换并不会改变a 的类型  
ptr++;
```

在上例中，指针 ptr 的类型是 int*，它指向的类型是 int，它被初始化为指向整型变量 a。接下来的第3句中，指针ptr被加了1，编译器是这样处理的：它把指针 ptr 的值加上了 `sizeof(int)`。
在 32 位程序中，是被加上了 4，因为在 32 位程序中，int 占 4 个字节。由于地址是用字节做单位的，故 ptr 所指向的地址由原来的变量 a 的地址向高地址方向增加了 4 个字节。由于 char 类型的长度是一个字节，所以，原来 ptr 是指向数组 a 的第 0 号单元开始的四个字节，此时指向了数组 a 中从第 4 号单元开始的四个字节。我们可以用一个指针和一个循环来遍历一个数组，看例子：

```c
// 例三：
int array[20]={0};  
int *ptr=array;  
for(i=0;i<20;i++) 
{  
	(*ptr)++;  
	ptr++;
}
```

这个例子将整型数组中各个单元的值加 1。由于每次循环都将指针 ptr加 1 个单元，所以每次循环都能访问数组的下一个单元。再看例子：

```c
// 例四：
char a[20]="You_are_a_girl"; 
int *ptr=(int *) a;  
ptr+=5;
```

在这个例子中，ptr 被加上了5，编译器是这样处理的：将指针 ptr 的值加上 5 乘 `sizeof(int)`，在 32 位程序中就是加上了 5 乘 4 = 20。由于地址的单位是字节，故现在的 ptr 所指向的地址比起加 5 后的ptr 所指向的地址来说，向高地址方向移动了 20 个字节。
在这个例子中，没加 5 前的 ptr 指向数组 a 的第 0 号单元开始的四个字节，加 5 后，ptr 已经指向了数组 a 的合法范围之外了。虽然这种情况在应用上会出问题，但在语法上却是可以的。这也体现出了指针的灵活性。如果上例中，ptr 是被减去5，那么处理过程大同小异，只不过 ptr 的值是被减去 5 乘 `sizeof(int)`，新的 ptr 指向的地址将比原来的 ptr 所指向的地址向低地址方向移动了 20 个字节。



下面请允许我再举一个例子:(一个误区)

```c
// 例五:
#include<stdio.h>  
int main()  
{  
	char a[20] = " You_are_a_girl";  
	char *p = a;  
	char **ptr = &p;  
	//printf("p=%d\n",p);  
	//printf("ptr=%d\n",ptr);  
	//printf("*ptr=%d\n",*ptr);  
	printf("**ptr=%c\n",**ptr);  
	ptr++;  
	//printf("ptr=%d\n",ptr);  
	//printf("*ptr=%d\n",*ptr);  
	printf("**ptr=%c\n",**ptr);  
}
```

误区一：输出答案为Y 和o。
误解：ptr 是一个 char 的二级指针，当执行 ptr++;时，会使指针加一个 `sizeof(char)`，所以输出如上结果，这个可能只是少部分人的结果。

误区二：输出答案为Y 和a。
误解：ptr 指向的是一个 char * 类型,当执行 ptr++;时,会使指针加一个 `sizeof(char *)`(有可能会有人认为这个值为 1，那就会得到误区一的答案，这个值应该是4，参考前面内容)，即 &p+4；那进行一次取值运算不就指向数组中的第五个元素了吗?那输出的结果不就是数组中第五个元素了吗?答案是否定的。

正解：ptr 的类型是 char **，指向的类型是一个 char *类型，该指向的地址就是 p的地址(&p)，当执行 ptr++ 时，会使指针加一个 `sizeof(char*)`，即 &p+4 那 *(&p+4) 指向哪呢，这个你去问上帝吧,或者他会告诉你在哪?所以最后的输出会是一个随机的值，或许是一个非法操作。

**总结一下:**
一个指针 ptrold 加(减)一个整数 n 后，结果是一个新的指针 ptrnew，ptrnew 的类型和 ptrold 的类型相同，ptrnew 所指向的类型和 ptrold 所指向的类型也相同。ptrnew 的值将比 ptrold 的值增加(减少)了 n 乘 `sizeof(ptrold 所指向的类型)` 个字节。就是说，ptrnew 所指向的内存区将比 ptrold 所指向的内存区向高(低)地址方向移动了 n 乘 `sizeof(ptrold 所指向的类型)` 个字节。指针和指针进行加减：两个指针不能进行加法运算，这是非法操作，因为进行加法后，得到的结果指向一个不知所向的地方，而且毫无意义。两个指针可以进行减法操作，但必须类型相同，一般用在数组方面，不多说了。

#### 三、运算符&和*

这里&是取地址运算符，*是间接运算符。&a 的运算结果是一个指针，指针的类型是 a 的类型加个 *，指针所指向的类型是 a 的类型，指针所指向的地址嘛，那就是 a 的地址。
*p 的运算结果就五花八门了。总之 *p 的结果是 p 所指向的东西，这个东西有这些特点：它的类型是 p 指向的类型，它所占用的地址是 p 所指向的地址。

```c
例六：
int a=12; int b; int *p; int **ptr; 
p=&a; // &a的结果是一个指针，类型是int*，指向的类型是int，指向的地址是a的地址。  
*p=24; // *p的结果，在这里它的类型是int，它所占用的地址是p所指向的地址，显然，
// *p就是变量a。  
ptr=&p; // &p的结果是个指针，该指针的类型是p的类型加个*，在这里是int **。该指针所
// 指向的类型是p的类型，这 里是int*。该指针所指向的地址就是指针p自己的地址。  
*ptr=&b; // *ptr是个指针，&b的结果也是个指针，且这两个指针的类型和所指向的类型
// 是一样的，所以用&b来给*ptr赋值就是毫无问题的了。  
**ptr=34; // *ptr的结果是ptr所指向的东西，在这里是一个指针，对这个指针再做一次*
          // 运算，结果是一个int 类型的变量。
```

#### 四、指针表达式

一个表达式的结果如果是一个指针，那么这个表达式就叫指针表式。
下面是一些指针表达式的例子：

```c
// 例七：
int a,b;  
int array[10];  
int *pa;  
pa=&a; //&a 是一个指针表达式。  
Int **ptr=&pa; //&pa 也是一个指针表达式。  
*ptr=&b; //*ptr 和&b 都是指针表达式。  
pa=array;  
pa++; //这也是指针表达式。
// 例八:
char *arr[20];  
char **parr=arr; //如果把arr 看作指针的话，arr 也是指针表达式  
char *str;  
str=*parr; //*parr 是指针表达式  
str=*(parr+1); //*(parr+1)是指针表达式  
str=*(parr+2); //*(parr+2)是指针表达式
```

由于指针表达式的结果是一个指针，所以指针表达式也具有指针所具有的四个要素：指针的类型，指针所指向的类型，指针指向的内存区，指针自身占据的内存。
好了，当一个指针表达式的结果指针已经明确地具有了指针自身占据的内存的话，这个指针表达式就是一个左值，否则就不是一个左值。在例七中，&a 不是一个左值，因为它还没有占据明确的内存。*ptr 是一个左值，因为 *ptr 这个指针已经占据了内存，其实 *ptr 就是指针 pa，既然 pa 已经在内存中有了自己的位置，那么 *ptr 当然也有了自己的位置。

#### 五、数组和指针的关系

数组的数组名其实可以看作一个指针。看下例：

```c
// 例九：
int array[10]={0,1,2,3,4,5,6,7,8,9},value;  
value=array[0]; //也可写成：value=*array;  
value=array[3]; //也可写成：value=*(array+3);  
value=array[4]; //也可写成：value=*(array+4);
```

上例中，一般而言数组名 array 代表数组本身，类型是 int[10]，但如果把 array 看做指针的话，它指向数组的第 0 个单元，类型是 int* 所指向的类型是数组单元的类型即 int。因此 *array 等于0 就一点也不奇怪了。同理，array+3 是一个指向数组第  3 个单元的指针，所以 *(array+3) 等于3。其它依此类推。

```c
// 例十：
char *str[3]={  
    "Hello,thisisasample!",  
    "Hi,goodmorning.",  
    "Helloworld"  
};  
char s[80]；  
strcpy(s,str[0]); //也可写成strcpy(s,*str);  
strcpy(s,str[1]); //也可写成strcpy(s,*(str+1));  
strcpy(s,str[2]); //也可写成strcpy(s,*(str+2));
```

上例中，str 是一个三单元的数组，该数组的每个单元都是一个指针，这些指针各指向一个字符串。把指针数组名 str 当作一个指针的话，它指向数组的第 0 号单元，它的类型是 char **，它指向的类型是 char *。



*str 也是一个指针，它的类型是 char *，它所指向的类型是 char，它指向的地址是字符串 "Hello,thisisasample!" 的第一个字符的地址，即 'H' 的地址。


注意：字符串相当于是一个数组，在内存中以数组的形式储存，只不过字符串是一个数组常量，内容不可改变，且只能是右值。如果看成指针的话，他即是常量指针，也是指针常量。


str +1 也是一个指针，它指向数组的第 1 号单元，它的类型是 char**，它指向的类型是 char*。*(str+1)也是一个指针，它的类型是 char*，它所指向的类型是 char，它指向 "Hi,goodmorning." 的第一个字符 'H'。



下面总结一下数组的数组名(数组中储存的也是数组)的问题，声明了一个数组 TYPE array[n]，则数组名称 array 就有了两重含义：

1. 它代表整个数组，它的类型是TYPE[n]；
2. 它是一个常量指针，该指针的类型是TYPE*，该指针指向的类型是 TYPE，也就是数组单元的类型，该指针指向的内存区就是数组第 0 号单元，该指针自己占有单独的内存区，注意它和数组第 0 号单元占据的内存区是不同的。该指针的值是不能修改的，即类似 array++ 的表达式是错误的。在不同的表达式中数组名 array 可以扮演不同的角色。在表达式 sizeof(array) 中，数组名 array 代表数组本身，故这时sizeof 函数测出的是整个数组的大小。在表达式 \*array 中，array 扮演的是指针，因此这个表达式的结果就是数组第 0 号单元的值。sizeof(\*array) 测出的是数组单元的大小。表达式 array+n（其中n=0，1，2，.....）中，array 扮演的是指针，故 array+n 的结果是一个指针，它的类型是 TYPE *，它指向的类型是 TYPE，它指向数组第 n 号单元。故 sizeof(array+n) 测出的是指针类型的大小。在 32 位程序中结果是 4。

```c
// 例十一:
int array[10];  
int (*ptr)[10];  
ptr=&array;：
```

上例中 ptr 是一个指针，它的类型是 int(*)[10]，他指向的类型是 int[10] ，我们用整个数组的首地址来初始化它。在语句 ptr=&array 中，array 代表数组本身。



本节中提到了函数 sizeof()，那么我来问一问，sizeof(指针名称)测出的究竟是指针自身类型的大小呢还是指针所指向的类型的大小？
答案是前者。例如：`int(*ptr)[10];` 则在32 位程序中，有：

```c
sizeof(int(*)[10])==4
sizeof(int[10])==40
sizeof(ptr)==4
```

实际上，sizeof(对象)测出的都是对象自身的类型的大小，而不是别的什么类型的大小。

#### 六、指针和结构体的关系

可以声明一个指向结构类型对象的指针。

```c
//例十二：
struct MyStruct  
{  
    int a;  
    int b;  
    int c;  
};  
struct MyStruct ss={20,30,40};  
//声明了结构对象ss，并把ss 的成员初始化为20，30 和40。  
struct MyStruct *ptr=&ss;  
//声明了一个指向结构对象ss 的指针。它的类型是  
//MyStruct *,它指向的类型是MyStruct。  
int *pstr=(int*)&ss;  
//声明了一个指向结构对象ss 的指针。但是pstr 和  
//它被指向的类型ptr 是不同的。
```

Q：请问怎样通过指针 ptr 来访问 ss 的三个成员变量？
A：

```c
ptr->a; //指向运算符，或者可以这们(*ptr).a,建议使用前者
ptr->b;
ptr->c;
```



Q：又请问怎样通过指针pstr 来访问ss 的三个成员变量？
A：

```c
*pstr； //访问了ss 的成员a。
*(pstr+1); //访问了ss 的成员b。
*(pstr+2) //访问了ss 的成员c。
```

虽然我在我的 MSVC++6.0 上调式过上述代码，但是要知道，这样使用pstr 来访问结构成员是不正规的，为了说明为什么不正规，让我们看看怎样通过指针来访问数组的各个单元: (将结构体换成数组)

```c
// 例十三：
int array[3]={35,56,37};  
int *pa=array;  
//通过指针pa 访问数组array 的三个单元的方法是：  
*pa; //访问了第0 号单元  
*(pa+1); //访问了第1 号单元  
*(pa+2); //访问了第2 号单元
```



从格式上看倒是与通过指针访问结构成员的不正规方法的格式一样。
所有的C/C++编译器在排列数组的单元时，总是把各个数组单元存放在连续的存储区里，单元和单元之间没有空隙。但在存放结构对象的各个成员时，在某种编译环境下，可能会需要字对齐或双字对齐或者是别的什么对齐，需要在相邻两个成员之间加若干个"填充字节"，这就导致各个成员之间可能会有若干个字节的空隙。
所以，在例十二中，即使*pstr 访问到了结构对象ss 的第一个成员变量a，也不能保证*(pstr+1)就一定能访问到结构成员b。因为成员a 和成员b 之间可能会有若干填充字节，说不定*(pstr+1)就正好访问到了这些填充字节呢。这也证明了指针的灵活性。要是你的目的就是想看看各个结构成员之间到底有没有填充字节，嘿，这倒是个不错的方法。
不过指针访问结构成员的正确方法应该是像例十二中使用指针ptr 的方法。

#### 七、指针和函数的关系

**1.可以把一个指针声明成为一个指向函数的指针。**

```c
int fun1(char *,int);
int (*pfun1)(char *,int);
pfun1=fun1;
int a=(*pfun1)("abcdefg",7); //通过函数指针调用函数。
```

**2.可以把指针作为函数的形参。** 在函数调用语句中，可以用指针表达式来作为实参。

```c
// 例十四：
int fun(char *);  
inta;  
char str[]="abcdefghijklmn";  
a=fun(str);  
int fun(char *s)  
{  
    int num=0;  
    for(int i=0;;)  
    {  
        num+=*s;s++;  
    }  
    return num;  
}
```

这个例子中的函数 fun 统计一个字符串中各个字符的 ASCII 码值之和。前面说了，数组的名字也是一个指针。在函数调用中，当把 str 作为实参传递给形参 s 后，实际是把 str 的值传递给了 s，s 所指向的地址就和 str 所指向的地址一致，但是 str 和 s 各自占用各自的存储空间。在函数体内对 s 进行自加 1 运算，并不意味着同时对 str 进行了自加1 运算。

#### 八、指针类型转换

当我们初始化一个指针或给一个指针赋值时，赋值号的左边是一个指针，赋值号的右边是一个指针表达式。在我们前面所举的例子中，绝大多数情况下，指针的类型和指针表达式的类型是一样的，指针所指向的类型和指针表达式所指向的类型是一样的。

```c
// 例十五：
float f=12.3;  
float *fptr=&f;  
int *p;
```

在上面的例子中，假如我们想让指针 p 指向实数 f，应该怎么办？是用`p=&f;`语句吗？
不对。因为指针p 的类型是 int *，它指向的类型是 int。表达式 &f 的结果是一个指针，指针的类型是 float *,它指向的类型是 float。
两者不一致，直接赋值的方法是不行的。至少在我的 MSVC++6.0 上，对指针的赋值语句要求赋值号两边的类型一致，所指向的类型也一致，其它的编译器上我没试过，大家可以试试。为了实现我们的目的，需要进行"强制类型转换"：`p=(int*)&f;`

如果有一个指针 p，我们需要把它的类型和所指向的类型改为 TYEP *TYPE， 那么语法格式是： `(TYPE *)p；`
这样强制类型转换的结果是一个新指针，该新指针的类型是 TYPE *，它指向的类型是 TYPE，它指向的地址就是原指针指向的地址。
而**原来的指针 p 的一切属性都没有被修改**。（切记）

一个函数如果使用了指针作为形参，那么在函数调用语句的实参和形参的结合过程中，必须保证类型一致，否则需要强制转换

```c
// 例十六：
void fun(char*);  
int a=125,b;  
fun((char*)&a);  
void fun(char*s)  
{  
    charc;  
    c=*(s+3);*(s+3)=*(s+0);*(s+0)=c;  
    c=*(s+2);*(s+2)=*(s+1);*(s+1)=c;  
}
```

注意这是一个 32 位程序，故 int 类型占了四个字节，char 类型占一个字节。函数 fun 的作用是把一个整数的四个字节的顺序来个颠倒。注意到了吗？在函数调用语句中，实参 &a 的结果是一个指针，它的类型是 int *，它指向的类型是 int。形参这个指针的类型是 char *，它指向的类型是 char。这样，在实参和形参的结合过程中，我们必须进行一次从 int *类型到 char * 类型的转换。
结合这个例子，我们可以这样来想象编译器进行转换的过程：编译器先构造一个临时指针 char *temp，然后执行 temp=(char *)&a，最后再把 temp 的值传递给 s。所以最后的结果是：s 的类型是 char *，它指向的类型是 char，它指向的地址就是 a 的首地址。
我们已经知道，指针的值就是指针指向的地址，在 32 位程序中，指针的值其实是一个 32 位整数。那可不可以把一个整数当作指针的值直接赋给指针呢？就象下面的语句：

```c
unsigned int a;  
TYPE *ptr; //TYPE 是int，char 或结构类型等等类型。  
a=20345686;  
ptr=20345686; //我们的目的是要使指针ptr 指向地址20345686  
ptr=a; //我们的目的是要使指针ptr 指向地址20345686  
//编译一下吧。结果发现后面两条语句全是错的。
```

那么我们的目的就不能达到了吗？不，还有办法：

```c
unsigned int a;  
TYPE *ptr; //TYPE 是int，char 或结构类型等等类型。  
a=N //N 必须代表一个合法的地址；  
ptr=(TYPE*)a； //呵呵，这就可以了。
```

严格说来这里的(TYPE *)和指针类型转换中的(TYPE *)还不一样。这里的(TYPE *)的意思是把无符号整数 a 的值当作一个地址来看待。上面强调了 a 的值必须代表一个合法的地址，否则的话，在你使用 ptr 的时候，就会出现非法操作错误。想想能不能反过来，把指针指向的地址即指针的值当作一个整数取出来。完全可以。下面的例子演示了把一个指针的值当作一个整数取出来，然后再把这个整数当作一个地址赋给一个指针：

```c
\\ 例十七： 
int a=123,b;  
int *ptr=&a;  
char *str;  
b=(int)ptr; //把指针ptr 的值当作一个整数取出来。  
str=(char*)b; //把这个整数的值当作一个地址赋给指针str。
```

现在我们已经知道了，可以把指针的值当作一个整数取出来，也可以把一个整数值当作地址赋给一个指针。

#### 九、指针的安全问题

看下面的例子：

```c
// 例十八：
char s='a';  
int *ptr;  
ptr=(int *)&s;  
*ptr=1298；
```

指针 ptr 是一个 int *类型的指针，它指向的类型是 int。它指向的地址就是 s 的首地址。在 32 位程序中，s 占一个字节，int 类型占四个字节。最后一条语句不但改变了 s 所占的一个字节，还把和 s 相临的高地址方向的三个字节也改变了。这三个字节是干什么的？只有编译程序知道，而写程序的人是不太可能知道的。也许这三个字节里存储了非常重要的数据，也许这三个字节里正好是程序的一条代码，而由于你对指针的马虎应用，这三个字节的值被改变了！这会造成崩溃性的错误。
让我们再来看一例：

```c
// 例十九：
char a;  
int *ptr=&a;  
ptr++;  
*ptr=115;
```

该例子完全可以通过编译，并能执行。但是看到没有？第 3 句对指针 ptr 进行自加 1 运算后，ptr 指向了和整形变量 a 相邻的高地址方向的一块存储区。这块存储区里是什么？我们不知道。有可能它是一个非常重要的数据，甚至可能是一条代码。
而第 4 句竟然往这片存储区里写入一个数据！这是严重的错误。所以在使用指针时，程序员心里必须非常清楚：**我的指针究竟指向了哪里**。在用指针访问数组的时候，也要注意不要超出数组的低端和高端界限，否则也会造成类似的错误。
在指针的强制类型转换：ptr1=(TYPE *)ptr2 中，如果 **sizeof(ptr2的类型)**大于**sizeof(ptr1 的类型)**，那么在使用指针 ptr1 来访问 ptr2 所指向的存储区时是安全的。如果**sizeof(ptr2 的类型)** 小于**sizeof(ptr1 的类型)**，那么在使用指针 ptr1 来访问 ptr2 所指向的存储区时是不安全的。至于为什么，读者结合例十八来想一想，应该会明白的。

## 字符串

### 字符串简介

在 Unit 2 中简单介绍了字符串和字符数组的概念，这里先复习一下之前讲解的字符串的知识，然后再详细学习一下字符串。

#### 什么是字符串？

**定义：** **字符串是**以空字符(\0)结尾的**字符(char)数组**。

> 字符串是一种特殊的字符数组，特殊在字符串是以空字符 '\0' 结尾上，这样只需要给出字符串的起始地址，编译器就可以知道字符串的范围是从起始地址到空字符，不需要我们再指出数组长度，或者结束地址了。

因为字符串是一种字符数组，因此数组和指针的知识都可以运用到字符串上。但是字符串实在是太常用了，因此 C 提供了很多用于处理字符串的函数，这些函数基本都是需要掌握的，因为这些函数都是可以大大提高我们处理字符串的效率。

#### 字符串的声明

在 C 语言中，可以使用多种方法声明字符串，但是无论哪种方法，都需要**确保程序有足够的空间储存字符串**！

**定义：** 双引号括起来的内容成为字符串常量(String Constant)，也叫做字符串字面量(String Literal)。例如，`"I am a string constant."` 就表示一个字符串。
其实之前我们就已经接触了字符串常量了，只是我们当时并没有学到字符串的知识，printf() 和 scanf() 函数中的 `""` 括起来的内容就是字符串。

> 之前说过，字符串以空字符(\0)结尾，但是在字符串常量的双引号中并没有空字符，这是因为编译器会对双引号中的字符自动的在末尾加上空字符(\0)，不需要我们显式的在字符串末尾加上空字符。
> 也就是说，上面的 "I am a string constant."，在存储的时候被保存为 "I am a string constant.\0"。

**注意1**：从 ANSI C 标准起，如果字符串常量之间没有间隔，或者用空白字符分隔，C 会将其视为串联起来的字符串常量。例如下面的两种写法是等价的：

```cpp
char greeting1[50] = "Hello, and"" how are" " you" " today!";
char greeting2[50] = "Hello, and how are you today!";
```

> 虽然是等价的，但是为了程序的可读性，推荐使用的还是第二种。



**注意2**： 因为字符串是由双引号包裹起来的，如果想要在字符串内部使用双引号，必须用反斜杠 \ 进行转义。例如，希望输出的字符串是 "Hello, World!"

```c
printf("Hello, World!"); // 输出的只是 Hello, World! 
printf("\"Hello, World!\""); // 输出的才是 "Hello, World!"
printf("Hel\"lo, Wor\"ld!"); // 输出的是 Hel"lo, Wor"ld!
```



**注意3**：字符串常量属于静态存储类别（static storage class），这说明如果在函数中使用字符串常量，该字符串只会被储存一次，在整个程序的生命期内存在，即使函数被调用多次。用双引号括起来的内容被视为指向该字符串储存 位置的指针。这类似于把数组名作为指向该数组位置的指针。

```c
printf("%s, %p, %c\n", "We", "are", *"space farers");
// 输出："We",0x100000f61,s
```

#### 字符串数组与初始化

**定义字符串数组时，必须让编译器知道需要多少空间。**一种方法是，用足够空间的数组储存字符串。另一种方法是，在声明字符串时初始化，由编译器自动计算数组大小。



**方法1. 用足够空间存储字符串：**

**演示1**：用足够空间存储字符串。

```c
// 1. 数组初始化(最后必须加上'\0'，否则只是字符数组，不是字符串)
const char m1[40] = { 'L','i', 'm', 'i', 't', ' ', 'y', 'o', 'u', 'r', 
's', 'e', 'l', 'f', ' ', 't', 'o', ' ', 'o', 'n', 'e', ' ','l', 'i', 
'n', 'e', '\'', 's', ' ', 'w', 'o', 'r','t', 'h', '.', '\0' };
// 2. 字符串常量初始化
const char m2[40] = "Limit yourself to one line's worth.";
```

**注意：**

1. 如果使用之前学习的字符数组初始化的方法，最后一定要加上空字符 `'\0'`，否则只是字符数组，而不是字符串。
2. 如果使用的是字符串常量来初始化的话，不需要在最后加空字符 `'\0'`，因为编译器在处理字符串常量时，在存储时会自动在最后加上空字符，不需要我们手动加。
3. 由之前数组知识可以知道 **数组的大小 >= 字符数量**，因为字符串是空字符结尾的字符数组，因此对于有 35 个字符(包括空格)的`Limit yourself to one line's worth.`来说，存储它的字符数组大小至少是 36(因为还有一个空字符)。
4. 如果**字符数组的大小大于字符串长度+1**(字符串字符+空字符)，剩余的位置上都会被自动初始化为空字符 \0

![](E:\Note\Code Language\the-c\picture\basic\5-11.png)



**方法2. 编译器自动计算数组的大小：**

回忆一下在学习数组时，可以省略数组初始化声明中的大小，编译器会自动计算数组大小。

```cpp
int[] arr = {1, 3, 5, 7};// 编译器会自动计算数组大小为 4
```

**演示2**：编译器自动计算数组大小。

```cpp
// 这个是字符数组，而不是字符串
const char ch1[] = {'y', 'o', 'u', ' ', 'k', 'a'};// 编译器自动计算大小为 6
// 这个是字符数组，也是字符串
const char str[] = {'y', 'o', 'u', ' ', 'k', 'a', '\0'};// 编译器自动计算大小为 7
// 这个是字符数组，也是字符串
const char str[] = "you ka";// 编译器自动计算大小为 7
```

**注意：**

1. 让编译器计算数组的大小只能用在初始化数组时。如果创建一个稍后再填充的数组，就必须在声明时指定大小。
2. 声明数组时，数组大小必须是可求值的整数。在 C99 新增变长数组之前，数组的大小必须是整型常量。
3. 字符数组名和其他数组名一样，是该数组首元素的地址。

#### 指针表示法创建字符串

还可以使用指针表示法创建字符串。例如，下面两条声明语句几乎相同：

```cpp
const char* p1 = "you ka";
const char arr1[] = "you ka";
```

注意：指针表示法和数组表示法来创建字符串只是几乎相同，还是有一定的区别的。
字符串 "you ka" 会保存在内存中，如果使用指针表示法，比如上面的 p1，那么 p1 指向的就是字符串 "you ka" 的起始地址。
这意味着，如果有 `const char* p2 = "you ka";` 则 `*p1 == *p2`，此时内存中只有一份 "you ka" 字符串。
如果使用的是数组表示法，则会在内存中以 arr1 为首地址保存 "you ka" 的一个副本，此时内存中有两份 "you ka" 字符串。



**如何选择指针表示法和数组表示法？**如果要用数组表示一系列待显示的字符串，使用指针数组，因为它比二维字符数组的效率高。如果要改变字符串或为字符串输入预留空间，不要使用指向字符串字面量的指针。

#### 字符串的输入

如果想要将一个字符串读入到程序，首先**必须预留存储这个字符串的空间**，然后用输入函数获取字符串。

| 函数    | 描述                                                     |
| ------- | -------------------------------------------------------- |
| scanf() | 配合 %s 占位符使用，读取到空白字符，即可以读取一个单词。 |
| gets()  | 读取到换行符，即可以读取一行。                           |
| fgets() | 同 gets()，主要是作为 gets() 的替代品。                  |

**函数1. scanf()：**

配合 %s 可以读取字符串，但是遇到空白符会停止读取，因此更像是一个“读取单词”的函数。例如：

```cpp
char str[100];
scanf("%s", str);
printf("%s\n", str);
```

输入：you ka
输出：you



**函数2. gets()：**

scanf() 只能读取一个单词，但是在读取字符串的时候，往往需要一整行读取输入，而不仅仅是一个单词。gets() 这个函数就是用于处理这种情况的。

**gets()** 简单易用，**读取整行输入，直到遇到换行符，然后丢弃换行符，存储其他字符，并在这些字符的末尾添加一个空字符，使其成为一个 C 字符串**。

```cpp
gets (char *__str)
```

但是，gets() 有一个缺陷，它的参数只有一个指针变量，**无法检查数组是否装得下输入行。** 因此，gets() 只知道数组的开始，并不知道数组有多少个元素。如果输入的字符串过长，会导致缓冲区溢出。

gets() 函数的不安全行为造成了 安全隐患。过去，有些人通过系统编程，利用 gets() 插入和运行一些破坏系统安全的代码。



**函数3. fgets()：**

因为 gets() 函数存在安全隐患，所以需要一个能够替代 gets() 的函数。过去通常用 fgets() 来代替 gets()，fgets() 函数稍微复杂些，在处理输入方面与 gets() 略有不同。

> C11标准新增的 gets_s() 函数也可代替 gets()。该函数与 gets() 函数更接近，而且可以替换现有代码中的 gets()。但是，它是 stdio.h 输入/输出函数系列中的可选扩展，所以支持C11的编译器也不一定支持它。

fgets() 函数通过第2个参数限制读入的字符数来解决溢出的问题。该函数专门设计**用于处理文件输入**，所以一般情况下可能不太好用。



fgets() 和 gets() 的区别：

1. fgets() 的第二个参数指明读入字符的最大数目。如果参数值为 n，那么 fgets() 将读入 n-1 个字符，或者遇到第一个换行符。
2. fgets() 读到第一个换行符，会储存在字符串中，而 gets() 会丢弃换行符。
3. fgets() 的第三个参数指明需要读入的文件，如果是从键盘输入的数据，则用 stdin 作为参数，该标识定义在 stdin.h 中。

> 因为  fgets() 函数把换行符放在字符串的末尾，通常要与 fputs() 函数配对使用，如果用 puts() 输出的话，会多打印一个换行。

fgets() 储存换行符有好处也有坏处。坏处是你可能并不想把换行符储存在字符串中，这样的换行符会带来一些麻烦。好处是对于储存的字符串而言，检查末尾是否有换行符可以判断是否读取了一整行。如果不是一整行，要妥善处理一行中剩下的字符。



**小结：**

| 函数                                         | 功能                                                         | 备注                                                         |
| -------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| int  scanf (const char, ...)                 | 配合占位符使用来读取键盘输入的数据。返回成功匹配和赋值的个数。 | 如果到达文件末尾或发生读错误，则返回 EOF。 遇到空白字符停止。 |
| char* gets(char* str)                        | 从标准输入 stdin 读取一行，并把它存储在 str 所指向的字符串中。如果成功，该函数返回 str；如果发生错误或者到达文件末尾时还未读取任何字符，则返回 NULL。 | 读取到换行符停止，**不会保存换行符**。 并不安全，没有考虑字符数组手否足够容纳字符串。 |
| char* fgets(char * str, int n, FILE* stream) | 从指定的流 stream 读取一行。如果读取成功，返回相同的 str 字符串；如果到达文件末尾或者没有读取到任何字符，str 的内容保持不变，并返回一个空指针。 | 读取到换行符，或者读取 n-1 字符时停止，**会保存换行符**。    |
| gets_s(char*, int)                           | gets() 的安全版，通过第二个参数控制读取的字符串长度。当字符串长度超过第二个参数，会丢弃。 | **不会保存换行符**。可选项，并不是每个编译器都会支持。       |

#### 字符串输出

| 函数     | 参数                         | 功能                             | 备注                                                |
| -------- | ---------------------------- | -------------------------------- | --------------------------------------------------- |
| printf() | 不定参数                     | 格式化输出不同的数据类型。       | 不会添加换行符，执行时机更长，但更灵活。            |
| puts()   | 一个参数，字符串地址         | 打印字符串。遇到空字符停止输出。 | 打印完字符串，会添加一个换行符。 需要保证有空字符。 |
| fputs()  | 两个参数，字符串地址、输出流 | 向指定输出流打印字符串。         | 打印完字符串，不会添加换行符。 需要保证有空字符。   |

> 还可以用 getchar()，putchar() 来自定义输入输出函数。

### 字符串函数

C库提供了多个处理字符串的函数，ANSI C 把这些函数的原型放在  string.h 头文件中。其中最常用的函数有 strlen()、strcat()、strcmp()、 strncmp()、strcpy() 和 strncpy()。另外，还有 sprintf() 函数，其原型在 stdio.h 头文件中。

#### strlen()

全称 string length，即 strlen() 函数用于统计字符串的长度。

> PS：最终统计的字符串长度不包括空字符。

**原型：** `size_t strlen(const char*);`
**用法：** 接受一个字符串参数，返回该字符串的长度。

#### strcat()

全称 string catenate(连接)，即 strcat() 函数用于字符串拼接。
**原型：** `char* strcat(char*, const char*);`
**用法：** 接受两个字符串作为参数，该函数把第 2 个字符串的备份附加在第 1 个字符串末尾，并把拼接后形成的新字符串作为 第 1 个字符串，第 2 个字符串不变。返回第 1 个参数，即拼接第 2 个字符串后的第 1 个字符串的地址。
**注意：** 1. 第二个参数的第一个字符替换第一个参数的空字符； 2. 第二个参数指向的字符串拼接到第一个参数指向的字符串之后，在最后添加一个空字符。

#### strncat()

学习过 gets() 之后，我们很容易会想到 strcat() 有同样的缺陷 —— 无法保证第一个数组能容纳第二个字符串。如果分配给第 1 个数组的空间不够大，多出来的字符溢出到相邻存储单元时就会出问题。

**解决方法：**

1. 使用 strlen() 来检测是否可以容纳。
2. 使用 strncat() 来拼接。

**原型：** `char* strncat(char*, const char*, size_t);`
**用法：** 该函数的第 3 个参数指定了最大添加字符数。例如 `strncat(bugs, addon, 13)` 将把 addon 字符串的内容附加给 bugs，在加到第 13 个字符或遇到空字符时停止。
**注意：** 第三个参数的设置为 `第一个数组的大小 - 1 - 第一个字符串大小`

> 第二个字符串的第1个字符将覆盖第一个字符串末尾的空字符。不会拷贝第二个字符串中空字符和其后的字符，并在拷贝字符的末尾添加一个空字符。
> **因此，拼接后一定是字符串(一定包含空字符)。**

#### strcmp

全称：string compare，用于比较字符串的内容。

**Q：为什么要用 strcmp() ?**
**A：** 因为对于字符串 str1 和字符串 str2 来说， `str1 == str2` 永远是比较的地址，而不是字符串的内容。需要比较字符串内容的时候就要使用 strcmp() 了。
**原型：** `int strcmp(const char*, const char*);`
**用法：** 该函数通过比较运算符来比较字符串，就像比较数字一样。如果两个字符串参数相同，该函数就返回 0，否则返回非零值。

> 关于返回值的问题，如果第一个参数的在第二参数的后面，返回整数；如果第一个参数和第二个参数下相同，返回0；如果第一个参数在第二个参数前面，返回负数。

#### strncmp

**原型：** `int strncmp(const char*, const char*, size_t);`
**用法：** 第三个参数指定两个字符串比较的字符数。

#### strcpy

**Q：为什么要有 strcpy() ?**
**A：** 和字符串比较相似，`str1 = str2` 是将字符串 str2 的首地址赋值给 str1，即 str1 和 str2 都指向了同一个字符串，此时内存中只有一个字符串，并没有复制字符串。
**原型：** `char* strcpy(char*, const char*);`
**用法：** 将第二个参数指向的字符串拷贝给第一个参数指向的数组中，返回值为第一个参数。

#### strncpy

strcpy() 也存在缺陷：第一个参数不一定可以容纳下第二个参数指向的字符串。
**原型：** `char* strncpy(char*, const char*, size_t);`
**用法：** 第 3 个参数指明可拷贝的最大字符数。
**注意：** `strncpy(target, source, n)` 是把 source 中的 n 个字符或空字符之前的字符拷贝至 target 中。因此，如果 source 中的字符数小于n，则拷贝整个字符串，包括空字符。但是，strncpy() 拷贝字符串的长度不会超过 n，如果拷贝到第 n 个字符时还未拷贝完整个源字符串，就不会拷贝空字符。所以，**拷贝的副本中不一定有空字符**。鉴于此，该程序把 n 设置为比目标数组大小少 1（TARGSIZE-1），然后把数组最后一个元素设置为空字符。

#### sprinf()

**注意：** 前面的函数都是在 string.h 这个头文件中，而 sprinf() 函数则是声明在 stdio.h 中。
**功能：** 该函数和 prinf() 类似，但是它将数据写入字符串，而不是打印在显示器上。

例如：

```c
// 将后面的字符串写入到 formal 中
sprintf(formal, "%s, %-5s: $%6.2f\n", last, first, prize);
```

### 字符函数

C 有一系列专门处理字符的函数，ctype.h 头文件包含了这些函数的原型。这些函数接受一个字符作为参数，如果该字符属于某特殊的类别，就返回一个非零值（真）；否则，返回0（假）。

![](E:\Note\Code Language\the-c\picture\basic\5-12.png)

![](E:\Note\Code Language\the-c\picture\basic\5-13.png)

## 结构体、联合、枚举

### 结构体

结构体，简称结构 struct。

#### 结构简介

**什么是结构**？**为什么要用结构**？
编写代码时，最重要的步骤之一是选择表示数据的方法。在许多情况下，基本的变量类型和数组还步够，为此 C 提供了结构变量来表示复杂的数据。例如，对于一本书，可能需要书名、作者、价格等属性。

使用结构需要掌握的三个技巧：

- 为结构建立一个格式或样式；
- 声明一个合适该样式的变量；
- 访问结构变量的各个部分。

#### 建立结构体声明

结构声明描述了一个结构的组织布局。

```c
struct book {
	char title[100];
	char author[80];
	float value;
};
```

如上所示的声明描述了一个由两个字符数组和一个 float 类型变量组成的结构。注意，**该声明仅仅只是描述了该结构由什么组成，并未创建实际的数据对象**。

接下来分析一下结构声明的细节。

`struct` 是声明结构的关键字，该关键字表明跟在其后面的是一个结构。
`book` 是一个可选的标记，该标记表示结构的名称(该例中是 book)。关于标记，会在定义结构变量处讲解。
`{ };` 花括号括起来的是结构成员列表，每个成员都是可以是任意一种 C 的数据类型，甚至可以是其他结构。注意，**右括号后面一定要有** `**;**` ！！

结构声明可以放在所有函数的外部，也可以放在一个函数定义的内部。如果把结构声明置于一个函数的内部，它的标记(如本例中的 book)，只能限于该函数的内部使用。如果把结构声明置于函数的外部，那么该声明之后的所有函数都可以使用它的标记(如本例中的 book)。

#### 定义结构变量

结构有两层含义，一层是上面讲过的结构布局，另一层则是这里要讲的定义结构变量。以上面声明的结构 book 为例，定义一个变量 library 的代码如下所示：

```c
struct book library;
```

这行代码表明，用 book 结构来为 library 变量分配空间，包括了一个还有 100 个元素的 char 数组，一个包含 80 个元素的 char 数组，和一个 float 类型的变量。

![](E:\Note\Code Language\the-c\picture\basic\5-14.png)

在结构变量 library 的声明中，`struct book` 的作用相当于 `int` 或者 `float` 。和基本类型变量的声明一样，可以定义多个结构变量，甚至是结构指针。

```c
struct book doyle, panshin, *ptbook;
```

从本质上看，book 结构声明创建了一个名为 struct book 的新类型。就计算机而言，`struct book library;` 是以下声明的简化：

```c
struct book {
	char title[100];
	char author[80];
	float value;
} library;
```

所以，建立结构声明的过程和定义结构变量的过程可以组合成一个步骤。组合后的结构声明和结构变量的定义可以不使用结构标记。

```c
struct {
	char title[100];
	char author[80];
	float value;
} library;
```

**关于可选的结构标记是否可以省略的问题。** 如果是只需要定义有限个变量，可以将结构声明和变量定义合并到一起，这样**结构模板只会被使用一次**，此时**可以省略结构标记**。然而，**如果打算多次使用结构模板，就必须使用带标记的形式**，或者使用 typedef (这里不做介绍)。

#### 初始化结构变量

和定义基本数据类型变量一样，声明结构变量的同时可以对其进行初始化。初始化结构变量使用花括号中括起来的**初始化列表**进行初始化，各初始化项用**逗号**分隔，也可以用结构体变量来初始化。

> PS：使用结构体变量来初始化的变量不能作为全局变量。

```c
struct book library = {
	"The Pious Pirate and the Devious Damsel",
	"Renee Vivotte",
	1.95
};
struct book l1 = library; // 不能作为全局变量。
```

#### 使用结构变量

对于结构变量来说，使用结构成员运算符 —— 点(.)访问结构中的成员。例如使用 `library.value` 访问 library 中的 value 部分。
对于指向结构变量的指针来说，使用 `->` 运算符访问结构中的成员，或者`(*指针变量).成员`。

```c
struct book *ptbook = &library;
ptbook->value;
(*ptbook).value;
```

#### 结构变量的赋值

同一个结构体的变量之间可以直接赋值。

```c
struct book b1 = {
    "C Primer",
    "Stephen Prata",
    68.3
};
struct book b2 = b1;
```

> 但如果结构体的成员涉及到动态内存分配的话会有一些问题(深拷贝与浅拷贝的问题)，这点稍后再讲。

#### 结构体大小

之前学过的基本数据类型，如 char、int、double，它们的大小都是固定的，在 64 位系统中，char 占 1 字节，int 占 4 字节，double 占 8 字节。而结构体的大小并不固定，因为结构体的成员类型和数目是程序员自定义的。和基本数据类型一样，我们可以用 sizeof 这个运算符来获取结构体占据的内存大小。

```c
struct Cookie
{
    int a;
    short b;
    short c;    
} cookie;
int main()
{
    printf("%d\n", sizeof cookie);
    return 0;
}
```

上面代码输出的结果是 8，正好是 1 个 int 类型，2 个 short 类型的大小之和。**那么结构体的大小是各成员大小之和吗**？我们把 Cookie 稍微变化一下。

```c
struct Cookie
{
    int a;
    short b;
    char c;    
} cookie;
```

将 Cookie 的第3个成员变为 char，运行程序发现输出的结果依旧是 8，而不是 4+3+1 = 7。由此可知结构体的大小并不是简单的各成员大小之和，在计算结构体大小的时候，需要满足以下规则(对齐规则)：

1. **结构体成员的地址需要根据对齐数进行字节对齐**。对齐数=编译器默认的对齐数与该成员类型的大小中的较小值。其中编辑器默认的对齐数由编辑器决定，Linux 环境下是 4，这个值也可以由程序员指定。
2. 结构体总大小为其最大成员大小的整数倍。



**使用编译器默认对齐数：**

> 注：以下程序是在默认对齐数为 4 的编译器下运行。如果是在像 VS 这种默认对齐数为 8 的编译器下运行结果会有所不同。

```c
struct Cookie1
{
    int a;
    short b;
    char c[10];    
} cookie1;
struct Cookie2
{
    short b;
    int a;
    char c[10];    
} cookie2;
```

首先看 Cookie1 的大小。Cookie1 的成员中 int 占4字节，short 占2字节，char 占1字节，因此最大成员是占4字节的 int(对于数组，考虑数组元素的大小而不是数组的大小)，因此**最后计算的 Cookie1 的大小一定是4的倍数**。对于第一个成员 a，占4字节。对于第二个成员 b，大小是2字节，小于编译器默认的4字节，因此 b 的对齐数为 2，而 b 前面的成员已经占据的内存大小为 4，是2字节的倍数，因此 b 不需要字节补齐，此时 Cookie1 的内存大小是 4+2=6 字节。对于第三个成员 c，对齐数是 1，前面成员以及占据的内存是 6，是对齐数1的倍数，因此不需要字节补齐。此时 Cookie1 的内存大小是 4+2+10=16，正好是其最大成员 a 大小的倍数，因此 Cookie1 的内存大小是 16。

再来看 Cookie2 的大小。Cookie2 的成员中依旧是 int 为最大成员，因此**最后计算的 Cookie2 的大小也一定是 4 的倍数**。对于第一个成员 b，占2字节。对于第二个成员 a，对齐数是 4，而 a 前面已占据的内存是 2，不是 4 的倍数，因此需要对前面的内存进行补齐，空出 2 字节空间，此时 Cookie2 的大小为 2(存储 b) + 2(空出) + 4(存储 a) = 8 字节。对于成员 c，不需要字节补齐。此时 Cookie2 的大小为 2+2+4+10 = 18，不是 4 的倍数，因此最后还需要空出 2 字节进行字节补齐，使得 Cookie2 的大小为 4 的倍数，故 Cookie2 的大小为 2+2(空出)+4+10+2(空出)=20。

```c
struct Cookie3
{
    int a;
    double b;    
    short c;
} cookie3;
```

Cookie3 最大成员为 double 类型，因此 Cookie 的大小一定是 8 的倍数。第一个成员 a，占 4 字节内存。第二个成员 b，对齐数为 min(编译器默认对齐数(4), double 大小(8))，即 b 的对齐数为 4，而 b 前面已占据的内存大小为 4，不需要补齐字节。第三个成员 c，对齐数为 2，之前的成员占据的内存为 4 + 8 = 12，是 2 的倍数，不需要补齐。此时 Cookie3 的大小为 4+8+2 = 14，不是 8 的倍数，需要补齐2字节使其成为 8 的倍数，故 Cookie3 的大小为 16 字节。



**程序员在程序中指定对齐数：**

可以通过 `#param pack(n)` 来指定 n 为编译器默认的对齐数。

PS：n 的值可以是 1、2、4、8。

```c
#pragma pack(4)
struct Cookie3
{
    int a;
    double c;    
    short b;
} cookie3;
// Cookie3 的大小为 16
#pragma pack(8)
struct Cookie4
{
    int a;
    double c;    
    short b;
} cookie4;
// Cookie4 的大小为 24
```



了解了结构体的对齐原则，可能并不知道C语言为什么要设计结构体的字节对齐？主要是出于两种考虑：

1. 为了 CPU 访问数据的高效率。如果变量的地址不对齐，那么 CPU 读取结构体就需要对结构体成员进行重复的访问，然后组合得到数据。而如果变量在自然对齐位置上，则只要一次就可以取出数据。
2. 在有的硬件平台中，计算机在内存读取数据时，只能在规定的地址处读数据，而不是内存中任意地址都是可以读取。因此字节对齐尤为重要。



了解结构体的大小是很有必要的，通过示例1，我们可以看到存储相同的成员的结构体，在结构体声明中成员的顺序不同，结构体的大小是不同的。因此，明白结构体大小的计算，我们可以在声明结构体的时候声明一个占内存最小的结构体，这样可以减少内存开销。

#### 浅拷贝

```c
// 浅拷贝演示
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct book {
    char *title;
    char *author;
    float value;
};

void show_book(const struct book* ptr_book) {
    printf("This book\'s name is %s, the author is %s, the value is %lf.\n",
           ptr_book->title, ptr_book->author, ptr_book->value);
    printf("The struct value\'s address is %p.\n", ptr_book);
    printf("The title\'s address is %p.\n", ptr_book->title);
    printf("The author\'s address is %p.\n", ptr_book->author);
    printf("-------------------------------------------------------------\n");
}

void free_book(struct book* ptr_b) {
    if (ptr_b == NULL)
        return;
    if(ptr_b->title != NULL) {
        free(ptr_b->title);
        ptr_b->title = NULL;
    }
    if (ptr_b->author != NULL) {
        free(ptr_b->author);
        ptr_b->title = NULL;
    }
}
int main(int argc, char** args) {
    // 初始化 b1 变量
    struct book b1 = {.value = 68.3};
    b1.title = (char*) malloc(9 * sizeof (char));
    strcpy(b1.title, "C Primer");
    b1.author = (char*) malloc(13 * sizeof (char));
    strcpy(b1.author, "Stephen Prata");
    // 展示 b1 的成员
    show_book(&b1);
    // 声明 b2, 并将 b1 赋值给 b2
    struct book b2 = b1;
    // 以下代码和直接赋值作用一样
//    memcpy(&b2, &b1, sizeof (struct book));
    // 展示 b2 的成员
    show_book(&b2);

    // 修改 b2 的 author 成员指向的内容
    strcpy(b2.author, "You Ka");
    // 展示 b2 的成员
    show_book(&b2);
    // 展示 b1 的成员
    show_book((&b1));

    // 释放 b1 动态分配的内存
    free_book(&b1);
    // 释放 b2 动态分配的内存 —— 如果取消注释，会造成程序崩溃
//    free_book(&b2); 
    return 0;
}
// 输出结果：
This book's name is C Primer, the author is Stephen Prata, the value is 68.3.
The struct value's address is 000000000061FE00.
The title's address is 0000000000A11420.
The author's address is 0000000000A11440.
-------------------------------------------------------------
This book's name is C Primer, the author is Stephen Prata, the value is 68.3.
The struct value's address is 000000000061FDE0.
The title's address is 0000000000A11420.
The author's address is 0000000000A11440.
-------------------------------------------------------------
This book's name is C Primer, the author is You Ka, the value is 68.3.
The struct value's address is 000000000061FDE0.
The title's address is 0000000000A11420.
The author's address is 0000000000A11440.
-------------------------------------------------------------
This book's name is C Primer, the author is You Ka, the value is 68.3.
The struct value's address is 000000000061FE00.
The title's address is 0000000000A11420.
The author's address is 0000000000A11440.
-------------------------------------------------------------
```

可以看到，b2 = b1 其实是将 b1 成员的值复制给 b2，b2 的 title 成员和 author 成员的值和 b1 一模一样，即只复制指针本身，而不复制指针指向的模板。因此结构体赋值，采用的类似于 memcpy() 这种形式。

在结构体成员中有指针，并且会用到动态内存分配的情况下，就会产生一些问题。例如，在本例的结构体中就会存在一下问题：

1. **同一地址多次使用 free 释放，导致程序崩溃**。结构体变量 b1 和 b2 的 title 和 author 指针都指向一个 malloc 分配的地址，malloc 分配的地址是需要 free 释放的。如果使用 free 释放 b1 的 title 和 author ，此时 b2 的 title 和 author 就会成为野指针，后续使用 b2 时就会出现一些不可预见的问题。例如，free b1 之后，再用 free 释放 b2 就会造成程序崩溃。
2. **修改某一个变量指针成员指向的内容，会导致其他变量指向的内容一起改变**。结构体变量 b1 和 b2 的 title 和 author 指针都指向同一个地址，修改任意一个变量指向的内容，另一个变量的内容也会被修改。
3. **malloc 申请的内存没有被 free 释放，造成内存泄漏**。如果在将 b1 赋值给 b2 之前，b2 的 title 和 author 指针已经指向一个 malloc 申请的内存，并且没有其他变量的成员指针指向该内存。如果直接将 b1 赋值给 b2 的话，会造成之前 b2 指向的内存没有被回收。

#### 深拷贝

解决办法：不直接使用赋值运算符对结构体进行赋值，编写代码使两个结构体中指针地址不同，但是指向的内容一致。

```c
// 深拷贝演示
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct book {
    char *title;
    char *author;
    float value;
};

void show_book(const struct book* ptr_book) {
    printf("This book\'s name is %s, the author is %s, the value is %lf.\n",
           ptr_book->title, ptr_book->author, ptr_book->value);
    printf("The struct value\'s address is %p.\n", ptr_book);
    printf("The title\'s address is %p.\n", ptr_book->title);
    printf("The author\'s address is %p.\n", ptr_book->author);
    printf("-------------------------------------------------------------\n");
}

void free_book(struct book* ptr_b) {
    if (ptr_b == NULL)
        return;
    if(ptr_b->title != NULL) {
        free(ptr_b->title);
        ptr_b->title = NULL;
    }
    if (ptr_b->author != NULL) {
        free(ptr_b->author);
        ptr_b->title = NULL;
    }
    printf("Free Memory Success!\n");
}

// 执行深拷贝的函数
void copy_book(struct book * dest, const struct book * src) {
    // 如果dest的指针成员正指向一个动态分配的内存，首先将其释放掉，防止内存泄漏
    if(dest != NULL)
        free_book(dest);

    // 动态分配能够存储src对应成员的内存
    dest->title = malloc(strlen(src->title) + 1);
    dest->author = malloc(strlen(src->author) + 1);

    // 赋值
    strcpy(dest->title, src->title);
    strcpy(dest->author, src->author);
    dest->value = src->value;
}

int main(int argc, char** args) {
    // 初始化 b1 变量
    struct book b1 = {.value = 68.3};
    b1.title = (char*) malloc(9 * sizeof (char));
    strcpy(b1.title, "C Primer");
    b1.author = (char*) malloc(13 * sizeof (char));
    strcpy(b1.author, "Stephen Prata");
    // 展示 b1 的成员
    show_book(&b1);
    
    // ------------------------------------------------
    // 声明 b2, 并将 b1 赋值给 b2
    struct book b2;
    // 调用深拷贝的函数
    copy_book(&b2, &b1);
    // ------------------------------------------------
    
    // 展示 b2 的成员
    show_book(&b2);

    // 修改 b2 的 author 成员指向的内容
    strcpy(b2.author, "You Ka");
    // 展示 b2 的成员
    show_book(&b2);
    // 展示 b1 的成员
    show_book((&b1));

    // 释放 b1 动态分配的内存
    free_book(&b1);
    // 释放 b2 动态分配的内存，此时不会崩溃
    free_book(&b2);
    return 0;
}
D:\MyNote\C++\source\cmake-build-debug\C_Struct2.exe
This book's name is C Primer, the author is Stephen Prata, the value is 68.3.
The struct value's address is 000000000061FE00.
The title's address is 0000000000BA1420.
The author's address is 0000000000BA1440.
-------------------------------------------------------------
Free Memory Success!
This book's name is C Primer, the author is Stephen Prata, the value is 68.3.
The struct value's address is 000000000061FDE0.
The title's address is 0000000000BA1460.
The author's address is 0000000000BA1480.
-------------------------------------------------------------
This book's name is C Primer, the author is You Ka, the value is 68.3.
The struct value's address is 000000000061FDE0.
The title's address is 0000000000BA1460.
The author's address is 0000000000BA1480.
-------------------------------------------------------------
This book's name is C Primer, the author is Stephen Prata, the value is 68.3.
The struct value's address is 000000000061FE00.
The title's address is 0000000000BA1420.
The author's address is 0000000000BA1440.
-------------------------------------------------------------
Free Memory Success!
Free Memory Success!
```

#### 指向结构的指针

**为什么使用指向结构的指针？**

- 指向结构的指针通常比结构本身容易操控。
- 一些早期的 C 视线中，结构不能作为参数传递给函数，但是可以传递指向结构的指针。
- 传递指针通常更有效率。
- 一些用于表示数据的结构中包含指向其他结构的指针。

#### 向函数传递结构

和基本类型数据相同，可以向函数传递结构变量和指向结构的指针。**结构和结构指针作为函数参数的优缺点：**

|      | 结构作为参数                                                 | 指针作为参数                                                 |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 优点 | 1. 函数处理的是原始数据的副本，保护了原始数组； 2. 代码风格更为清晰。 | 1. 无论是以前还是现在的实现都可以使用这种方法； 2. 执行起来很快，只需要传递一个地址。 |
| 缺点 | 1. 较老版本的实现可能无法处理这样的代码； 2. 传递结构浪费时间和存储空间。 | 无法保护原始数据，但 ANSI C 新增的 const 限定符解决了这个问题。 |

**结构和结构指针作为函数参数的选择：**
通常，我们**为了追求效率会使用结构指针作为函数参数**，如需防止原始数据被意外修改，可以使用 const 限定符。而按值传递结构是处理小型结构最常用的方法。

### 联合

#### 联合简介

**Q：联合是什么？**
A：联合(union) 是一种数据类型，它可以在同一内存空间中存储不同的数据类型(不是同时存储)。

> PS：结构是可以同时存储不同数据类型的，但联合不可以，只能存储某一个数据类型。

**关键字**：union。

#### 建立联合的声明

联合的声明和结构声明类似，不同的是，联合使用 union 关键字进行声明。

```c
union hold {
	int digit;
	double bigfl;
	char letter;
};
```

hold 是联合的标记，之后可以使用 hold 声明一个联合变量。

```c
union hold var1;// hold 类型的联合变量 var1
```

也可以在声明联合模板的时候创建一个联合变量。

```c
union hold {
	int digit;
	double bigfl;
	char letter;
} var2;
```

**联合变量的内存空间**：联和模板中占用空间最大的类型的内存大小。如，上例中的 int、double、char 中 double 的内存大小最大，8 字节，所以 union hold 变量的内存空间是 8 字节。

#### 初始化联合变量

与结构类似，通过初始化列表来初始化联合对象。但是，对联合来说，列表只有一个初始化器。C99 允许在初始化器中使用成员指示符来指示哪个成员被初始化。而且，**如果初始化器没有成员指示符，那么就与联合内的第一个成员关联**。具有自动存储类的联合对象也可以使用已有的同类型对象来初始化。

#### 使用联合变量

使用点运算符表示正在使用哪种数据类型。在联合中，一次只能存储一个值。即使有足够的空间，也不能同时存储两个类型的值。

```c
fit.digit = 23; // 把23存储在fit中，占2字节
fit.bigfl = 2.0; // 清除23，存储2.0，占8字节
fit.letter = 'h'; // 清除2.0，存储h，占1字节
```

#### 联合的大小

联合的大小是其最大成员的大小。如果成员是数组的话，成员的大小为数组的大小。

```c
union Std {
	int a;
    char b;
    double c;
} s1;
// Std 的大小为 double 的大小，即 8.
union Stu {
	int a;
    char b[10];
    double c;
} s2;
// 最大成员为 char 数组，大小为 10.
// 但是需要考虑字节补齐。如果编译器默认对齐数是4，大小为12.如果编译器默认对齐数是8，大小为16.
```

#### 练习

```c
#include<stdio.h>
#include<stdlib.h>
union {
     struct {int x, y;} s;
     int x, y;
 } u;
int main()
{
    printf("addr:&u.x=%p, &u.y=%p, &u.s.x=%p, &u.s.y=%p\n\n", &u.x, &u.y, &u.s.x, &u.s.y);
    u.x = 1;
    printf("val:u.x=1;\nres:u.x=%d, u.y=%d, u.s.x=%d, u.s.y=%d\n\n", u.x, u.y, u.s.x, u.s.y);
    u.y = 2;
    printf("val:u.y=2;\nres:u.x=%d, u.y=%d, u.s.x=%d, u.s.y=%d\n\n", u.x, u.y, u.s.x, u.s.y);
    u.s.x = u.x * u.x;
    printf("val:u.s.x = u.x * u.x;\nres:u.x=%d, u.y=%d, u.s.x=%d, u.s.y=%d\n\n", u.x, u.y, u.s.x, u.s.y);
    u.s.y = u.y + u.y;
    printf("val:u.s.y = u.y + u.y;\nres:u.x=%d, u.y=%d, u.s.x=%d, u.s.y=%d\n\n", u.x, u.y, u.s.x, u.s.y);
    getchar();
    return 0;
}
```

![](E:\Note\Code Language\the-c\picture\basic\5-15.png)

### 枚举

#### 枚举简介

**Q：枚举是什么？**
A：枚举类型声明符号名称来表示整型常量。
**关键字：** enum。

> 简单来说，枚举就是声明了一个符号名称来作为整型常量使用，它将一些整型常量用有意义的字符来表示，本质上依旧是使用整型常量，只是更易于阅读代码。
> 枚举类型的目的也就是提高程序的可读性。

#### 建立枚举的声明

枚举的声明和结构、联合的声明语法类似。如下列声明创建了 color 作为标记名，允许将 enum color 作为一个类型名使用。

```c
enum color {
	red,
	orange,
	yellow,
	green,
	blue
};
```

花括号中的标识符列举了 enum color 变量可能的值。因此 enum color 类型的变量的值可能是 red、orange、yellow...
那么 red、orange、yellow... 又代表什么值呢？

#### 枚举的值

默认情况下，枚举列表中的常量会被赋予0、1、2...，从0开始依次递增。

```c
enum color {
	red,
	orange,
	yellow,
	green,
	blue
};
```

例如，上面的例子实际上就是默认 red 代表 0，orange 代表 1，yellow 代表 2，green 代表 3，blue 代表 4。



在枚举声明中除了使用默认值，我们还可以指定整数值。如果只给一个枚举常量赋值，没有对后面的枚举常量赋值，那么后面的常量会被赋予后序的值。

```c
enum color {
	red,
	orange = 10,
	yellow,
	green = 20,
	blue
};
```

在声明的声明中，red 代表 0，orange 代表 10，yellow 代表 11，green 代表 20， blue 代表 21。

虽然这样语法上也是 OK 的，但是推荐使用枚举的时候，每个枚举常量都进行显式的赋值。

#### 枚举的大小

枚举的大小就是 int 类型的大小，即 4 字节。

#### 枚举变量

```c
enum color {
	red,
	orange = 10,
	yellow,
	green = 20,
	blue
};
int main(void){
    enum color col1 = red;
    printf("%d\n", col1); // 输出 0
    enum color col2 = blue;
    printf("%d\n", col2); // 输出 21
    printf("%d\n", sizeof col1); // 输出 4
    return 0;
}
```

#### 小结

1. 在没有显示说明的情况下，枚举常量（也就是花括号中的常量名）默认第一个枚举常量的值为0，往后每个枚举常量依次递增1
2. 在部分显示说明的情况下，未指定的枚举名的值将依着之前最有一个指定值向后依次递增
3. **一个整数不能直接赋值给一个枚举变量**，必须用该枚举变量所属的枚举类型进行类型强制转换后才能赋值
4. 同一枚举类型中不同的枚举成员可以具有相同的值
5. **同一个程序中不能定义同名的枚举类型，不同的枚举类型中也不能存在同名的枚举成员**（枚举常量）

### 名称空间

C 语言通过名称空间标识程序中的各部分，即通过名称来标识。作用域是名称空间概念的一部分：两个不同作用域的同名变量不冲突。



名称空间是分类别的，**在特定作用域中的结构标记、联合标记、枚举标记共享相同的名称空间，但是该名称空间和普通变量使用的名称空间不同。** 这表示相同作用域中的变量和标记的名称可以相同，并不会引起冲突。

> PS：在 C++ 中不允许这样做，因为它把标记名和变量名放在同一名称空间中。

## typedef

typedef 工具是一个高级数据特性，利用 typedef 可以为某一类型自定义名称。typedef 是 type define 的缩写。在使用时和 #define 类似，但两者有3点不同：

1. 1. 与 #define 不同，typedef 创建的符号名只受限于类型，不能用于值。
   2. typedef 由编译器解释，不是预处理器。 
   3. 在其受限范围内，typedef 比 #define 更灵活。

下面介绍 typedef 的工作原理。假设要用 BYTE 表示1字节的数组。只需像定义个 char 类型变量一样定义 BYTE ，然后在定义前面加上关键字 typedef 即可：

```c
typedef unsigned char BYTE; 
```

随后，便可使用 BYTE 来定义变量： 

```c
BYTE x, y[10], *z; 
```

该定义的作用域取决于 typedef 定义所在的位置。如果定义在函数中，就具有局部作用域，受限于定义所在的函数。如果定义在函数外面，就具有文件作用域。 

通常，typedef 定义中用大写字母表示被定义的名称，以提醒用户这个类型名实际上是一个符号缩写。当然，也可以用小写。

typedef 中使用的名称遵循变量的命名规则。为现有类型创建一个名称，看上去真是多此一举，但是它有时的确很有用。在前面的示例中，用 BYTE 代替 unsigned char 表明你打算用 BYTE 类型的变量表示数字，而不是字符码。使用 typedef 还能提高程序的可移植性。如，我们之前提到的 sizeof 运算符的返回类型：size_t类型，以及 time() 函数的返回类型：time_t类型。C 标准规定 sizeof 和 time() 返回整数类型，但是让实现来决定具体是什么整数类型。其原因是，C 标准委员会认为没有哪个类型对于所有的计算机平台都是最优选择。所以，标准委员会决定建立一个新的类型名（如，time_t），并让实现使用 typedef 来设置它的具体类型。以这样的方式，C 标准提供以下通用原型： 

```c
time_t time(time_t *);
```

time_t 在一个系统中是 unsigned long，在另一个系统中可以是 unsigned long long。只要包含 time.h 头文件，程序就能访问合适的定义，你也可以在代码中声明 time_t 类型的变量。 



typedef 的一些特性与 #define 的功能重合。例如： 

```c
#define BYTE unsigned char
```

这使预处理器用 BYTE 替换 unsigned char。但是也有 #define 没有的功能： 

```c
typedef char * STRING;
```

没有 typedef 关键字，编译器将把 STRING 识别为一个指向 char 的指针变量。有了 typedef 关键字，编译器则把 STRING 解释成一个类型的标识符，该类型是指向 char 的指针。因此： 

```c
STRING name, sign; 
// 相当于
char * name, * sign; 
```

但是，如果这样假设： 

```c
#define STRING char *
STRING name, sign;
```

将被翻译成：

```c
char * name, sign; 
```

 这导致只有 name 才是指针。 



还可以把 typedef 用于结构： 

```c
typedef struct complex { 
    float real; 
    float imag; 
} COMPLEX; 
```

然后便可使用 COMPLEX 类型代替 complex 结构来表示复数。



使用 typedef 的第1个原因是：为经常出现的类型创建一个方便、易识别的类型名。用 typedef 来命名一个结构类型时，可以省略该结构的标签。

使用 typedef 的第2个原因是：typedef 常用于给复杂的类型命名。

```c
typedef char (* FRPTC ()) [5];
```

把 FRPTC 声明为一个函数类型，该函数返回一个指针，该指针指向内含5个 char 类型元素的数组。



使用 typedef 时要记住，**typedef 并没有创建任何新类型，它只是为某个已存在的类型增加了一个方便使用的标签**。以前面的 STRING 为例，这意味着我们创建的 STRING 类型变量可以作为实参传递给以指向 char 指针作为形参的函数。

通过结构、联合和 typedef，C 提供了有效处理数据的工具和处理可移植数据的工具。

# Unit 6. 存储类别

## 存储类别

### 名称解释

**1. 对象：** 从硬件方面来看，被储存的每个值都占用一定的物理内存，C 语言把这样的一块内存称为对象（object）。对象可以储存一个或多个值。一个对象可能并未储存实际的值，但是它在储存适当的值时一定具有相应的大小。

> 注：这里的对象和面向对象编程的对象不是一个概念，C 语言是面向过程编程。

**2. 存储期：** 存储期是指对象在内存中保留了多长时间。存储期可用于描述对象。有自动存储、静态存储、动态分配存储、线程存储。

**3. 作用域：** 作用域描述程序中可访问标识符的区域。有块作用域、函数作用域、函数原型作用域、文件作用域。

**4. 链接：** 有无链接、内部链接、外部链接。

**5. 翻译单元：** 编译器源代码文件和所有的头文件都看成是一个包含信息的单独文件，这个文件被称为翻译单元。如果程序由多个源代码文件组成，那么该程序也将由多个 翻译单元组成。每个翻译单元均对应一个源代码文件和它所包含的文件。

### 作用域

作用域描述**程序中可访问标识符的区域**。有块作用域、函数作用域、函数原型作用域、文件作用域。

> 函数原型作用域和函数作用域决定了在函数原型中可以不使用变量名，以及函数原型作用域中的变量名，和函数作用域中的变量名可以不同。
> PS：边长数组不适用。

函数作用域和函数原型作用域实际上也是一种块作用域，因此作用域主要区分块作用域和文件作用域。

**块作用域：** 定义在块中的变量具有块作用域。块作用域变量的可见范围是**从定义处到包含该定义的块的末尾**。

> 所谓的块，就是包裹代码的 { }。

**文件作用域：** 定义在函数的外面的变量具有文件作用域。文件作用域变量的可见范围是**从它的定义处到该定义所在文件的末尾均可见**。由于这样的变量可用于多个函数，所以文件作用域变量也称为全局变量。

> 块作用域变量和文件作用域变量可以根据链接和存储期的不同进行细分。

### 链接性

 C 语言的变量有三种链接属性：无连接、外部链接、内部链接。所谓的链接，在我理解中就是能不能被共用。
**块作用域、函数作用域、函数原型作用域的变量就是无链接的变量**，这些变量只能被定义它们的块、函数、函数原型所使用，不能被别人访问。
**文件作用域的变量是有链接的变量**，可以被位于该变量声明之后的多个函数共用。根据共用文件域变量的范围，又分为外部链接和内部链接。
外部链接和内部链接的区别：外部链接变量可以供多个翻译单元共用，内部链接变量只在一个翻译单元中使用。

外部链接变量的定义：在函数的外部像定义普通变量一样。
内部链接变量的定义：在函数的外部，使用 static 关键字定义。

```cpp
int giants = 5; // 文件作用域，外部链接 
static int dodgers = 3; // 文件作用域，内部链接
```

### 存储期

**作用域和链接描述了一个标识符的可见性**(在程序的那些地方可以访问标识符)。而**存储期描述的是**通过这些标识符访问的**对象的生存期**。C 语言的对象有4中存储期：**自动存储期、静态存储期、动态分配存储期、线程存储期**。

#### 自动存储期

块作用域的变量通常都具有自动存储期。**当程序进入定义这些变量的块时，为这些变量分配内存；当退出这个块时，释放刚才为变量分配的内存**。 这种做法相当于把自动变量占用的内存视为一个可重复使用的工作区或暂存区。例如，一个函数调用结束后，其变量占用的内存可用于储存下一个被调用函数的变量。

> PS：块作用域变量除了可以具有自动存储期，也能具有静态存储期。在创建静态存储期的块作用域变量时使用 static 关键字来声明。

```cpp
void more()
{
	static int ct = 0;
}
```

> static 关键字用于修饰块作用域变量的声明时，表示该变量具有静态存储期，和存储期有关。
> static 关键字用于修饰文件域变量的声明时，表示该变量是内部链接的变量，和存储期无关，因为内部链接和外部链接的变量都是静态存储期的。

#### 静态存储期

如果对象具有静态存储期，那么它**在程序的执行期间一直存在**。文件作用域变量和 static 修饰的块作用域变量具有静态存储期。

> 对于文件作用域变量，关键字 static 表明了其链接属性，而非存储期。

#### 动态分配存储期

用 malloc() 和 free() 进行动态内存管理。

#### 线程存储期

线程存储期用于并发程序设计，程序执行可被分为多个线程。具有线程存储期的对象，**从被声明时到线程结束一直存在**。

### 存储类别

C 语言使用作用域、链接和存储期为变量定义多种存储方案。这里不涉及并发程序设计，因此不包括线程存储期，而动态分配内存期后面再介绍，因此就剩下5中存储类别：自动、寄存器、静态无链接、静态内部链接、静态外部链接。

| 存储类别     | 存储期     | 作用域     | 链接     | 声明方式                      |
| ------------ | ---------- | ---------- | -------- | ----------------------------- |
| 自动         | 自动存储期 | 块作用域   | 无链接   | 块内                          |
| 寄存器       | 自动存储期 | 块作用域   | 无链接   | 块内、使用 register 关键字    |
| 静态无链接   | 静态存储期 | 块作用域   | 无链接   | 块内、使用 static 关键字      |
| 静态内部链接 | 静态存储期 | 文件作用域 | 内部链接 | 所有函数外，使用static 关键字 |
| 静态外部链接 | 静态存储期 | 文件作用域 | 外部链接 | 所有函数外                    |

#### 自动变量

**属于自动存储类别的变量具有自动存储期、块作用域且无链接。**默认情况下，声明在块或函数头中的任何变量都属于自动存储类别。可以显式地使用关键字 auto 来声明一个自动变量。

> 一般情况下，使用 auto 来声明自动变量，是为了表明故意覆盖一个同名的外部变量，或者强调不要把该变量改为其他存储类别。
> auto 在 C 中表示存储类别说明符，在 C++ 中用法不同。

块作用域和无链接意味着只有在变量定义所在的块中才能通过变量名访问该变量（当然，参数用于传递变量的值和地址给另一个函数，但是这是间接的方法）。另一个函数可以使用同名变量，但是该变量是储存在不同内存位置上的另一个变量。

变量具有自动存储期意味着，程序在进入该变量声明所在的块时变量存在，程序在退出该块时变量消失。原来该变量占用的内存位置现在可做他用。



**自动变量的初始化问题：自动变量不会自动初始化**，如果不初始化，该值是垃圾值。可以使用非常量表达式初始化自动变量，前提是所用的变量在之前已经定义过。

```cpp
void main(void)
{
	int a;// 未初始化，直接使用是垃圾值
	int b = 1; // 使用常量初始化自动变量 b
	int c = 2*b; // 使用非常量表达式初始化自动变量 c
}
```

#### 寄存器变量

变量通常储存在计算机内存中。如果幸运的话，寄存器变量储存在 CPU 的寄存器中。而寄存器可以概括地认为是最快的可用内存。与普通变量相比，访问和处理寄存器变量的速度更快。但由于寄存器变量储存在寄存器而非内存中，所以无法获取寄存器变量的地址。
绝大多数方面，寄存器变量和自动变量都一样。也就是说，它们都是块作用域、无链接和自动存储期。但是寄存器变量无法获取地址，即无法使用取地址符 &。

**如何声明寄存器变量？使用存储类别说明符 register 便可声明寄存器变量**。
需要注意的是，register 更像是一种请求，表示希望该变量是寄存器变量，至于会不会放到寄存器中计算，则是编译器根据寄存器或最快可用内存的数量衡量你的请求，或者直接忽略你的请求，所以可能不会如你所愿。在这种情况下，寄存器变量就变成普通的自动变量。即使是这样，仍然不能对该变量使用地址运算符。

> 可声明为 register 的数据类型有限。例如，处理器中的寄存器可能没有足够大的空间来储存 double 类型的值。

#### 块作用域的静态变量

静态变量听起来像是静止不变的变量，可能会认为不可变的变量，事实上 const 才是用来修饰常量的关键字，表示值不可变，而静态 **static 则是表示变量的地址不可变**。静态变量在程序被载入内存时就执行完毕了。例如，trystatic() 中的 a 变量在程序载入内存时就已经创建了，在 trystatic() 中声明只是为了告诉编译器只有 tyrstatic() 函数可以看见该变量。

```c
void trystatic(void)
{
	static int a = 1;
}
```

> 如果希望多个函数都可以访问同一个变量，则需要将该变量的声明放在所有函数之外，作为文件作用域变量，所有的文件作用域变量都是静态的。
> **函数的形参中不允许使用 static 变量**。

#### 内部链接的静态变量

该存储类别的变量具有静态存储期、文件作用域和内部链接。在所有函数外部（这点与外部变量相同），用存储类别说明符 static 定义的变量具有这种存储类别。
可以使用存储类别说明符 extern，在函数中重复声明任何具有文件作用域的变量。这样的声明并不会改变其链接属性。也可以不使用 extern，在函数中直接使用内部链接静态变量的变量名。

```cpp
int traveler = 1; // 外部链接 
static int stayhome = 1; // 内部链接 
int main() 
{
	extern int traveler; // 使用定义在别处的 traveler 
	extern int stayhome; // 使用定义在别处的 stayhom
}
```

#### 外部链接的静态变量

外部链接的静态变量具有文件作用域、外部链接和静态存储期。该类别有时称为外部存储类别，属于该类别的变量称为外部变量。

**创建外部变量：** 把变量的定义性声明放在在所有函数的外面便创建了外部变量。
**使用别的文件中创建的外部变量：** 使用 extern 关键字再次声明。

```cpp
int a = 1; // 创建了一个外部变量 a
extern int b; // 声明了变量 b，该变量的定义式声明在别的文件中
void main(void)
{
	extern int c;// 声明了变量 b，该变量的定义式声明在别的文件中
	auto int b; // 声明了一个和外部变量 b 同名的自动变量
}
```

对于 `extern int b` 省略 extern 则表示创建了一个外部变量 b。
对于 `extern int c` 省略 extern 则表示创建了一个自动变量 c。
对于 `auto int b;` 省略 auto 依旧表示创建一个自动变量 b，但是为了显式表达这里的目的就是创建一个和外部变量 b 同名的自动变量，不推荐省略 auto。



**外部链接静态变量的初始化问题：**

1. 如果不初始化外部变量，会自动被初始化为 0。
2. 外部变量只能初始化一次，且必须在定义该变量时进行。
3. 只能使用常量表达式初始化外部变量。

```cpp
// file1.c
int a = 1;
// file2.c
extern int a = 2; // 错误
```

#### 多文件问题

只有当程序由多个翻译单元组成时，才体现区别内部链接和外部链接的重要性。接下来简要介绍一下。 复杂的 C 程序通常由多个单独的源代码文件组成。有时，这些文件可能要共享一个外部变量。C 通过在一个文件中进行**定义式声明**，然后在其他文件中进行**引用式声明**来实现共享。也就是说，除了一个定义式声明外，其他声明都要使用 extern 关键字。而且，**只有定义式声明才能初始化变量**。 注意，如果外部变量定义在一个文件中，那么其他文件在使用该变量之 前必须先声明它（用 extern关键字）。也就是说，在某文件中对外部变量进行定义式声明只是单方面允许其他文件使用该变量，其他文件在用 extern 声明之前不能直接使用它。

#### 函数存储类别

函数的存储类别有外部函数(默认)、静态函数、内联函数。
外部函数可以被其他文件函数访问，静态函数只能被用于其定义所在文件。

```cpp
double gamma(double); // 定义一个外部函数
extern double delta(double, int); // 声明一个定义在其他文件中的函数
static double beta(int, int); // 静态函数
```

通常的做法是：用 extern 关键字声明定义在其他文件中的函数。这样做是为了表明当前文件中使用的函数被定义在别处。除非使用 static 关键字，否则一般函数声明都默认为 extern。

#### 存储类别的选择

对于“使用哪种存储类别”的回答**绝大多数是“自动存储类别”**，要知道默认类别就是自动存储类别。

初学者会认为外部存储类别很不错，为何不把所有的变量都设置成外部变量，这样就不必使用参数和指针在函数间传递信息了。然而，这背后隐藏着一个陷阱。如果这样做，A() 函数可能违背你的意图，私下修改 B() 函数使用的变量。多年来，无数程序员的经验表明，随意使用外部存储类别的变量导致的后果远远超过了它所带来的便利。唯一例外的是const数据。因为它们在初始化后就不会被修改，所以不用担心它们被意外篡改。

**保护性程序设计的黄金法则**是：**“按需知道”原则**。尽量在函数内部解决该函数的任务，只共享那些需要共享的变量。

## 动态分配内存

### malloc() 和 free()

我们前面讨论的自动变量、寄存器变量、无链接静态变量、内部链接静态变量、外部连接静态变量这些存储类别有一个共同之处：在确定用哪种存储类别后，根据已制定好的内存管理规则，将自动选择其作用域和存储期。然而，还有更灵活地选择，即用库函数分配和管理内存，也就是动态分配存储期。

首先，回顾一下内存分配。所有程序都必须预留足够的内存来储存程序使用的数据。这些内存中有些是自动分配的。静态数据在程序载入内存时分配，而自动数据在程序执行块时分配，并在程序离开该块时销毁。 

C 能做的不止这些。可以在程序运行时分配更多的内存。主要的工具是 malloc() 函数。

#### malloc()

malloc() 函数定义在 <stdlib.h> 中：

```c
void *__cdecl malloc(size_t _Size);
```

**参数**：所需的内存字节数。

**功能**：malloc() 函数会找到合适的空闲内存块，这样的内存是匿名的。也就是说，malloc() 分配内存，但是不会为其赋名。然而，它确实返回动态分配内存块的首字节地址。因此，可以把该地址赋给一个指针变量，并使用指针访问这块内存。

**返回值**：如果 malloc() 分配内存成功，返回一个 void* 指针指向分配的内存块首地址，如果 malloc() 分配内存失败，将返回空指针。

PS：从 ANSI C 标准开始，C 使用一个新的类型：指向 void 的指针，该类型相当于一个“通用指针”。把指向 void 的指针赋给任意类型的指针完全不用考虑类型匹配的问题。但是在 ANSI C 中，应该坚持使用强制类型转换，提高代码的可读性(C++ 中则要求必须强制转换)。malloc() 函数可用于返回指向数组的指针、指向结构的指针等，通常该函数的返回值会被强制转换为匹配的类型。



我们试着用 malloc() 创建一个数组。除了用 malloc() 在程序运行时请求一块内存，还需要一个指针记录这块内存的位置。例如：

```c
double * ptd; 
ptd = (double *) malloc(30 * sizeof(double));
```

以上代码为 30 个 double 类型的值请求内存空间，并设置 ptd 指向该位置。注意，指针 ptd 被声明为指向一个 double 类型，而不是指向内含 30 个 double 类型值的块。回忆一下，数组名是该数组首元素的地址。因此，如果让 ptd 指向这个块的首元素，便可像使用数组名一样使用它。也就是说，可以使用表达式 ptd[0] 访问该块的首元素，ptd[1] 访问第 2 个元素，以此类推。根据前面所学的知识，可以使用数组名来表示指针，也可以用指针来表示数组。



**现在，我们有3种创建数组的方法**。

1. 声明数组时，用常量表达式表示数组的维度，用数组名访问数组的元素。可以用静态内存或自动内存创建这种数组。 
2. 声明变长数组（C99新增的特性）时，用变量表达式表示数组的维度，用数组名访问数组的元素。具有这种特性的数组只能在自动内存中创建。 
3. 声明一个指针，调用 malloc()，将其返回值赋给指针，使用指针访问数组的元素。该指针可以是静态的或自动的。 



使用第2种和第3种方法可以创建动态数组（dynamic array）。这种数组和普通数组不同，可以在程序运行时选择数组的大小和分配内存。动态分配内存比变长数组更灵活。

```c
double item[n]; /* C99之前：n不允许是变量 */ 
ptd = (double *) malloc(n * sizeof(double)); /* 可以 */ 
```

**通常，malloc()要与free()配套使用。**

#### free()

free() 和 malloc() 函数一样在 <stdlib.h> 中声明。

```c
void __cdecl free(void *_Memory);
```

**参数**：malloc() 返回的地址。

**返回值**：无

**功能**：释放之前 malloc() 分配的内存。因此，动态分配内存的存储期从调用 malloc() 分配内存到调用 free() 释放内存为止。

设想 malloc() 和 free() 管理着一个内存池。每次调用 malloc() 分配内存给程序使用，每次调用 free() 把内存归还内存池中，这样便可重复使用这些内存。

> PS：free() 的参数应该是一个指针，指向由 malloc() 分配的一块内存。不能用 free() 释放通过其他方式（如，声明一个数组）分配的内存。

#### 动态数组

**使用动态数组有什么好处**？

使用动态数组给程序带来了更多灵活性。假设你已经知道，在大多数情况下程序所用的数组都不会超过 100 个元素，但是有时程序确实需要 10000 个元素。要是按照平时的做法，你不得不为这种情况声明一个内含 10000 个元素的数组。基本上这样做是在浪费内存。如果需要 10001 个元素，该程序就会出错。这种情况下，可以使用一个动态数组调整程序以适应不同的情况。 

#### free() 的重要性

静态内存的数量在编译时是固定的，在程序运行期间也**不会改变**。自动变量使用的内存数量在程序执行期间**自动**增加或减少。但是动态分配的内存数量只会增加，除非用 free() 进行释放。

```c
... 
int main() 
{
    double glad[2000]; 
    int i; 
    ...
    for (i = 0; i < 1000; i++) 
    	gobble(glad, 2000); 
    ... 
}
void gobble(double ar[], int n) 
{
    double * temp = (double *) malloc( n * sizeof(double)); 
    .../* free(temp); // 假设忘记使用free() */ 
}
```

第1次调用 gobble() 时，它创建了指针 temp，并调用 malloc() 分配了 16000 字节的内存（假设 double 为 8 字节）。假设如代码注释所示，遗漏了 free()。当函数结束时，作为自动变量的指针 temp 也会消失。但是它所指向的 16000 字节的内存却仍然存在。由于 temp 指针已被销毁，所以无法访问这块内存，它也不能被重复使用，因为代码中没有调用 free() 释放这块内存。

第2次调用 gobble() 时，它又创建了指针 temp，并调用 malloc() 分配了 16000 字节的内存。第1次分配的 16000 字节内存已不可用，所以 malloc() 分配了另外一块 16000 字节的内存。当函数结束时，该内存块也无法被再访问和再使用。

循环要执行 1000 次，所以在循环结束时，内存池中有 1600 万字节被占用。实际上，也许在循环结束之前就已耗尽所有的内存。这类问题被称为内存泄漏（memory leak）。在函数末尾处调用 free() 函数可避免这类问题发生。 

### calloc()

分配内存还可以用 calloc() 函数。同样是在 <stdlib.h> 中声明。

```c
void *__cdecl calloc(size_t _NumOfElements,size_t _SizeOfElements);
```

**参数**：calloc() 函数接受两个无符号整数作为参数( ANSI 规定是 size_t 类型）。第1个参数是所需的存储单元数量，第2个参数是存储单元的大小(以字节为单位)。

**返回值**：和 malloc() 函数类似，在 ANSI C 之后，返回指向 void 的指针。如果要储存不同的类型，应使用强制类型转换运算符。

**功能**：分配指定数目指定大小的存储空间，并返回指向这个空间的指针。同时，分配的存储空间的所有位都被设置为 0。

```c
long * newmem; 
newmem = (long *)calloc(100, sizeof (long));
```

在该例中，long 为 4 字节，所以，前面的代码创建了 100 个 4 字节的存储单元，总共400字节。 用 sizeof(long) 而不是 4，提高了代码的可移植性。这样，在其他 long 不是 4 字节的系统中也能正常工作。 



calloc() 函数还有一个**特性**：**它把块中的所有位都设置为 0**（注意，在某些硬件系统中，不是把所有位都设置为0来表示浮点值0）。 **而 malloc() 函数不会初始化**。

free() 函数也可用于释放 calloc() 分配的内存。

### 动态内存分配和变长数组

变长数组（VLA）和调用 malloc() 在功能上有些重合。例如，两者都可用于创建在运行时确定大小的数组。

不同的是，变长数组是自动存储类型。因此，程序在离开变长数组定义所在的块时，变长数组占用的内存空间会被自动释放，不必使用 free()。另一方面，用 malloc() 创建的数组不必局限在一个函数内访问。例如，可以这样做：被调函数创建一个数组并返回指针，供主调函数访问，然后主调函数在末尾调用 free() 释放之前被调函数分配的内存。另外，free() 所用的指针变量可以与 malloc() 的指针变量不同，但是两个指针必须储存相同的地址。但是，**不能释放同一块内存两次**。 



对多维数组而言，使用变长数组更方便。当然，也可以用 malloc() 创建二维数组，但是语法比较繁琐。如果编译器不支持变长数组特性，就只能固定二维数组的维度。

```c
int n = 5; 
int m = 6; 
int ar2[n][m]; // n×m的变长数组（VLA） 
int (* p2)[6]; // C99之前的写法 
int (* p3)[m]; // 要求支持变长数组 
p2 = (int (*)[6]) malloc(n * 6 * sizeof(int)); // n×6 数组 
p3 = (int (*)[m]) malloc(n * m * sizeof(int)); // n×m 数组（要求支持变长数 组）
ar2[1][2] = p2[1][2] = 12; 
```

### 静态存储区、栈、堆

**存储类别和动态内存分配有何联系**？

我们来看一个理想化模型。可以认为程序把它可用的内存分为 3 部分：一部分供具有外部链接、内部链接和无链接的静态变量使用；一部分供自动变量使用；一部分供动态内存分配。 

静态存储类别所用的内存数量在编译时确定，只要程序还在运行，就可访问储存在该部分的数据。该类别的变量在程序开始执行时被创建，在程序结束时被销毁。 这部分内存称为静态存储区 or 全局存储区。

自动存储类别的变量在程序进入变量定义所在块时存在，在程序离开块时消失。因此，随着程序调用函数和函数结束，自动变量所用的内存数量也相应地增加和减少。这部分的内存通常作为栈来处理，这意味着新创建的变量按顺序加入内存，然后以相反的顺序销毁。 这部分内存称为栈。

动态分配的内存在调用 malloc() 或相关函数时存在，在调用 free() 后释放。这部分的内存由程序员管理，而不是一套规则。所以内存块可以在一个函数中创建，在另一个函数中销毁。正是因为这样，这部分的内存用于动态内存分配会支离破碎。也就是说，未使用的内存块分散在已使用的内存块之间。另外，使用动态内存通常比使用栈内存慢。这部分内存称为堆。

总而言之，程序把静态对象、自动对象和动态分配的对象储存在不同的区域。

## ANSI C 类型限定符

我们**通常用类型和存储类别来描述一个变量**。

C90 新增了两个属性： 恒常性(constancy)和易变性(volatility)。这两个属性可以分别用关键字 const 和 volatile 来声明，以这两个关键字创建的类型是限定类型(qualified type)。

C99 标准新增了第 3 个限定符：restrict，用于提高编译器优化。

C11 标准新增了第 4 个限定符：_Atomic。C11 提供一个可选库，由 stdatomic.h 管理，以支持并发程序设计，而且 _Atomic 是可选支持项。 

C99 为类型限定符增加了一个新属性：它们现在是幂等的(idempotent)！这个属性听起来很强大，其实意思是可以在一条声明中多次使用同一个限定符，多余的限定符将被忽略： 

```c
const const const int n = 6; // 与 const int n = 6;相同
```

### const 类型限定符

以 const 关键字声明的对象，其值不能通过赋值或递增、递减来修改。但可以初始化 const 变量，初始化之后，就不能再改变其值了。

#### 指针和 const

声明普通变量和数组时使用 const 关键字很简单。指针则复杂一些，因为要区分是限定指针本身为 const 还是限定指针指向的值为 const，即指针常量和常量指针的区别。

```c
const float * pf; /* pf 指向一个float类型的const值 */ 
```

创建了 pf 指向的值不能被改变，而 pf 本身的值可以改变。例如，可以设置该指针指向其他 const 值。相比之下，下面的声明： 

```c
float * const pt; /* pt 是一个const指针 */ 
```

创建的指针 pt 本身的值不能更改。pt 必须指向同一个地址，但是它所指向的值可以改变。下面的声明： 

```c
const float * const ptr; 
```

表明 ptr 既不能指向别处，它所指向的值也不能改变。 



还可以把 const 放在第3个位置： 

```c
float const * pfc; // 与const float * pfc;相同 
```

小技巧：const 和 * 的位置决定了是常量指针还是指针常量。const 在前，* 在后，表示常量指针，指向常量的指针。* 在前，const 在后，表示指针常量，指针本身是一个常量。

简而言之， const 放在 * 左侧任意位置，限定了指针指向的数据不能改变；const 放在 * 的右侧，限定了指针本身不能改变。 



const 关键字的**常见用法**是作为函数的形参。例如，假设有一个函数要调用 display() 显示一个数组的内容。要把数组名作为实际参数传递给该函数，但是数组名是一个地址。该函数可能会更改主调函数中的数据，但是下面的原型保证了数据不会被更改： 

```c
void display(const int array[], int limit); 
```

在函数原型和函数头，形参声明 const int array[] 与 const int * array 相同，所以该声明表明不能更改 array 指向的数据。 

ANSI C 库遵循这种做法。如果一个指针仅用于给函数访问值，应将其声明为一个指向 const 限定类型的指针。如果要用指针更改主调函数中的数据，就不使用 const 关键字。

#### 全局变量和 const

前面讲过，使用全局变量是一种冒险的方法，因为这样做暴露了数据，程序的任何部分都能更改数据。如果把数据设置为 const，就可避免这样的危险，因此用 const 限定符声明全局数据很合理。可以创建 const 变量、const 数组和 const 结构。

然而，在文件间共享 const 数据要小心。可以采用两个策略。第一，遵循外部变量的常用规则，即在一个文件中使用定义式声明，在其他文件中使用引用式声明。另一种方案是，把 const 变量放在一个头文件中，然后在其他文件中包含该头文件。

### volatile 类型限定符

volatile 这个单词的意思是**易变的**。

volatile 限定符告知计算机，代理(而不是变量所在的程序)可以改变该变量的值。通常，它被用于硬件地址以及在其他程序或同时运行的线程中共享数据。例如，一个地址上可能储存着当前的时钟时间，无论程序做什么，地址上的值都随时间的变化而改变，或者一个地址用于接受另一台计算机传入的信息。

volatile 的语法和 const 一样： 

```c
volatile int loc1;/* loc1 是一个易变的位置 */ 
volatile int * ploc; /* ploc 是一个指向易变的位置的指针 */ 
```

以上代码把 loc1 声明为 volatile 变量，把 ploc 声明为指向 volatile 变量的指针。



读者可能认为 volatile 是个可有可无的概念，**为何 ANSI 委员把 volatile 关键字放入标准**？原因是它涉及编译器的优化。例如，假设有下面的代码： 

```c
vall =x; 
/* 一些不使用 x 的代码*/ 
val2 = x 
```

智能的(进行优化的)编译器会注意到以上代码使用了两次 x，但并未改变它的值。于是编译器把 x 的值临时储存在寄存器中，然后在 val2 需要使用 x 时，才从寄存器中(而不是从原始内存位置上)读取 x 的值，以节约时间。这个过程被称为高速缓存(caching)。通常，高速缓存是个不错的优化方案，但是如果一些其他代理在以上两条语句之间改变了 x 的值，就不能这样优化了。如果没有 volatile 关键字，编译器就不知道这种事情是否会发生。因此，为安全起见，编译器不会进行高速缓存。这是在 ANSI 之前的情况。现在，如果声明中没有 volatile 关键字，编译器会假定变量的值在使用过程中不变，然后再尝试优化代码。 

可以同时用 const 和 volatile 限定一个值。例如，通常用 const 把硬件时钟设置为程序不能更改的变量，但是可以通过代理改变，这时用 volatile。只能在声明中同时使用这两个限定符，它们的顺序不重要，如下所示：

```c
volatile const int loc; 
const volatile int * ploc;
```

### restrict 类型限定符

restrict 的意思是限定。

restrict 关键字允许编译器优化某部分代码以更好地支持计算。**它只能用于指针，表明该指针是访问数据对象的唯一且初始的方式**。

要弄明白为什么这样做有用，先看几个例子。考虑下面的代码： 

```c
int ar[10]; 
int * restrict restar = (int *) malloc(10 * sizeof(int)); 
int * par = ar; 
```

这里，指针 restar 是访问由 malloc() 所分配内存的唯一且初始的方式。因此，可以用 restrict 关键字限定它。而指针 par 既不是访问 ar 数组中数据的初始方式，也不是唯一方式。所以不用把它设置为 restrict。



现在考虑下面稍复杂的例子，其中 n 是 int 类型： 

```c
for (n = 0; n < 10; n++) 
{
    par[n] += 5; 
    restar[n] += 5; 
    ar[n] *= 2; 
    par[n] += 3; 
    restar[n] += 3; 
}
```

由于之前声明了 restar 是访问它所指向的数据块的唯一且初始的方式，编译器可以把涉及 restar 的两条语句替换成下面这条语句，效果相同： 

```c
restar[n] += 8; /* 可以进行替换 */ 
```

但是，如果把与 par 相关的两条语句替换成下面的语句，将导致计算错误：

```c
par[n] += 8; / * 给出错误的结果 */ 
```

这是因为 for 循环在 par 两次访问相同的数据之间，用 ar 改变了该数据的值。

在本例中，如果未使用 restrict 关键字，编译器就必须假设最坏的情况，即在两次使用指针之间，其他的标识符可能已经改变了数据。如果用了 restrict 关键字，编译器就可以选择捷径优化计算。 

restrict 限定符还可用于函数形参中的指针。**这意味着编译器可以假定在函数体内其他标识符不会修改该指针指向的数据，而且编译器可以尝试对其优化，使其不做别的用途**。例如，C 库有两个函数用于把一个位置上的字节拷贝到另一个位置。在 C99 中，这两个函数的原型是： 

```c
void * memcpy(void * restrict s1, const void * restrict s2, size_t n); 
void * memmove(void * s1, const void * s2, size_t n);
```

这两个函数都从位置 s2 把 n 字节拷贝到位置 s1。

memcpy() 函数要求两个位置不重叠，但是 memove() 没有这样的要求。声明 s1 和 s2 为 restrict 说明这两个指针都是访问相应数据的唯一方式，所以它们不能访问相同块的数据。这满足了 memcpy() 无重叠的要求。memmove() 函数允许重叠，它在拷贝数据时不得不更小心，以防在使用数据之前就先覆盖了数据。

restrict 关键字有两个读者。一个是编译器，该关键字告知编译器可以自由假定一些优化方案。另一个读者是用户，该关键字告知用户要使用满足 restrict 要求的参数。总而言之，编译器不会检查用户是否遵循这一限制，但是无视它后果自负。

### _Atomic 类型限定符

并发程序设计把程序执行分成可以同时执行的多个线程。这给程序设计带来了新的挑战，包括如何管理访问相同数据的不同线程。

C11 通过包含可选的头文件 stdatomic.h 和 threads.h，提供了一些可选的（不是必须实现的）管理方法。值得注意的是，要通过各种宏函数来访问原子类型。当一个线程对一个原子类型的对象执行原子操作时，其他线程不能访问该对象。

```c
int hogs;// 普通声明 
hogs = 12; // 普通赋值 
```

可以替换成： 

```c
_Atomic int hogs; // hogs 是一个原子类型的变量 
atomic_store(&hogs, 12); // stdatomic.h中的宏 
```

这里，在 hogs 中储存 12 是一个原子过程，其他线程不能访问 hogs。编写这种代码的前提是，编译器要支持这一新特性。 

# Unit 7. 文件I/O

## 与文件通信

我们程序中使用的数据都是保存在内存中的，是临时的，无法永久保存，每次启动程序都是从数据的初始化开始重新进行。而有时，我们希望程序的数据是上一次运行的结果，这时就需要将数据保存到外存中，即需要程序从文件中读取信息或把信息写入文件。

C 提供了强大的文件通信方法，可以在程序中打开文件，然后使用特殊的 I/O 函数读取文件中的信息或把信息写入文件。在研究这些方法之前，先简要介绍一下文件的性质。

### 文件是什么？

**文件**(file) **通常是在磁盘或固态硬盘上的一段已命名的存储区**。对我们而言，stdio.h 就是一个文件的名称，该文件中包含一些有用的信息。然而，对操作系统而言，文件更复杂一些。例如，大型文件会被分开储存，或者包含一些额外的数据，方便操作系统确定文件的种类。然而，这都是操作系统所关心的，程序员关心的是 C 程序如何处理文件(除非你正在编写操作系统)。

C 把文件看作是一系列连续的字节，每个字节都能被单独读取。这与 UNIX 环境中(C 的发源地)的文件结构相对应。由于其他环境中可能无法完全对应这个模型，C 提供两种文件模式：文本模式和二进制模式。

### 文本模式和二进制模式

首先，要区分文本内容和二进制内容、文本文件格式和二进制文件格式，以及文件的文本模式和二进制模式。 所有文件的内容都以二进制形式(0或1)储存。

但是，如果文件最初使用二进制编码的字符（例如， ASCII 或 Unicode）表示文本（就像 C 字符串那样），该文件就是文本文件，其中包含文本内容。

如果文件中的二进制值代表机器语言代码或数值数据（使用相同的内部表示，假设，用于 long 或 double 类型的值）或图片或音乐编码，该文件就是二进制文件，其中包含二进制内容。 

UNIX 用同一种文件格式处理文本文件和二进制文件的内容。不奇怪，鉴于 C 是作为开发 UNIX 的工具而创建的，C 和 UNIX 在文本中都使用 \n(换行符)表示换行。UNIX 目录中有一个统计文件大小的计数，程序可使用该计数确定是否读到文件结尾。

然而，其他系统在此之前已经有其他方法处理文件，专门用于保存文本。也就是说，其他系统已经有一种与 UNIX 模型不同的格式处理文本文件。例如，以前的 OS X Macintosh 文件用 \r(回车符)表示新的一行。早期的 MS-DOS 文件用 \r\n 组合表示新的一行，用嵌入的 Ctrl+Z 字符表示文件结尾，即使实际文件用添加空字符的方法使其总大小是 256 的倍数(在 Windows 中，Notepad 仍然生成 MS-DOS 格式的文本文件，但是新的编辑器可能使用类 UNIX 格式居多）。其他系统可能保持文本文件中的每一行长度相同，如有必要，用空字符填充每一行，使其长度保持一致。或者，系统可能在每行的开始标出每行的长度。 

为了规范文本文件的处理，C 提供两种访问文件的途径：二进制模式和文本模式。在二进制模式中，程序可以访问文件的每个字节。而在文本模式中，程序所见的内容和文件的实际内容不同。程序以文本模式读取文件时，把本地环境表示的行末尾或文件结尾映射为 C 模式。例如，C 程序在旧式 Macintosh 中以文本模式读取文件时，把文件中的 \r 转换成 \n；以文本模式写入文件时，把 \n 转换成 \r。或者，C 文本模式程序在 MS-DOS 平台读取文件时，把 \r\n 转换成 \n；写入文件时，把 \n 转换成 \r\n。在其他环境中编写的文本模式程序也会做类似的转换。

![](E:\Note\Code Language\the-c\picture\basic\7-1.png)

### IO 的级别

除了选择文件的模式，大多数情况下，还可以选择 I/O 的两个级别（即处理文件访问的两个级别）。

底层 I/O(low-level I/O)使用操作系统提供的基本 I/O 服务。标准高级 I/O(standard high-level I/O)使用 C 库的标准包和 stdio.h 头文件定义。

因为无法保证所有的操作系统都使用相同的底层 I/O 模型，C 标准只支持标准 I/O 包。有些实现会提供底层库，但是 C 标准建立了可移植的 I/O 模型，我们主要讨论这些 I/O。

### 标准文件

C 程序会自动打开 3 个文件，它们被称为标准输入(standard input)、标准输出(standard output)和标准错误输出(standard error output)。

在默认情况下，标准输入是系统的普通输入设备，通常为键盘；标准输出和标准错误输出是系统的普通输出设备，通常为显示屏。通常，标准输入为程序提供输入，它是 getchar() 和 scanf() 使用的文件。程序通常输出到标准输出，它是 putchar()、puts() 和 printf() 使用的文件。第 8 章提到的重定向把其他文件视为标准输入或标准输出。标准错误输出提供了一个逻辑上不同的地方来发送错误消息。例如，如果使用重定向把输出发送给文件而不是屏幕，那么发送至标准错误输出的内容仍然会被发送到屏幕上。这样很好，因为如果把错误消息发送至文件，就只能打开文件才能看到。 

## 标准 IO

与底层 I/O 相比，标准 I/O 包除了可移植以外还有两个好处。第一，标准 I/O 有许多专门的函数简化了处理不同 I/O 的问题。第二，输入和输出都是缓冲的。也就是说，一次转移一大块信息而不是一字节信息（通常至少 512 字节）。这种缓冲极大地提高了数据传输速率。程序可以检查缓冲区中的字节。缓冲在后台处理，所以让人有逐字符访问的错觉（如果使用底层 I/O，要自己完成大部分工作）。

### fopen()

```c
FILE* fopen(const char *filename, const char *mode)
```

该函数声明在 <stdio.h> 中。它的第 1 个参数是待打开文件的名称，更确切地说是一个包含该文件名的字符串地址。第 2 个参数是一个字符串，指定待打开文件的模式。**该函数的作用是使用给定的模式 mode 打开 文件名为 filename 的文件**。下面的图表列出了 C 库提供的一些模式：

![](E:\Note\Code Language\the-c\picture\basic\7-2.png)

r 代表 read，w 代表 write，a 代表 append，b 代表 binary，+ 表示读写。



像 UNIX 和 Linux 这样只有一种文件类型的系统，带 b 字母的模式和不带 b 字母的模式相同。 新的 C11 新增了带 x 字母的写模式，与以前的写模式相比具有更多特性。第一，如果以传统的一种写模式打开一个现有文件，fopen() 会把该文件的长度截为 0，这样就丢失了该文件的内容。但是使用带 x 字母的写模式，

即使 fopen() 操作失败，原文件的内容也不会被删除。第二，如果环境允许，x 模式的独占特性使得其他程序或线程无法访问正在被打开的文件。

**注意**！如果使用任何一种 "w" 模式（不带 x 字母）打开一个现有文件，该文件的内容会被删除，以便程序在一个空白文件中开始操作。然而，如果使用带 x 字母的任何一种模式，将无法打开一个现有文件。 

程序成功打开文件后，fopen() 将返回文件指针，其他 I/O 函数可以使用这个指针指定该文件。文件指针的类型是指向 FILE 的指针，FILE 是一个定义在 stdio.h 中的派生类型。文件指针并不指向实际的文件，它指向一个包含文件信息的数据对象，其中包含操作文件的 I/O 函数所用的缓冲区信息。因为标准库中的 I/O 函数使用缓冲区，所以它们不仅要知道缓冲区的位置，还要知道缓冲区被填充的程度以及操作哪一个文件。标准 I/O 函数根据这些信息在必要时决定再次填充或清空缓冲区。

### getc() 和 putc()

```c
int getc(FILE *filename);
int putc(int char, FILE *filename);
```

getc() 和 putc() 函数与 getchar() 和 putchar() 函数类似。所不同的是，要告诉 getc() 和 putc() 函数使用哪一个文件。

```c
// 下面这条语句的意思是“从标准输入中获取一个字符”： 
ch = getchar(); 
// 下面这条语句的意思是“从fp指定的文件中获取一个字符”： 
ch = getc(fp); 

// 下面这条语句的意思是“从标准输出中打印一个字符”
putchar(ch);
// 下面语句的意思是“把字符ch放入FILE指针fpout指定的文件 中”：
putc(ch, fpout)
```

在 putc() 函数的参数列表中，第1个参数是待写入的字符，第2个参数是文件指针。 

如果把 stdout 作为 putc() 的第2个参数，则和 putchar(ch) 的作用相同。实际上，putchar() 函数一般通过 putc() 来定义。与此类似，getchar() 也通过使用标准输入的 getc() 来定义。

PS：stdout 作为与标准输出相关联的文件指针，定义在 stdio.h 中。

### 文件结尾

从文件中读取数据的程序在读到文件结尾时要停止。**如何告诉程序已经读到文件结尾**？如果 getc() 函数在读取一个字符时发现是文件结尾，它将返回一个特殊值 EOF。所以 C 程序只有在读到超过文件末尾时才会发现文件的结尾（一些其他语言用一个特殊的函数在读取之前测试文件结尾，C 语言不同）。

### fclose()

```c
int fclose(FILE *filename);
```

fclose(fp) 函数关闭 fp 指定的文件，必要时刷新缓冲区。对于较正式的程序，应该检查是否成功关闭文件。如果成功关闭，fclose() 函数返回 0，否则返回 EOF。 

```c
if (fclose(fp) != 0) 
	printf("Error in closing file %s\n", argv[1]); 
```

如果磁盘已满、移动硬盘被移除或出现 I/O 错误，都会导致调用 fclose() 函数失败。

### 指向标准文件的指针

stdio.h 头文件把3个文件指针与3个标准文件相关联，C 程序会自动打开这3个标准文件：

![](E:\Note\Code Language\the-c\picture\basic\7-3.png)

这些文件指针都是指向 FILE 的指针，所以它们可用作标准 I/O 函数的参数，如 fclose(fp) 中的 fp。

### 示例程序

```c
#include <stdio.h> 
#include <stdlib.h> // 提供 exit()的原型 
#include <string.h> // 提供 strcpy()、strcat()的原型 
#define LEN 40 
int main(int argc, char *argv []) 
{
    FILE *in, *out; // 声明两个指向 FILE 的指针 
    int ch; 
    char name[LEN]; // 储存输出文件名 
    int count = 0; 
	// 检查命令行参数 
    if (argc < 2) 
    {
        fprintf(stderr, "Usage: %s filename\n", argv[0]); 
        exit(EXIT_FAILURE); 
    }
    // 设置输入 
    if ((in = fopen(argv[1], "r")) == NULL) 
    {
        fprintf(stderr, "I couldn't open the file \"%s\"\n", 
        argv[1]); 
        exit(EXIT_FAILURE); 
    }
    // 设置输出 
    strncpy(name, argv[1], LEN - 5); // 拷贝文件名 
    name[LEN - 5] = '\0'; 
    strcat(name, ".red"); // 在文件名后添加.red 
    if ((out = fopen(name, "w")) == NULL) 
    { 
        // 以写模式打开文件 
        fprintf(stderr, "Can't create output file.\n"); 
        exit(3); 
    }
    // 拷贝数据 
    while ((ch = getc(in)) != EOF) 
    	if (count++ % 3 == 0) 
   			putc(ch, out);// 打印3个字符中的第1个字符 
    // 收尾工作 
    if (fclose(in) != 0 || fclose(out) != 0) 
    	fprintf(stderr, "Error in closing files\n"); 
    return 0; 
}
```

## 文件 IO 函数

### fopen()

#### 函数介绍

```c
// fopen() 函数原型，位于 <stdio.h> 头文件中
FILE* fopen(const char *filename, const char *mode);
```

**参数**：第1个参数是保存文件名的字符串，第2个参数是打开文件的模式。

**功能**：以指定的 mode 模式打开名为 filename 的文件，返回一个指向 FILE 结构的指针。

**返回**：指向指定文件的 FILE 对象的指针。

通常，**使用****标准 I/O 的第1步就是调用 fopen() 打开文件**。fopen() 函数不仅打开一个文件，还创建了一个缓冲区（在读写模式下会创建两个缓冲区）以及一个包含文件和缓冲区数据的结构 FILE。另外，fopen() 返回一个指向该结构的指针，以便其他函数知道如何找到该结构。假设把该指针赋给一个指针变量 fp，我们说 fopen() 函数“打开一个流”。如果以文本模式打开该文件，就获得一个文本流；如果以二进制模式打开该文件，就获得一个二进制流。

#### 文件打开模式

 r，即 read，表示读模式。以 r 模式打开文件时，如果文件不存在则报错。

w，即 write，表示写模式。以 w 模式打开文件时，如果文件不存在则新建文件；如果文件存在则将原有内容擦除，重新写入。

a，即 append，表示写模式。以 a 模式打开文件时，如果文件不存在则新建文件；如果文件存在则从文件末尾开始添加内容。

+，表示读写模式。例如，r+ 表示读写模式打开文件，如果文件不存在则报错。w+ 表示读写模式打开文件，如果文件不存在则新建文件，如果文件存在则将原有内容擦除，重新写入。

b，即 binary，表示二进制模式。

#### FILE 结构

这个结构通常包含一个指定流中当前位置的文件位置指示器。除此之外，它还包含错误和文件结尾的指示器、一个指向缓冲区开始处的指针、一个文件标识符和一个计数。

```c
struct _iobuf {
    char *_ptr; //文件输入的下一个位置
    int _cnt; //当前缓冲区的相对位置
    char *_base; //指基础位置(即是文件的其始位置)
    int _flag; //文件标志
    int _file; //文件的有效性验证
    int _charbuf; //检查缓冲区状况,如果无缓冲区则不读取
    int _bufsiz;
    char *_tmpfname; //临时文件名
};
```

### getc() 和 putc()

```c
// getc() 和 putc() 函数原型，位于 <stdio.h> 头文件中
int getc(FILE *filename);
int putc(int char, FILE *filename);
```

**getc() 参数**：FILE 指针。

**getc() 功能**：向指定文件中获取一个字符。

**getc() 返回**：字符。

<hr>

**putc() 参数**：第1个参数是需要输入的字符，第2个参数是指向需要输入字符的文件的指针。

**putc() 功能**：向指定文件中输入一个字符。

**putc() 返回**：如果发生错误返回 EOF。

### fprintf() 和 fscanf()

```c
// fprintf() 和 fscanf() 函数原型，位于 <stdio.h> 头文件中
int fprintf(FILE *stream, const char *format, ...);
int fscanf(FILE *stream, const char *format, ...)
```

fprintf() 和 fscanf() 的工作方式与 printf() 和 scanf() 类似。但是，与 putc() 不同的是，fprintf() 和 fscanf() 函数都把 FILE 指针作为第1个参数，而不是最后一个参数。

**fprintf() 返回**：如果成功，则返回写入的字符总数，否则返回一个负数。

**fscanf() 返回**：如果成功，该函数返回成功匹配和赋值的个数。如果到达文件末尾或发生读错误，则返回 EOF。

### fgets() 和 fputs()

**fgets() 参数**：第1个参数和 gets() 函数一样，也是表示储存输入位置的地址（char * 类型）；第2个参数是一个整数，表示待输入字符串的大小；最后一个参数是文件指针，指定待读取的文件。

**fgets() 函数**：从指定的流 stream 读取一行，并把它存储在 str 所指向的字符串内。当读取 (n-1) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。然后 fgets() 会在末尾添加一个空字符使其成为字符串。如果 fgets() 在读到字符上限之前已读完一整行，它会把表示行结尾的换行符放在空字符前面。

**fgets() 返回**：如果成功，该函数返回相同的 str 参数。如果到达文件末尾或者没有读取到任何字符，str 的内容保持不变，并返回一个空指针。如果发生错误，返回一个空指针。



**fputs() 参数**：第1个参数是字符串的地址；第2个参数是文件指针。 

**fputs() 函数**：把字符串写入到指定的流 stream 中，但不包括空字符。和 puts() 函数不同，fputs() 在打印字符串时不会在其末尾添加换行符。

**fputs() 返回**：该函数返回一个非负值，如果发生错误则返回 EOF。



由于 fgets() 保留了换行符，fputs() 就不会再添加换行符，它们配合得非常好。

### rewind()

```c
// <stdio.h>
void rewind(FILE *stream);
```

rewind 是倒回的意思。rewind() 功能：回到文件开头位置开始读取或写入。

### fseek()

```c
// <stdio.h>
int fseek(FILE *stream, long int offset, int whence);
```

**参数**：**第1个参数是指向待查找的文件**，fopen() 应该已打开该文件。**第2个参数是偏移量**(offset)，该参数表示从起始点开始要移动的距离，该参数必须是一个 long 类型的值，可以为正（前移）、负（后移）或 0（保持不动）。**第3个参数是模式**，该参数确定起始点。根据 ANSI 标准，在 <stdio.h> 头文件中规定了几个表示模式的明示常量(#define 定义的变量) —— SEEK_SET(0)、SEEK_CUR(1)、SEEK_END(2) ，这三个明示变量分别表示文件开始处、当前位置、文件末尾。

**功能**：可把文件看作是数组，在 fopen() 打开的文件中直接移动到指定的字节处。

**返回**：如果一切正常，fseek() 的返回值为 0；如果出现错误（如试图移动的距离超出文件的范围），其返回值为 -1。 

```c
fseek(fp, 0L, SEEK_SET); // 定位至文件开始处 
fseek(fp, 10L, SEEK_SET); // 定位至文件中的第10个字节 
fseek(fp, 2L, SEEK_CUR); // 从文件当前位置前移2个字节 
fseek(fp, 0L, SEEK_END); // 定位至文件结尾 
fseek(fp, -10L, SEEK_END); // 从文件结尾处回退10个字节 
```

### ftell()

```c
// <stdio.h>
long int ftell(FILE *stream);
```

**参数**：FILE 指针。

**功能**：返回当前位置。在最初实现的 UNIX 中，ftell() 通过返回距文件开始处的字节数来确定文件的位置。文件的第1个字节到文件开始处的距离是0，以此类推。ANSI C 规定，该定义适用于以二进制模式打开的文件，以文件模式打开文件的情况不同。

**返回**：该函数返回位置标识符的当前值。如果发生错误，则返回 -1L，全局变量 errno 被设置为一个正值。

ftell()- 函数在文本模式和二进制模式中的工作方式不同。许多系统的文本文件格式与 UNIX 的模型有很大不同，导致从文件开始处统计的字节数成为一个毫无意义的值。ANSI C 规定，对于文本模式，ftell() 返回的值可以作为 fseek() 的第2个参数。对于 MS-DOS，ftell() 返回的值把 \r\n 当作一个字节计数。

### fgetpos() 和 fsetpos()

fseek() 和 ftell() 函数智能处理文件大小在 long 类型能表示的范围内。也许20亿字节看起来相当大，但是随着存储设备的容量迅猛增长，文件也越来越大。鉴于此，ANSI C 新增了两个处理较大文件的新定位函数：fgetpos() 和 fsetpos()。

这两个函数不使用 long 类型的值表示位置，它们使用一种新类型：fpos_t（代表 file position type，文件定位类型）。fpos_t 类型不是基本类型，它根据其他类型来定义。fpos_t 类型的变量或数据对象可以在文件中指定一个位置，它不能是数组类型，除此之外，没有其他限制。

```c
int fgetpos(FILE * restrict stream, fpos_t * restrict pos); 
```

ANSI C 定义了如何使用 fpos_t 类型。调用该函数时，它把 fpos_t 类型的值放在 pos 指向的位置上，该值描述了文件中的一个位置。

**fgetpos() 返回**：如果成功，fgetpos() 函数返回0；如果失败，返回非0。 

```c
int fsetpos(FILE *stream, const fpos_t *pos); 
```

调用该函数时，使用 pos 指向位置上的 fpos_t 类型值来设置文件指针指向该值指定的位置。

**fsetpos() 返回**：如果成功，fsetpos()函数返回0；如果失败，则返回非0。 

PS：fpos_t 类型的值应通过之前调用 fgetpos() 获得。 

### fclose()

```c
// fclose() 函数原型，位于 <stdio.h> 头文件中
int fclose(FILE *filename);
```

功能：关闭 filename 指向的文件。

返回：如果关闭成功，则该方法返回 0。如果失败，则返回 EOF。

## 演示程序

> 该练习来自《C Primer Plus》第 985 页程序。

### 文件读写操作

接下来，我们用一个程序示例说明这些函数的用法。该程序把一系列文件中的内容附加在另一个文件的末尾。该程序存在一个问题：如何给文件传递信息。可以通过交互或使用命令行参数来完成，我们先采用交互式的方法。下面列出了程序的设计方案。 

询问目标文件的名称并打开它。使用一个循环询问源文件。 以读模式依次打开每个源文件，并将其添加到目标文件的末尾。 



为演示 setvbuf() 函数的用法，该程序将使用它指定一个不同的缓冲区大小。下一步是细化程序打开目标文件的步骤： 

1. 以附加模式打开目标文件； 
2. 如果打开失败，则退出程序； 
3. 为该文件创建一个4096字节的缓冲区； 
4. 如果创建失败，则退出程序。 



与此类似，通过以下具体步骤细化拷贝部分： 

1. 如果该文件与目标文件相同，则跳至下一个文件； 
2. 如果以读模式无法打开文件，则跳至下一个文件； 
3. 把文件内容添加至目标文件末尾。



最后，程序回到目标文件的开始处，显示当前整个文件的内容。作为练习，我们使用 fread() 和 fwrite() 函数进行拷贝。

```c
#include <stdio.h> 
#include <stdlib.h> 
#include <string.h> 
#define BUFSIZE 4096 
#define SLEN 81 
void append(FILE *source, FILE *dest); 
char * s_gets(char * st, int n); 
int main(void) 
{
    FILE *fa, *fs; // fa 指向目标文件，fs 指向源文件 
    int files = 0; // 附加的文件数量 
    char file_app[SLEN]; // 目标文件名 
    char file_src[SLEN]; // 源文件名 
    int ch; 
    puts("Enter name of destination file:"); 
    s_gets(file_app, SLEN); 
    if ((fa = fopen(file_app, "a+")) == NULL) 
    {
        fprintf(stderr, "Can't open %s\n", file_app); 
        exit(EXIT_FAILURE); 
    }
    if (setvbuf(fa, NULL, _IOFBF, BUFSIZE) != 0) 
    {
        fputs("Can't create output buffer\n", stderr); 
        exit(EXIT_FAILURE); 
    }
    puts("Enter name of first source file (empty line to quit):"); 
    while (s_gets(file_src, SLEN) && file_src[0] != '\0') 
    {
        if (strcmp(file_src, file_app) == 0) 
        	fputs("Can't append file to itself\n", stderr); 
        else if ((fs = fopen(file_src, "r")) == NULL) 
        	fprintf(stderr, "Can't open %s\n", file_src); 
   		else 
        {
            if (setvbuf(fs, NULL, _IOFBF, BUFSIZE) != 0) 
            {
                fputs("Can't create input buffer\n", stderr); 
                continue; 
            }
        	append(fs, fa); 
            if (ferror(fs) != 0) 
            	fprintf(stderr, "Error in reading file %s.\n",file_src); 
        	if (ferror(fa) != 0) 
                fprintf(stderr, "Error in writing file %s.\n", file_app); 
            fclose(fs); 
            files++; 
            printf("File %s appended.\n", file_src); 
            puts("Next file (empty line to quit):"); 
        } 
    }
    printf("Done appending.%d files appended.\n", files); 
    rewind(fa); 
    printf("%s contents:\n", file_app); 
    while ((ch = getc(fa)) != EOF) 
   		putchar(ch); 
    puts("Done displaying."); 
    fclose(fa); 
    return 0; 
}
void append(FILE *source, FILE *dest) 
{
    size_t bytes; 
    static char temp[BUFSIZE]; // 只分配一次 
    while ((bytes = fread(temp, sizeof(char), BUFSIZE, source)) > 0) 
        fwrite(temp, sizeof(char), bytes, dest); 
}
char * s_gets(char * st, int n) 
{ 
    char * ret_val; 
    char * find; 
    ret_val = fgets(st, n, stdin); 
    if (ret_val) 
    {
        find = strchr(st, '\n'); // 查找换行符 
        if (find) // 如果地址不是NULL， 
        	*find = '\0'; // 在此处放置一个空字符 
        else 
        	while (getchar() != '\n') continue; 
    }
    return ret_val; 
}
```

### 二进制 IO 随机访问

随机访问是用二进制I/O写入二进制文件最常用的方式，我们来看一个简短的例子。

```c
#include <stdio.h> 
#include <stdlib.h> 
#define ARSIZE 1000 
int main() 
{
    double numbers[ARSIZE]; 
    double value; 
    const char * file = "numbers.dat"; 
    int i; 
    long pos; 
    FILE *iofile; 
    // 创建一组 double类型的值 
    for (i = 0; i < ARSIZE; i++) 
    	numbers[i] = 100.0 * i + 1.0 / (i + 1); 
    // 尝试打开文件
    if ((iofile = fopen(file, "wb")) == NULL) 
    {
        fprintf(stderr, "Could not open %s for output.\n", file); 
        exit(EXIT_FAILURE); 
    }
    // 以二进制格式把数组写入文件 
    fwrite(numbers, sizeof(double), ARSIZE, iofile); 
    fclose(iofile); 
    if ((iofile = fopen(file, "rb")) == NULL) 
    {
        fprintf(stderr, "Could not open %s for random access.\n", file); 
        exit(EXIT_FAILURE); 
    }
    // 从文件中读取选定的内容 
    printf("Enter an index in the range 0-%d.\n", ARSIZE - 1); 
    while (scanf("%d", &i) == 1 && i >= 0 && i < ARSIZE) 
    {
    	pos = (long) i * sizeof(double); // 计算偏移量
        fseek(iofile, pos, SEEK_SET); // 定位到此处 
        fread(&value, sizeof(double), 1, iofile); 
        printf("The value there is %f.\n", value); 
        printf("Next index (out of range to quit):\n"); 
    }
    // 完成 
    fclose(iofile); 
    puts("Bye!"); 
    return 0; 
}
```

# Unit 8. 位操作

## 位运算符及应用

按位运算符分为按位逻辑运算符和位移运算符。

### 位逻辑运算符介绍

按位逻辑运算符有按位与(&)、按位或(|)、按位异或(^)、按位取反(~)，除了按位取反(~)运算符的优先级比较高(PS：低于()、[]、.)之外，其他三个按位逻辑运算符的优先级都比较低(PS：低于关系运算符，高于逻辑运算符)。

之所以称这四个运算符为按位逻辑运算符，是因为这些操作是对整数的每一个位进行操作，而不是整个值进行操作，这一点要和逻辑运算符区分开。

#### 按位取反(~)

一元运算符 ~ 对整数的每一位将1变为0，0变为1。

```c
// 表达式
~(1001 1010)
// 结果值
(0110 0101)
```

按位取反运算符常用于求二进制反码。

#### 按位与(&)

按位与运算符 & 逐位比较两个运算对象的每一位，生成新的值。对于每个位，只有两个运算符对象的相应位都为 1 时，结果才为1 (从真假来看，**都真才真**)。

```c
// 表达式
(1001 0011) & (0011 1101)
// 结果
(0001 0001)
// 所有的运算结果
0 & 0 == 0
0 & 1 == 0
1 & 0 == 0
1 & 1 == 1
```

从运算结果中，我们可以得到以下的性质。
**性质：** 假设 b 是某个二进制值的某位。
1. **任意位和 1 做 & 运算的结果是它本身，即 b & 1 = b**。
2. **任意位和 0 做 & 运算的结果是 0，即 b & 0 = 0**。

利用上面的性质，我们可以用 & 运算符来关闭指定位(将指定位设置为 0，其他位不变)，详情见应用。

#### 按位或(|)

按位或运算符 | 逐位比较两个运算对象的每一位，生成新的值。对于每个位，只有两个运算符对象的相应位都为 0 时，结果才为0 (从真假来看，**都假才假**)。

```c
// 表达式
(1001 0011) | (0011 1101)
// 结果值
(1011 1111)
// 所有的运算结果
0 | 0 == 0
0 | 1 == 1
1 | 0 == 1
1 | 1 == 1
```

从运算结果中，我们可以得到以下的性质。
**性质：** 假设 b 是某个二进制值的某位。
  1. **任意位和 1 做 | 运算的结果是 1，即 b | 1 = 1**。
  2. **任意位和 0 做 | 运算的结果是它本身，即 b | 0 = b**。

利用上面的性质，我们可以用 | 运算符来打开指定位(将指定为设置为1，其他位不变)，详情见应用。

#### 按位异或(^)

按位异或运算符 ^ 逐位比较两个运算对象的每一位，生成新的值。对于每个位，只有两个运算符对象的相应位不同时，结果才为1 (从真假来看，**不同时为真或者不同时为假结果才为真**)。

```c
// 表达式
(1001 0011) ^ (0011 1101)
// 结果
(1010 1110)
// 所有的运算结果
0 ^ 0 == 0
0 ^ 1 == 1
1 ^ 0 == 1
1 ^ 1 == 0
```

从运算结果中，我们可以得到以下的性质。
**性质：** 假设 b 是某个二进制值的某位。
  1. **任意位和 1 做 ^ 运算的结果是该位取反，即 b ^ 1 = ~b**。
  2. **任意位和 0 做 ^ 运算的结果是本身，即 b ^ 0 = b**。

利用上面的性质，我们可以用 & 运算符来切换指定位(将指定位取反，其他位不变)，详情见应用。

### 位逻辑运算符应用

#### 掩码(& 应用)

所谓掩码指的是一些设置为开(1)或者关(0)的位组合。我们先看一下通过 & 把一个量与掩码结合后会如何。例如，假设定义一个符号常量 MASK 为 2 (即， 0000 0010)。那么，flags = flags & MASK 会将 flags 中除 1 号位之外的所有位都设置为 0。

![](E:\Note\Code Language\the-c\picture\basic\8-1.png)

所以掩码和 & 运算符结合就是将 flags 对应掩码为0的位掩埋起来(设置位0)，因为我们不需要这些位的值，只关注掩码中值为1的位。

用途：假设我们用1个8位二进制数的每个位代表一个状态，1表示开启，0表示关闭，比如 1001 0101，而我们在操作的过程中可能只关注某一部分状态是否正确，而其他状态不需要关注，这时候就可以用掩码对不需要关注的位进行屏蔽，这样更容易法进行操作。

例如，flags 中 1 号位表示可写，检查 flags 变量是否表示可写，不能直接比较 flags 和 MASK `if (flags == MASK)` 这样的话，flags 为 0000 0011，1 号位是1，但是判断条件依旧为 false。应该先使用掩码将无关位屏蔽，再进行判断，即 `if ((flags & MASK) == MASK)`。

> 掩码在网络中应用很常见，子网掩码。

#### 打开指定位(设置位，| 应用)

利用 | 运算符的性质，我们可以在不改变其他位的情况下，将指定位设置为 1。

假设现在有一个 flags 值为 0000 1111，希望将其1、2、4、5、7号为设置为 1，其他位不变，所以 MASK 为 1011 0110。

```c
// 表达式 flags | MASK
(0000 1111) | (1011 0110)
// 结果值
（1011 1111）
```

#### 关闭指定位(清空位，& 应用)

利用 & 运算符的性质，我们可以在不改变其他位的情况下，将指定位设置为 0。

假设现在有一个 flags 值为 0000 1111，希望将其1、2、4、5、7号为设置为 0，其他位不变，所以 MASK 为 0100 1001。

```c
// 表达式 flags & MASK
(0000 1111) & (0100 1001)
// 结果值
（0000 1001）
```

> PS：也可以将 MASK 设为 1011 0110，利用 ~ 取反，在用 & 运算。

#### 切换指定位(切换位，^ 应用)

利用 ^ 运算符的性质，我们可以在不改变其他位的情况下，将指定位进行切换，即 0 变为 1，1 变为 0。

假设现在有一个 flags 值为 0000 1111，希望切换其1、2、4、5、7号的值，其他位不变，所以 MASK 为 1011 0110。

```c
// 表达式 flags ^ MASK
(0000 1111) ^ (1011 0110)
// 结果值
（1011 1001）
```

### 位移运算符

位移逻辑运算符有左移(<<)、右移(>>)、无符号右移(>>>)，其优先级低于算术运算符，高于关系运算符。

#### 左移运算符 <<

左移运算符将左侧运算对象每一位的值向左移动其右侧运算对象指定的位数。左侧运算对象移出左末端位的值丢失，用 0 填充空位。

```c
// 表达式
(1000 1010) << 2
// 结果值
(0010 1000)
```

#### 右移运算符 >>

右移运算符将左侧运算对象每一位的值向右移动其右侧运算对象指定的位数。左侧运算对象移出右末端位的值丢失。对于无符号类型，用 0 填充空出位置。对于有符号类型，取决于机器，空出位置可以用 0 填充，或者用符号位。

### 位移运算符应用

位移运算符可以针对 2 的幂提供快速有效的乘除法。

## 位字段

操作位的方法除了位运算符之外，第2种方法是位字段。位字段是一个 signed int 或 unsigned int 类型变量中的一组相邻的位。C99 和 C11 新增了 _Bool 类型的位字段。

位字段通过一个结构声明来建立，该结构声明为每个字段提供标签，并确定该字段的宽度。

```c
struct { 
    unsigned int autfd : 1; 
    unsigned int bldfc : 1; 
    unsigned int undln : 1; 
    unsigned int itals : 1; 
} prnt;
```

根据该声明，prnt 包含4个1位的字段。现在，可以通过普通的结构成员运算符(.)单独给这些字段赋值：

```c
prnt.itals = 0; 
prnt.undln = 1;
```

由于每个字段恰好为1位，所以只能为其赋值1或0。变量 prnt 被储存在一个 int 大小的内存单元中，但是在本例中只使用了其中的4位。



带有位字段的结构提供一种记录设置的方便途径。许多设置就是简单的二选一。例如，开或关、真或假、字体的粗体或斜。如果只需要使用 1 位，就不需要使用整个变量。内含位字段的结构允许在一个存储单元中储存多个设置。有时，某些设置也有多个选择，因此需要多位来表示。这没问题，字段不限制 1 位大小。

```c
struct { 
    unsigned int code1 : 2; 
    unsigned int code2 : 2; 
    unsigned int code3 : 8; 
} prcode;
```

以上代码创建了两个2位的字段和一个8位的字段。可以这样赋值：

```c
prcode.code1 = 0; 
prcode.code2 = 3; 
prcode.code3 = 102;
```

但是，要确保所赋的值不超出字段可容纳的范围。



**如果声明的总位数超过了一个 unsigned int 类型的大小会怎样**？

会用到下一个 unsigned int 类型的存储位置。**一个字段不允许跨越两个 unsigned int 之间的边界。编译器会自动移动跨界的字段，保持 unsigned int 的边界对齐**。一旦发生这种情况，第1个 unsigned int 中会留下一个未命名的“洞”。 **可以用未命名的字段宽度“填充”未命名的“洞”**。**使用一个宽度为 0 的未命名字段迫使下一个字段与下一个整数对齐**。

```c
struct { 
    unsigned int field1 : 1 ; 
    unsigned int : 2 ; 
    unsigned int field2 : 1 ; 
    unsigned int : 0 ; 
    unsigned int field3 : 1 ; 
} stuff; 
```

这里，在 stuff.field1 和 stuff.field2 之间，有一个 2 位的空隙；stuff.field3 将储存在下一个unsigned int中。 



字段储存在一个 int 中的顺序取决于机器。在有些机器上，存储的顺序是从左往右，而在另一些机器上，是从右往左。另外，不同的机器中两个字段边界的位置也有区别。由于这些原因，**位字段通常都不容易移植**。尽管如此，有些情况却要用到这种不可移植的特性。例如，以特定硬件设备所用的形式储存数据。

# Unit 9. 预处理器与C库

## C 代码如何变成可执行程序？

C 语言源文件需要经过编译、链接才会变成可直接运行的可执行文件。

### 编译过程

C 语言的源文件需要经过编译转换成供链接过程使用的目标文件，而编译过程分为以下三步：

- 翻译处理
- 预处理
- 源码解析

#### 第一步：翻译处理

C 语言的源文件需要经过编译转换成供链接过程使用的目标文件。

在预处理之前，编译器必须对该程序进行一些翻译处理。翻译过程的工作主要有以下三个：

1. 1. 编译器把源代码中出现的字符映射到源字符集。该过程是为了处理**多字节字符**和**三字符序列。**
   2. 编译器定位每个反斜杠后面跟着换行符的实例，并删除它们。也就是说，这个过程会把物理行转换成逻辑行。
   3. 编译器把文本划分成预处理记号序列、空白序列和注释序列。编译器将用一个空格字符替换每一条注释。

注意，在第2条中“换行符”的意思是通过按下 Enter 键在源代码文件中换行所生成的字符，而不是指符号表征 \n 

由于预处理表达式的长度必须是一个逻辑行，所以这一步为预处理器做好了准备工作。一个逻辑行可以是多个物理行。 

```c
// 两个物理行
printf("That's wond\ 
	erful!\n");
// 编译器会将其转换成的逻辑行
// printf("That's wonderful\n!");
```

#### 第二步：预处理

完成翻译处理之后，程序已经准备好进入预处理阶段，预处理器查找一行中以 # 号开始的预处理指令。

在这个阶段中，预处理器在源代码上执行一些文本操作。例如，用实际值代替由 #define 指令定义的符号以及读入由 #include 指令包含的文件的内容。

#### 第三步：源码解析

在这个阶段是产生绝大多数错误和警告信息的地方(运行阶段是另一个产生错误的阶段)。这个阶段会生成链接过程中需要的目标文件。

### 链接过程

将编译过程生成的各个目标代码文件由**链接器链接**在一起，形成一个单一完整的可执行程序。链接器同时也会引入标准 C 函数库中任何被该程序所用到的函数，而且它也可以搜索程序员个人的程序库，将其中需要使用的函数也链接到程序中。

### 执行程序

1. **运行可执行程序。**
2. **将程序载入内存中**。
3. **程序开始执行**。
4. **程序的终止**。

## 预处理指令

### 宏定义指令：#define

预处理指令可以出现在源文件的任何地方。

变量有作用域，#define 定义的明示常量同样有其作用区域，其定义从指令出现的地方到该文件末尾或者 #undef 命令之间有效。



#define 指令最常见的用法就是用来定义明示常量(也叫做符号常量)，但是该指令还有许多其他用途。

**用法**：`#define 标识符 常量`。注意后面没有分号！！

\#define 又称**宏定义**，标识符是所定义的宏名，简称宏。标识符的命名规则遵守 C 语言的标识符命名规则，不过通常采用大写字母来命名宏，以此提醒程序员注意。#define 的功能是将标识符定义为其后的常量。

#### 明示常量(符号常量)

C 语言中，可以用 #define 定义一个标识符来表示一个常量。其特点是：定义的标识符不占内存，只是一个临时的符号，预编译后这个符号就不存在了。因此这种常量也叫做符号常量。

```c
// 例1.
#include<stdio.h>
#define A1 300
#define S1 "Hello, World"
int main()
{
    const int a2 = 100;
    cosnt char* s2 = "hello, world";
    printf("%d\n%s\n", A1, S1);
    printf("%d\n%s\n", a2, s2);
    return 0;
}
```

对于绝大部分数字常量，应该使用字符常量。如果在算式中用字符常量代替数字，常量名能更清楚地表达该数字的含义。如果是表示数组大小的数字，用符号常量后更容易改变数组的大小和循环次数。如果数字是系统代码（如，EOF），用符号常量表示的代码更容易移植（只需改变EOF的定义）。助记、易更改、可移植，这些都是符号常量很有价值的特性。 

> C 语言现在也支持 const 关键字，提供了更灵活的方法。用 const 可以创建在程序运行过程中不能改变的变量，可具有文件作用域或块作用域。另一方面，宏常量可用于指定标准数组的大小和 const 变量的初始值。



**#define 声明明示常量最常考察的就是在预处理阶段只会进行文本替换，不进行计算**。

对于最后一条，**预处理指令定义的标识符都不会占据内存**。预处理指令也称预编译指令，即在编译之前进行一些处理，而预处理做的其实就是文本替换，这个过程也叫做宏展开，即用宏定义后面的替换体将程序中出现宏的地方替换掉。例如，#define 定义的明示变量就是在预处理阶段用标识符后面的值替换标识符，因此不会占据内存。例如，上面程序中将在预处理阶段将 `printf("%d\n%s\n", A1, S1);` 替换成 `printf("%d\n%s\n", 300, "Hello, World");` 

在这个文本替换过程中需要注意的一点是，**#define 只执行文本替换，不执行计算**！这个考点在各种笔试中都经常碰到。例如：

```c
// 例2.
#include<stdio.h>
#define SUM 3+4 
int main()
{
    int a = SUM * SUM;
    printf("%d\n", a);
    return 0;
}
```

例2. 运行结果是 19，而不是 49。因为预处理阶段预处理器将 SUM 替换成 3+4，经过预处理之后的程序为 `int a = 3 + 4 * 3 + 4;`，在运行阶段程序才进行计算，此时根据运算符优先级，先算 * 的部分，因此 a 的值为 3+12+4，即 19。 

#### 定义符号常量的易错点

```c
// 例3.
#include<stdio.h>
#define PI 3.14;
int main()
{
    double r = 4.3;
    double s = PI * r * r;
    printf("%lf\n", s);
    return 0;
}
```

例3. 会在 `PI * r` 处报错，错误描述为：`"*" 的操作数必须是指针，但它具有类型 "double"`。这时候是不是很纳闷为什么作为乘法运算符会被识别为指针的解引用？原因在于 PI 宏定义中多加了分号！在预处理阶段例3. 中的 `double s = PI * r * r;` 会被替换成 `double s = 3.14; * r * r;` 这下就能明白为什么会被识别为解引用运算符了吧。

#### 宏定义和 const 常量的区别

1. 定义的区别：
   a. 明示变量用 `#define` 声明，而 const 常量用 `const + 数据类型` 声明。
   b. 明示变量最后没用分号，const 常量声明需要用分号表示语句结束。
   c. 明示变量不需要用等号赋值，cosnt 常量需要用等号赋值。
   d. 明示变量不占内存，cosnt 常量需要占据内存。
1. 处理阶段阶段的不同：
   a. 宏定义在预处理阶段进行文本替换。
   b. cost 常量在程序运行时使用。
1. 存储方式不同：
   a. 宏定义是直接替换，不会分配内存，存储于程序的代码段中。
   b. const 常量需要进行内存分配。
1. 是否进行类型检查：
   a. 宏定义是字符替换，不进行类型检查。
   b. const 常量定义时需要声明数据类型，使用时会进行类型检测。
1. 宏定义可以声明函数。

#### 宏函数介绍

前面介绍了明示常量(宏定义)，其实宏定义除了定义常量之外还可以定义宏函数。在 #define 中使用参数可以创建外形和作用与函数类似的类函数宏。带有参数的宏看上去很像函数，因为这样的宏也使用圆括号。类函数宏定义的圆括号中可以有一个或多个参数，随后这些参数出现在替换体中。

![](E:\Note\Code Language\the-c\picture\basic\8-2.png)

```c
// 例4. 
// 宏函数定义
#define SQUARE(X) X*X 
// 在程序中使用：
z = SQUARE(2); // 结果：z = 4;
```

例4. 看上去像函数调用，但是它的行为和函数调用完全不同。

```c
例5.
#define SQUARE(X) X*X
int t = 4;
x = SQUARE(t);  // result: x = 16
y = SQUARE(t+2);// result: y = 14
```

例5. 演示了宏函数和函数调用的不同，`y = SQUARE(t+2)` 在预处理阶段被替换为 `y = t + 2 * t + 2`，因此 y 的值为 14。如果想要避免这样情况，需要在宏定义时多加几个括号来确保运算和结合的正确顺序。

```c
#define SQUARE(X) ((X)*(X))
```

替换体最外面的括号是为了避免诸如 `100/SQUARE(4)` 这样的情况下运算顺序。如果不加最外面的括号，在预处理阶段替换之后就变成了 `100/(4)*(4)`，会先算 100/4，再将结果×4。



尽管如此，这样做还是无法避免程序中最后一种情况的问题 —— SQUARE(++x) 变成了 ++x\*++x，递增了两次x，一次在乘法运算之前，一次在乘法运算之后：++x*++x = 6*7 = 42。由于标准并未对这类运算规定顺序，所以有些编译器得 7\*6。而有些编译器可能在乘法运算之前已经递增了x，所以7\*7得49。

解决这个问题最简单的方法是，避免用++x 作为宏参数。一般而言，**不要在宏中使用递增或递减运算符**。

#### 宏函数字符串中的宏参数：#

```c
// 例6. 
#define PSQR(X) printf("The square of X is %d.\n", ((X)*(X))); 
PSQR(8); // 输出为： The square of X is 64. 
```

注意双引号字符串中的 X 被视为普通文本，而不是一个可被替换的记号。**C 允许在字符串中包含宏参数**。在类函数宏的替换体中，# 号作为一个预处理运算符，可以把记号转换成字符串。例如，如果 x 是一个宏形参，那 

么 #x 就是转换为字符串"x"的形参名，这个过程称为字符串化。 

```c
#define PSQR(X) printf("The square of " #X " is %d.\n", ((X)*(X)));
int y = 8;
PSQR(y); // 输出为： The square of y is 64. 
```

调用宏函数的时候，用 "y" 替换 #x，`printf("The square of " "y" " is %d.\n", ((y)*(y)));`，然后利用 ANSI C 字符串的串联特性将这些字符串组合起来，`printf("The square of y is %d.\n", ((y)*(y)));`

#### 宏函数的预处理器粘合剂：##

与 # 运算符类似，## 运算符可用于类函数宏的替换部分。而且，## 还可用于对象宏的替换部分。## 运算符把两个记号组合成一个记号。例如，可以这样做：

```c
#define XNAME(n) x ## n 
```

然后，宏 XNAME(4) 将展开为 x4。

```c
#include <stdio.h> 
#define XNAME(n) x ## n 
#define PRINT_XN(n) printf("x" #n " = %d\n", x ## n); 
int main(void) 
{
    int XNAME(1) = 14; // 变成 int x1 = 14; 
    int XNAME(2) = 20; // 变成 int x2 = 20; 
    int x3 = 30; 
    PRINT_XN(1); // 变成 printf("x1 = %d\n", x1); 
    PRINT_XN(2); // 变成 printf("x2 = %d\n", x2); 
    PRINT_XN(3); // 变成 printf("x3 = %d\n", x3); 
    return 0; 
}
// 该程序的输出如下： x1 = 14 x2 = 20 x3 = 30
```

PRINT_XN() 宏用 # 运算符组合字符串，## 运算符把记号组合为一个新的标识符。

#### 变参宏：...和\_VA\_ARGS\_\_

C99/C11 对宏提供了变参的工具。虽然标准中未使用“可变”这个词，但是它已成为描述这种工具的通用词（虽然，C 标准的索引添加了字符串化词条，但是，标准并未把固定参数的函数或宏称为固定函数和不变宏）。



变参宏通过把宏参数列表中最后的参数写成省略号（即，3个点...）来实现这一功能。而 __VA_ARGS*__*可用在替换部分中，表明省略号代表什么。

```c
#include <stdio.h> 
#include <math.h> 

#define PR(X, ...) printf("Message " #X ": " __VA_ARGS__) 
int main(void) 
{
	double x = 48
    double y; 
    y = sqrt(x); 
    PR(1, "x = %g\n", x); 
    PR(2, "x = %.2f, y = %.4f\n", x, y); 
    return 0; 
}
// 输出结果：
// Message 1: x = 48
// Message 2: x = 48.00, y = 6.9282
```

记住，省略号只能代替最后的宏参数 

```c
#define WRONG(X, ..., Y) #X #_ _VA_ARGS_ _ #y //不能这样做
```

#### 宏函数和函数的选择

有些编程任务既可以用带参数的宏完成，也可以用函数完成。**应该使用宏还是函数**？

使用宏比使用普通函数复杂一些，稍有不慎会产生奇怪的副作用。



宏和函数的选择实际上是时间和空间的权衡。宏生成内联代码，即在程序中生成语句。如果调用20次宏，即在程序中插入20行代码。如果调用函数20次，程序中只有一份函数语句的副本，所以节省了空间。然而另一方面，程序的控制必须跳转至函数内，随后再返回主调程序，这显然比内联代码花费更多的时间。 因此，对于简单的函数，程序员通常用宏来处理。

C99 提供了第3种可替换的方法——**内联函数**。



在使用宏函数时，依旧推荐使用大写字母表示宏，以此来提醒程序员宏带来的副作用。



如果打算使用宏来加快程序的运行速度，那么首先要确定使用宏和使用函数是否会导致较大差异。在程序中只使用一次的宏无法明显减少程序的运行时间。在嵌套循环中使用宏更有助于提高效率。许多系统提供程序分析器以帮助程序员压缩程序中最耗时的部分。

### 文件包含指令：#include

#### 介绍

当预处理器发现 #include 指令时，会查看后面的文件名并把文件的内容包含到当前文件中，即替换源文件中的 #include 指令。这相当于把被包含文件的全部内容输入到源文件 #include 指令所在的位置。\#include 指令有两种形式：

```c
#include <stdio.h>   // 文件名在尖括号中 
#include "mystuff.h" // 文件名在双引号中
```

在 UNIX 系统中，**尖括号告诉预处理器在标准系统目录中查找该文件**。**双引号告诉预处理器首先在当前目录中（或文件名中指定的其他目录）查找该文件，如果未找到再查找标准系统目录**。

```c
#include <stdio.h>       // 查找系统目录 
#include "hot.h"         // 查找当前工作目录 
#include "/usr/biff/p.h" // 查找/usr/biff目录 
```

集成开发环境（IDE）也有标准路径或系统头文件的路径。许多集成开发环境提供菜单选项，指定用尖括号时的查找路径。在 UNIX 中，使用双引号意味着先查找本地目录，但是具体查找哪个目录取决于编译器的设定。有些编译器会搜索源代码文件所在的目录，有些编译器则搜索当前的工作目录，还有些搜索项目文件所在的目录。

ANSI C 不为文件提供统一的目录模型，因为不同的计算机所用的系统不同。一般而言，命名文件的方法因系统而异，但是尖括号和双引号的规则与系统无关。 



**为什么要包含文件**？因为编译器需要这些文件中的信息。例如，<stdio.h> 文件中通常包含 EOF、NULL、getchar() 和 putchar() 的定义。getchar() 和 putchar() 被定义为宏函数。此外，该文件中还包含 C 的其他 I/O 函数。 

C语言习惯用 .h 后缀表示头文件，这些文件包含需要放在程序顶部的信息。头文件经常包含一些预处理器指令。有些头文件（如stdio.h）由系统提供，当然你也可以创建自己的头文件。包含一个大型头文件不一定显著增加程序的大小。在大部分情况下，头文件的内容是编译器生成最终代码时所需的信息，而不是添加到最终代码中的材料。

#### 头文件的使用

浏览任何一个标准头文件都可以了解头文件的基本信息。头文件中最常用的形式如下。 

**明示常量** —— 例如，stdio.h 中定义的 EOF、NULL 和 BUFSIZE（标准 I/O 缓冲区大小）。 

**宏函数** —— 例如，getc(stdin) 通常用 getchar() 定义，而 getc() 经常用于定义较复杂的宏，头文件 ctype.h 通常包含 ctype 系列函数的宏定义。

**函数声明**——例如，string.h 头文件（一些旧的系统中是 strings.h）包含字符串函数系列的函数声明。在 ANSI C 和后面的标准中，函数声明都是函数原型形式。 

**结构模版定义** —— 例如，标准 I/O 函数使用 FILE 结构，该结构中包含了文件和与文件缓冲区相关的信息。FILE 结构在头文件 stdio.h 中。

类型定义 —— 例如，标准 I/O 函数使用指向 FILE 的指针作为参数。通常，stdio.h 用 #define 或 typedef 把 FILE 定义为指向结构的指针。类似地，size_t 和 time_t 类型也定义在头文件中。



**许多程序员都在程序中使用自己开发的标准头文件。如果开发一系列相关的函数或结构，那么这种方法特别有价值**。 



另外，还可以使用头文件声明外部变量供其他文件共享。例如，如果已经开发了共享某个变量的一系列函数，该变量报告某种状况（如，错误情况），这种方法就很有效。这种情况下，可以在包含这些函数声明的源代码文件定义一个文件作用域的外部链接变量。

```c
// 该变量具有文件作用域
int status = 0; // 在源代码文件 
// 可以在与源代码文件相关联的头文件中进行引用式声明： 
extern int status; // 在头文件中 
```

这行代码会出现在包含了该头文件的文件中，这样使用该系列函数的文件都能使用这个变量。虽然源代码文件中包含该头文件后也包含了该声明，但是只要声明的类型一致，在一个文件中同时使用定义式声明和引用式声明没问题。

需要包含头文件的另一种情况是，使用具有文件作用域、内部链接和 const 限定符的变量或数组。const 防止值被意外修改，static 意味着每个包含该头文件的文件都获得一份副本。因此，不需要在一个文件中进行定义式声明，在其他文件中进行引用式声明。 

\#include 和 #define 指令是最常用的两个 C 预处理器特性。

#### 疑问

\#include 包含的头文件在只会在链接使用到的函数声明和定义吗？没有用到的函数声明和定义不会链接？

### 其他指令

程序员可能要为不同的工作环境准备 C 程序和 C 库包。不同的环境可能使用不同的代码类型。预处理器提供一些指令，程序员通过修改 #define 的值即可生成可移植的代码。#undef 指令取消之前的 #define 定义。#ifdef、#ifndef、#else、#endif、#if 和 #elif 指令用于条件编译，即指定什么情况下编写哪些代码。#line 指令用于重置行和文件信息，#error 指令用于给出错误消息，#pragma 指令用于向编译器发出指令。

####  #undef 指令

#undef 指令用于“取消”已定义的 #define 指令。也就是说，假设有如下定义：

```c
#define LIMIT 400
```

然后，下面的指令将移除上面的定义：

```c
#undef LIMIT
```

 现在就可以把 LIMIT 重新定义为一个新值。即使原来没有定义 LIMIT，取消 LIMIT 的定义仍然有效。



如果想使用一个名称，又不确定之前是否已经用过，为安全起见，可以用 #undef 指令取消该名字的定义。需要注意的是，这里的定义指的是由预处理器定义的，因此像 `int q;` 这种不是宏的变量定义对预处理器来说是未定义的。

#### 条件编译指令 —— #ifdef、#ifndef、#else、#endif

可以使用其他指令创建条件编译（conditinal compilation）。也就是说，可以使用这些指令告诉编译器根据编译时的条件执行或忽略信息（或代码）块。

```c
#ifdef MAVIS 
    #include "horse.h" // 如果已经用#define定义了 MAVIS，则执行下面的指令 
    #define STABLES 5 
#else 
    #include "cow.h" //如果没有用#define定义 MAVIS，则执行下面的指令
    #define STABLES 15 
#endif 
```

\#ifdef 指令说明，如果预处理器已定义了后面的标识符（MAVIS），则执行 #else 或 #endif 指令之前的所有指令并编译所有 C 代码（先出现哪个指令就执行到哪里）。如果预处理器未定义 MAVIS，且有 #else 指令，则执行 #else 和 #endif 指令之间的所有代码。 

\#ifdef #else 很像 C 的 if else。两者的主要区别是，预处理器不识别用于标记块的花括号（{}），因此它使用 #else（如果需要）和 #endif（必须存在）来标记指令块。这些指令结构可以嵌套，也可以用这些指令标记 C 语句块。

\#ifndef 指令与 #ifdef 指令的用法类似，也可以和 #else、#endif 一起使用，但是它们的逻辑相反。#ifndef 指令判断后面的标识符是否是未定义的，常用于定义之前未定义的常量。

\#ifndef 的作用：

1. \#ifndef 指令可以防止相同的宏被重复定义。在首次定义一个宏的头文件中用 #ifndef 指令激活定义，随后在其他头文件中的定义都被忽略。
2. \#ifndef 指令通常用于防止多次包含一个文件。也就是说，应该像下面这样设置头文件： 

```c
/* things.h 文件中*/ 
#ifndef THINGS_H_ 
#define THINGS_H_ 
	/* 省略了头文件中的其他内容*/
#endif 
```

假设该文件被包含了多次。当预处理器首次发现该文件被包含时，THINGS*H*是未定义的，所以定义了 THINGS_H_，并接着处理该文件的其他内容。当预处理器第2次发现该文件被包含时，THINGS_H_是已定义的， 

所以预处理器跳过了该文件的其他部分。

**为何要多次包含一个文件**？最常见的原因是，许多被包含的文件中都包含着其他文件，所以显式包含的文件中可能包含着已经包含的其他文件。

**这有什么问题**？在被包含的文件中有某些项（如，一些结构类型的声明）只能在一个文件中出现一次。C 标准头文件使用 #ifndef 技巧避免重复包含。

但是，这存在一个问题：**如何确保待测试的标识符没有在别处定义**？通常，实现的供应商使用这些方法解决这个问题：用文件名作为标识符、使用大写字母、用下划线字符代替文件名中的点字符、用下划线字符做前缀或后缀（可能使用两条下划线）。

例如，查看 stdio.h 头文件，可以发现许多类似的代码：

```c
#ifndef _STDIO_H 
#define _STDIO_H 
	// 省略了文件的内容 
#endif 
```

#### 条件编译指令 —— #if 和 #elif 指令

\#if 指令很像 C 语言中的 if。#if 后面跟整型常量表达式，如果表达式为非零，则表达式为真。可以在指令中使用 C 的关系运算符和逻辑运算符： 

```c
#if SYS == 1 
#include "ibm.h" 
#endif
```

可以按照 if else 的形式使用 #elif（早期的实现不支持 #elif）。

```c
#if SYS == 1 
	#include "ibmpc.h" 
#elif SYS == 2 
	#include "vax.h" 
#elif SYS == 3 
	#include "mac.h" 
#else 
	#include "general.h" 
#endif 
```

条件编译还有一个用途是让程序更容易移植。改变文件开头部分的几个关键的定义，即可根据不同的系统设置不同的值和包含不同的文件。 

#### 预定义宏

![](E:\Note\Code Language\the-c\picture\basic\8-3.png)

#### #line 和 #error

\#line 指令重置 _ _LINE_ _和 _ _FILE_ _宏报告的行号和文件名。可以这样使用 #line：

```c
#line 1000 // 把当前行号重置为1000 
#line 10 "cool.c" // 把行号重置为10，把文件名重置为cool.c 
```

\#error 指令让预处理器发出一条错误消息，该消息包含指令中的文本。如果可能的话，编译过程应该中断。可以这样使用 #error 指令： 

```c
#if _ _STDC_VERSION_ _ != 201112L 
	#error Not C11 
#endif 
// 编译以上代码生成后，输出如下：
$ gcc newish.c 
newish.c:14:2: error: #error Not C11 
$ gcc -std=c11 newish.c 
$
```

#### #prama 指令

在现在的编译器中，可以通过命令行参数或IDE菜单修改编译器的一些设置。#pragma 把编译器指令放入源代码中。例如，在开发 C99 时，标准被称为 C9X，可以使用下面的编译指示（pragma）让编译器支持 C9X：

```c
#pragma c9x on
```

在笔试中常遇到的 #param pack(4) 表示**指定结构、联合和类成员的封装对齐**。其实就是**改变编译器的内存对齐方式**。其中n的取值必须是 2 的幂次方，即 1、2、4、8、16 等，Windows 下默认是 8，Linux 下默认是 4。

## 内联函数(C99)

通常，**函数调用都有一定的开销，因为函数的调用过程包括建立调用、传递参数、跳转到函数代码并返回**。这个过程中 CPU 需要先将调用函数之前的一些环境到栈中，例如一些参数的值等，然后跳转到调用的函数的位置执行函数体中的运算，然后再从栈将函数调用的环境恢复，再执行函数调用之后的代码。

如果调用的函数很简单，只有几行代码量，那么函数调用中的开销就会在整个函数调用过程中占据一个比较大的比例，这时候就不如直接将这几行代码写在程序中，而不是将其作为函数。

```c
int sum(int a, int b) { return a+b;}
int main(void) {
    int a = 10, b = 20;
    printf("%d\n", sum(a+b));
	return 0;
}

// 由于 sum 函数执行的内容非常简单，因此下面的写法更好一些，节省了函数调用的开销
int main(void) {
    int a = 10, b = 20;
    printf("%d\n", a+b);
	return 0;
}
```

**使用宏使代码内联，可以避免这样的开销**。C99 还提供另一种方法：内联函数（inline function）。读者可能顾名思义地认为内联函数会用内联代码替换函数调用。其实 C99 和 C11 标准中叙述的是：“**把函数变成内联函数建议尽可能快地调用该函数，其具体效果由实现定义**”。因此，把函数变成内联函数，编译器可能会用内联代码替换函数调用，并（或）执行一些其他的优化，但是也可能不起作用。 



创建内联函数的定义有多种方法。**标准规定具有内部链接的函数可以成为内联函数**，还规定了内联函数的定义与调用该函数的代码必须在同一个文件中。因此，最简单的方法是使用函数说明符 inline 和存储类别说明符 static。通常，内联函数应定义在首次使用它的文件中，所以内联函数也相当于函数原型。

```c
#include <stdio.h> 
inline static void eatline() // 内联函数定义/原型 
{
    while (getchar() != '\n') 
    continue; 
}
int main() 
{
	... 
    eatline(); // 函数调用 
	... 
}
```

编译器查看内联函数的定义（也是原型），可能会用函数体中的代码替换 eatline() 函数调用。也就是说，效果相当于在函数调用的位置输入函数体中的代码： 

```c
#include <stdio.h> 
inline static void eatline() //内联函数定义/原型 
{
    while (getchar() != '\n') 
    continue; 
}
int main() 
{
    ... 
    while (getchar() != '\n') //替换函数调用 
    continue; 
    ... 
}
```

由于并未给内联函数预留单独的代码块，所以无法获得内联函数的地址（实际上可以获得地址，不过这样做之后，编译器会生成一个非内联函数）。另外，内联函数无法在调试器中显示。

内联函数应该比较短小。把较长的函数变成内联并未节约多少时间，因为执行函数体的时间比调用函数的时间长得多。 

编译器优化内联函数必须知道该函数定义的内容。这意味着内联函数定义与函数调用必须在同一个文件中。鉴于此，一般情况下内联函数都具有内部链接。因此，如果程序有多个文件都要使用某个内联函数，那么这些文件中都必须包含该内联函数的定义。最简单的做法是，把内联函数定义放入头文件，并在使用该内联函数的文件中包含该头文件即可。 

**一般都不在头文件中放置可执行代码，内联函数是个特例**。因为内联函数具有内部链接，所以在多个文件中定义同一个内联函数不会产生什么问题。

与 C++ 不同的是，C 还允许混合使用内联函数定义和外部函数定义（具有外部链接的函数定义）。

```c
//file1.c 
... 
inline static double square(double); 
double square(double x) { return x * x; } 
int main() 
{
	double q = square(1.3); 
	... 
}

//file2.c 
... 
double square(double x) { return (int) (x*x); } 
void spam(double v) 
{
    double kv = square(v); 
    ... 
}

//file3.c 
... 
inline double square(double x) { return (int) (x * x + 0.5); } 
void masp(double w) 
{
    double kw = square(w); 
    ... 
}
```

如上述代码所示，3个文件中都定义了 square( )函数。file1.c 文件中是 inline static 定义；file2.c 文件中是普通的函数定义（因此具有外部链接）； file3.c 文件中是 inline 定义，省略了 static。 

3 个文件中的函数都调用了 square() 函数，这会发生什么情况？。file1.c 文件中的 main() 使用 square() 的局部 static 定义。由于该定义也是 inline 定义，所以编译器有可能优化代码，也许会内联该函数。file2.c 文件中，spam() 函数使用该文件中 square() 函数的定义，该定义具有外部链接，其他文件也可见。file3.c 文件中，编译器既可以使用该文件中 square() 函数的内联定义，也可以使用 file2.c 文件中的外部链接定义。如果像 file3.c 那样，省略 file1.c 文件 inline 定义中的 static，那么该 inline 定义被视为可替换的外部定义。注意 GCC 在 C99 之前就使用一些不同的规则实现了内联函数，所以 GCC 可以根据当前编译器的标记来解释 inline。 

## 泛型选择表达式(C11新特性)

在程序设计中，泛型编程（generic programming）指那些没有特定类型，但是一旦指定一种类型，就可以转换成指定类型的代码。例如，C++ 在模板中可以创建泛型算法，然后编译器根据指定的类型自动使用实例化代 

码。

C 没有这种泛型编程。然而，C11 新增了一种表达式，叫作泛型选择表达式（generic selection expression），可根据表达式的类型（即表达式的类型是 int、double 还是其他类型）选择一个值。泛型选择表达式不是预处理器指令，但是在一些泛型编程中它常用作 #define 宏定义的一部分。下面是一个泛型选择表达式的示例： 

```c
_Generic(x, int: 0, float: 1, double: 2, default: 3)
```

\_Generic 是 C11 的关键字。\_Generic 后面的圆括号中包含多个用逗号分隔的项。第1个项是一个表达式，后面的每个项都由一个类型、一个冒号和一个值组成，如 float: 1。第1个项的类型匹配哪个标签，整个表达式的值是该标签后面的值。例如，假设上面表达式中 x 是 int 类型的变量，x 的类型匹配 int: 标签，那么整个表达式的值就是 0。如果没有与类型匹配的标签，表达式的值就是 default: 标签后面的值。**泛型选择语句与 switch 语句类似，只是前者用表达式的类型匹配标签，而后者用表达式的值匹配标签**。 

```c
#define MYTYPE(X) _Generic((X),\ 
    int: "int",\ 
    float : "float",\ 
    double: "double",\ 
    default: "other"\ 
)
```

宏必须定义为一条逻辑行，但是可以用 \ 把一条逻辑行分隔成多条物理行。在这种情况下，对泛型选择表达式求值得字符串。例如，对 MYTYPE(5) 求值得 "int"，因为值 5 的类型与 int: 标签匹配。

```c
// mytype.c 
#include <stdio.h>
#define MYTYPE(X) _Generic((X),\ 
    int: "int",\ 
    float : "float",\ 
    double: "double",\ 
    default: "other"\ 
)
int main(void) 
{
    int d = 5; 
    printf("%s\n", MYTYPE(d)); // d 是int类型 
    printf("%s\n", MYTYPE(2.0*d)); // 2.0 * d 是double类型 
    printf("%s\n", MYTYPE(3L)); // 3L是long类型 
    printf("%s\n", MYTYPE(&d)); // &d 的类型是 int * 
    return 0; 
}
```

```
// 输出结果：
int
double
other
other
```

## _Noreturn

C99 新增 inline 关键字时，它是唯一的函数说明符（关键字 extern 和 static 是存储类别说明符，可应用于数据对象和函数）。C11 新增了第2个函数说明符 _Noreturn，表明调用完成后函数不返回主调函数。exit() 函数是 _Noreturn 函数的一个示例，一旦调用 exit()，它不会再返回主调函数。

注意，这与 void 返回类型不同。void 类型的函数在执行完毕后返回主调函数，只是它不提供返回值。 

_Noreturn 的目的是告诉用户和编译器，这个特殊的函数不会把控制返回主调程序。告诉用户以免滥用该函数，通知编译器可优化一些代码。

## C 库

最初，并没有官方的 C 库。后来，基于 UNIX 的 C 实现成为了标准。ANSI C 委员会主要以这个标准为基础，开发了一个官方的标准库。在意识到 C 语言的应用范围不断扩大后，该委员会重新定义了这个库，使之可以应用于其他系统。

我们讨论过一些标准库中的 I/O 函数、字符函数和字符串函数。本章将介绍更多函数。不过，首先要学习如何使用库。

### 访问C库

如何访问C库取决于实现，因此你要了解当前系统的一般情况。

首先，可以在多个不同的位置找到库函数。例如，getchar() 函数通常作为宏定义在 stdio.h 头文件中，而 strlen() 通常在库文件中。

其次，不同的系统搜索这些函数的方法不同。下面介绍3种可能的方法：

1. **自动访问**。在一些系统中，只需编译程序，就可使用一些常用的库函数。记住，在使用函数之前必须先声明函数的类型，通过包含合适的头文件即可完成。在描述库函数的用户手册中，会指出使用某函数时应包含哪个头文件。但是在一些旧系统上，可能必须自己输入函数声明。再次提醒读者，用户手册中指明了函数类型。过去，不同的实现使用的头文件名不同。ANSI C 标准把库函数分为多个系列，每个系列的函数原型都放在一个特定的头文件中。 
2. **文件包含**。如果函数被定义为宏，那么可以通过 #include 指令包含定义宏函数的文件。通常，类似的宏都放在合适名称的头文件中。例如，许多系统（包括所有的 ANSI C 系统）都有 ctype.h 文件，该文件中包含了一些确定字符性质（如大写、数字等）的宏。
3. **库包含**。在编译或链接程序的某些阶段，可能需要指定库选项。即使在自动检查标准库的系统中，也会有不常用的函数库。必须通过编译时选项显式指定这些库。注意，这个过程与包含头文件不同。头文件提供函数声明或原型，而库选项告诉系统到哪里查找函数代码。虽然这里无法涉及所有系统的细节，但是可以提醒读者应该注意什么。 

### 库描述

可以在多个地方找到函数文档。你所使用的系统可能有在线手册，集成开发环境通常都有在线帮助。C 实现的供应商可能提供描述库函数的纸质版用户手册，或者把这些材料放在 CD-ROM 中或网上。有些出版社也出版 C 库函数的参考手册。这些材料中，有些是一般材料，有些则是针对特定实现的。

阅读文档的关键是看懂函数头。许多内容随时间变化而变化。下面是旧的 UNIX 文档中，关于 fread() 的描述：

```c
#include <stdio.h> 
fread(ptr, sizeof(*ptr), nitems, stream) 
FILE *stream;
```

首先，给出了应该包含的文件，但是没有给出 fread()、ptr、sizeof(*ptr) 或 nitems 的类型。过去，默认类型都是 int，但是从描述中可以看出 ptr 是一个指针（在早期的 C 中，指针被作为整数处理）。参数 stream 声明为指向 FILE 的指针。上面的函数声明中的第 2 个参数看上去像是 sizeof 运算符，而实际上这个参数的值应该是 ptr 所指向对象的大小。虽然用 sizeof 作为参数没什么问题，但是用 int 类型的值作为参数更符合语法。

后来，上面的描述变成了： 

```c
#include <stdio.h> 
int fread(ptr, size, nitems, stream;) 
char *ptr; 
int size, nitems; 
FILE *stream; 
```

现在，所有的类型都显式说明，ptr 作为指向 char 的指针。ANSI C90 标准提供了下面的描述：

```c
#include <stdio.h> 
size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream); 
```

首先，使用了新的函数原型格式。其次，改变了一些类型。size_t 类型被定义为 sizeof 运算符的返回值类型 —— 无符号整数类型，通常是 unsigned int 或 unsigned long。stddef.h 文件中包含了 size_t 类型的 typedef 或 #define 定义。 其他文件（包括stdio.h）通过包含 stddef.h 来包含这个定义。许多函数（包括 fread()）的实际参数中都要使用 sizeof 运算符，形式参数的 size_t 类型中正好匹配这种常见的情况。

另外，ANSI C 把指向 void 的指针作为一种通用指针，用于指针指向不同类型的情况。例如，fread() 的第1个参数可能是指向一个 double 类型数组的指针，也可能是指向其他类型结构的指针。如果假设实际参数是一个指向内含20个 double 类型元素数组的指针，且形式参数是指向 void 的指针，那么编译器会选用合适的类型，不会出现类型冲突的问题。

C99/C11标准在以上的描述中加入了新的关键字 restric： 

```c
#include <stdio.h> 
size_t fread(void * restrict ptr, size_t size,size_t nmemb, FILE * restrict stream); 
```

> 复习：restric 关键字只用于指针，表示该指针是唯一指向这个对象的指针。

## C++ 项目的 extern "C" {}

C++ 的编译和 C 的编译是不同的。例如，C++ 支持函数重载，在编译时会对函数名进行一个转换，而C并不需要这个过程。

extern "C" {} 表示对于 {} 中的内容按 c 语言的语法编译。
