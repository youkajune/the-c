一般而言，程序进入循环后，在下一次循环测试之前会执行完循环体中的所有语句。continue 和 break 语句可以根据循环体中的测试结果来忽略一部分循环内容，甚至结束循环。

# continue

continue 只用在循环语句中，常搭配 if 语句使用。执行到该语句时，会跳过本次迭代的剩余部分，并开始下一轮迭代。如果 continue 语句在嵌套循环内，则只会影响包含该语句的内层循环。

```c
#include <stdio.h>
int main()
{
    char c = 0;
    while(c!='\n')
    {  //回车键结束循环
        c=getchar();
        if(c=='4' || c=='5')  //按下的是数字键4或5
            continue;  //跳过当次循环，进入下次循环
        putchar(c);
    }
    return 0;
}
```

本例我们输入的是 0123456789，当读取到 4 或 5 时，if 的条件 c=='4'||c=='5' 成立，就执行 continue 语句，结束当前循环，直接进入下一次循环，也就是说 putchar(c); 不会被执行到。而读取到其他数字时，if 的条件不成立，continue 语句不会被执行到，putchar(c); 就会输出读取到的字符。

这种情况下，使用 continue 的好处是减少主语句组中的一级缩进。当语句很长或嵌套较多时，紧凑简洁的格式提高了代码的可读性。例如我们下面演示了不使用 continue 的情况，需要将剩下的语句放在 else 中。

```c
#include <stdio.h>
int main()
{
    char c = 0;
    while(c!='\n')  //回车键结束循环
    {
        c=getchar();
        if(c=='4' || c=='5')  //按下的是数字键4或5
            continue;  //跳过当次循环，进入下次循环
        else 
        {
        	putchar(c);
        }
    }
    return 0;
}
```

continue 还可用作占位符。例如，下面的循环读取并丢弃输入的数据，直至读到行末尾： 

```c
while (getchar() != '\n');
```

当程序已经读取一行中的某些内容，要跳至下一行开始处时，这种用法很方便。问题是，一般很难注意到一个单独的分号。如果使用 continue，可读性会更高： 

```c
while (getchar() != '\n') 
	continue; 
```

# break

break 可以用在循环和 switch 中，在循环中常和 if 搭配使用。程序执行到循环中的 break 语句时，会终止包含它的循环，并继续执行下一阶段。如果 break 语句位于嵌套循环内，它只会影响包含它的当前循环。

在 for 循环中的 break 和 continue 的情况不同，执行完 break 语句后会直接执行循环后面的第 1 条语句，连更新部分也跳过。而 continue 会执行 for 循环的更新部分。

# goto

早期版本的 BASIC 和 FORTRAN 所依赖的 goto 语句，在 C 中仍然可用。但是 C 和其他两种语言不同，没有 goto 语句 C 程序也能运行良好。Kernighan 和 Ritchie 提到 goto 语句“易被滥用”，并建议“谨慎使用，或者根本不用”。

介绍一下如何使用 goto 语句。。goto 语句有两部分：goto 和标签名。标签的命名遵循变量命名规则，如下所示：`goto part2; `要让这条语句正常工作，函数还必须包含另一条标为 part2 的语句，该语句以标签名后紧跟一个冒号开始： 

```c
part2: printf("Refined analysis:\n"); 
```

原则上，根本不用在 C 程序中使用 goto 语句(可以用函数代替 goto)。

因为 goto 的出现是因为 BASIC 和 FORTRAN 的 if else 语句后面只能跟一条语句，因此需要用 goto 来实现复合语句，而 C 本身就支持用 {} 括起来的复合语句，因此不需要用到 goto 语句。

讽刺地是，虽然 C 根本不需要 goto，但是它的 goto 比其他语言的 goto 好用，因为 C 允许在标签中使用描述性的单词而不是数字。